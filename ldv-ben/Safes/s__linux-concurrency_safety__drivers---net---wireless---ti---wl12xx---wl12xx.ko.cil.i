/* Generated by Frama-C */

#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef unsigned char __u8;

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef unsigned short __u16;

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef int __s32;

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef unsigned int __u32;

#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef unsigned long long __u64;

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef signed char s8;

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef unsigned char u8;

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef unsigned short u16;

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef int s32;

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef unsigned int u32;

#line 24  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef long long s64;

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef unsigned long long u64;

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef long __kernel_long_t;

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef unsigned long __kernel_ulong_t;

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_pid_t;

#line 48  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid32_t;

#line 49  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid32_t;

#line 71  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ssize_t;

#line 87  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef long long __kernel_loff_t;

#line 88  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_time_t;

#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_clock_t;

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_timer_t;

#line 91  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_clockid_t;

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/types.h"
typedef __u16 __le16;

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/types.h"
typedef __u16 __be16;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/types.h"
typedef __u32 __le32;

#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/types.h"
typedef __u32 __be32;

#line 40  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/types.h"
typedef __u32 __wsum;

#line 12  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __u32 __kernel_dev_t;

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_dev_t dev_t;

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned short umode_t;

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_pid_t pid_t;

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_clockid_t clockid_t;

#line 29  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef _Bool bool;

#line 31  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_uid32_t uid_t;

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_gid32_t gid_t;

#line 45  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_loff_t loff_t;

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_size_t size_t;

#line 59  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_ssize_t ssize_t;

#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_time_t time_t;

#line 102  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __s32 int32_t;

#line 106  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __u8 uint8_t;

#line 108  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __u32 uint32_t;

#line 111  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __u64 uint64_t;

#line 133  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned long sector_t;

#line 134  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned long blkcnt_t;

#line 152  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef u64 dma_addr_t;

#line 157  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned int gfp_t;

#line 158  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned int fmode_t;

#line 159  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned int oom_flags_t;

#line 162  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef u64 phys_addr_t;

#line 167  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef phys_addr_t resource_size_t;

#line 177  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
struct __anonstruct_atomic_t_6 {
   int counter ;
};

#line 177  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef struct __anonstruct_atomic_t_6 atomic_t;

#line 182  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
struct __anonstruct_atomic64_t_7 {
   long counter ;
};

#line 182  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef struct __anonstruct_atomic64_t_7 atomic64_t;

#line 183  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};

#line 188 
struct hlist_node;

#line 188  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
struct hlist_head {
   struct hlist_node *first ;
};

#line 192  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};

#line 203  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
struct callback_head {
   struct callback_head *next ;
   void (*func)(struct callback_head *) ;
};

#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/page_types.h"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/ptrace.h"
struct __anonstruct_9 {
   unsigned int a ;
   unsigned int b ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/ptrace.h"
struct __anonstruct_10 {
   u16 limit0 ;
   u16 base0 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) base1 : 8 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) type : 4 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) s : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) dpl : 2 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) p : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) limit : 4 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) avl : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) l : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) d : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) g : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) base2 : 8 ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/ptrace.h"
union __anonunion_8 {
   struct __anonstruct_9 __anonCompField___anonunion_8_4 ;
   struct __anonstruct_10 __anonCompField___anonunion_8_5 ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/ptrace.h"
struct desc_struct {
   union __anonunion_8 __anonCompField_desc_struct_6 ;
};

#line 12  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pteval_t;

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgdval_t;

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgprotval_t;

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_64_types.h"
struct __anonstruct_pte_t_11 {
   pteval_t pte ;
};

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_64_types.h"
typedef struct __anonstruct_pte_t_11 pte_t;

#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_64_types.h"
struct pgprot {
   pgprotval_t pgprot ;
};

#line 218  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_types.h"
typedef struct pgprot pgprot_t;

#line 220  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pgd_t_12 {
   pgdval_t pgd ;
};

#line 220  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pgd_t_12 pgd_t;

#line 361 
struct page;

#line 361  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_types.h"
typedef struct page *pgtable_t;

#line 372 
struct file;

#line 385 
struct seq_file;

#line 423 
struct thread_struct;

#line 425 
struct mm_struct;

#line 426 
struct task_struct;

#line 427 
struct cpumask;

#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/spinlock_types.h"
struct qspinlock {
   atomic_t val ;
};

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/qspinlock_types.h"
typedef struct qspinlock arch_spinlock_t;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/qspinlock_types.h"
struct qrwlock {
   atomic_t cnts ;
   arch_spinlock_t lock ;
};

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/qrwlock_types.h"
typedef struct qrwlock arch_rwlock_t;

#line 48  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dynamic_debug.h"
struct device;

#line 54 
struct net_device;

#line 420  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/printk.h"
struct file_operations;

#line 432 
struct completion;

#line 102  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bug.h"
struct timespec;

#line 103 
struct compat_timespec;

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bug.h"
struct __anonstruct_futex_16 {
   u32 *uaddr ;
   u32 val ;
   u32 flags ;
   u32 bitset ;
   u64 time ;
   u32 *uaddr2 ;
};

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bug.h"
struct __anonstruct_nanosleep_17 {
   clockid_t clockid ;
   struct timespec *rmtp ;
   struct compat_timespec *compat_rmtp ;
   u64 expires ;
};

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bug.h"
struct __anonstruct_poll_18 {
   struct pollfd *ufds ;
   int nfds ;
   int has_timeout ;
   unsigned long tv_sec ;
   unsigned long tv_nsec ;
};

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bug.h"
union __anonunion_15 {
   struct __anonstruct_futex_16 futex ;
   struct __anonstruct_nanosleep_17 nanosleep ;
   struct __anonstruct_poll_18 poll ;
};

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bug.h"
struct restart_block {
   long (*fn)(struct restart_block *) ;
   union __anonunion_15 __anonCompField_restart_block_7 ;
};

#line 127  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/uapi/asm/vm86.h"
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/vm86.h"
union __anonunion_19 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/vm86.h"
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion_19 __anonCompField_math_emu_info_8 ;
};

#line 328  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bitmap.h"
struct cpumask {
   unsigned long bits[128U] ;
};

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cpumask.h"
typedef struct cpumask cpumask_t;

#line 652  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cpumask.h"
typedef struct cpumask *cpumask_var_t;

#line 260  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/special_insns.h"
struct fregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u32 status ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct __anonstruct_29 {
   u64 rip ;
   u64 rdp ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct __anonstruct_30 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
union __anonunion_28 {
   struct __anonstruct_29 __anonCompField___anonunion_28_12 ;
   struct __anonstruct_30 __anonCompField___anonunion_28_13 ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
union __anonunion_31 {
   u32 padding1[12U] ;
   u32 sw_reserved[12U] ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct fxregs_state {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion_28 __anonCompField_fxregs_state_14 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32U] ;
   u32 xmm_space[64U] ;
   u32 padding[12U] ;
   union __anonunion_31 __anonCompField_fxregs_state_15 ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct swregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};

#line 155  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct xstate_header {
   u64 xfeatures ;
   u64 xcomp_bv ;
   u64 reserved[6U] ;
};

#line 161  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct xregs_state {
   struct fxregs_state i387 ;
   struct xstate_header header ;
   u8 __reserved[464U] ;
};

#line 179  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
union fpregs_state {
   struct fregs_state fsave ;
   struct fxregs_state fxsave ;
   struct swregs_state soft ;
   struct xregs_state xsave ;
   u8 __padding[4096U] ;
};

#line 194  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct fpu {
   unsigned int last_cpu ;
   unsigned char fpstate_active ;
   unsigned char fpregs_active ;
   unsigned char counter ;
   union fpregs_state state ;
};

#line 170  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/processor.h"
struct seq_operations;

#line 369 
struct perf_event;

#line 370  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/processor.h"
struct thread_struct {
   struct desc_struct tls_array[3U] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long fs ;
   unsigned long gs ;
   struct perf_event *ptrace_bps[4U] ;
   unsigned long debugreg6 ;
   unsigned long ptrace_dr7 ;
   unsigned long cr2 ;
   unsigned long trap_nr ;
   unsigned long error_code ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
   struct fpu fpu ;
};

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/atomic-long.h"
typedef atomic64_t atomic_long_t;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bottom_half.h"
struct lockdep_map;

#line 55  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/debug_locks.h"
struct stack_trace {
   unsigned int nr_entries ;
   unsigned int max_entries ;
   unsigned long *entries ;
   int skip ;
};

#line 28  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/stacktrace.h"
struct lockdep_subclass_key {
   char __one_byte ;
};

#line 53  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockdep.h"
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8U] ;
};

#line 59  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockdep.h"
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct stack_trace usage_traces[13U] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
   unsigned long ops ;
   char const *name ;
   int name_version ;
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};

#line 144  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockdep.h"
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char const *name ;
   int cpu ;
   unsigned long ip ;
};

#line 205  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockdep.h"
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   u64 waittime_stamp ;
   u64 holdtime_stamp ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(13))) class_idx : 13 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) irq_context : 2 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) trylock : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) read : 2 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) check : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) hardirqs_off : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(12))) references : 12 ;
   unsigned int pin_count ;
};

#line 546  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockdep.h"
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_types.h"
typedef struct raw_spinlock raw_spinlock_t;

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_types.h"
struct __anonstruct_35 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_types.h"
union __anonunion_34 {
   struct raw_spinlock rlock ;
   struct __anonstruct_35 __anonCompField___anonunion_34_17 ;
};

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_types.h"
struct spinlock {
   union __anonunion_34 __anonCompField_spinlock_18 ;
};

#line 76  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_types.h"
typedef struct spinlock spinlock_t;

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rwlock_types.h"
struct __anonstruct_rwlock_t_36 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rwlock_types.h"
typedef struct __anonstruct_rwlock_t_36 rwlock_t;

#line 41  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.h"
struct mutex;

#line 30  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/slab.h"
struct resource {
   resource_size_t start ;
   resource_size_t end ;
   char const *name ;
   unsigned long flags ;
   struct resource *parent ;
   struct resource *sibling ;
   struct resource *child ;
};

#line 13  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/osq_lock.h"
struct optimistic_spin_queue {
   atomic_t tail ;
};

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/osq_lock.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   void *magic ;
   struct lockdep_map dep_map ;
};

#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mutex.h"
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   void *magic ;
};

#line 193  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mutex.h"
struct seqcount {
   unsigned int sequence ;
   struct lockdep_map dep_map ;
};

#line 52  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/seqlock.h"
typedef struct seqcount seqcount_t;

#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/seqlock.h"
struct __anonstruct_seqlock_t_45 {
   struct seqcount seqcount ;
   spinlock_t lock ;
};

#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/seqlock.h"
typedef struct __anonstruct_seqlock_t_45 seqlock_t;

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/wait.h"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};

#line 43  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;

#line 1170  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/wait.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};

#line 105  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/debugobjects.h"
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};

#line 437  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jiffies.h"
union ktime {
   s64 tv64 ;
};

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ktime.h"
typedef union ktime ktime_t;

#line 296  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rcupdate.h"
struct notifier_block;

#line 1120  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rcupdate.h"
union __anonunion_46 {
   unsigned long bitmap[4U] ;
   struct callback_head callback_head ;
};

#line 1120  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rcupdate.h"
struct idr_layer {
   int prefix ;
   int layer ;
   struct idr_layer *ary[256U] ;
   int count ;
   union __anonunion_46 __anonCompField_idr_layer_19 ;
};

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/idr.h"
struct idr {
   struct idr_layer *hint ;
   struct idr_layer *top ;
   int layers ;
   int cur ;
   spinlock_t lock ;
   int id_free_cnt ;
   struct idr_layer *id_free ;
};

#line 124  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/idr.h"
struct ida_bitmap {
   long nr_busy ;
   unsigned long bitmap[15U] ;
};

#line 153  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/idr.h"
struct ida {
   struct idr idr ;
   struct ida_bitmap *free_bitmap ;
};

#line 185  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/idr.h"
struct rb_node {
   unsigned long __rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
};

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};

#line 97 
struct dentry;

#line 98 
struct iattr;

#line 99 
struct vm_area_struct;

#line 100 
struct super_block;

#line 101 
struct file_system_type;

#line 102 
struct kernfs_open_node;

#line 103 
struct kernfs_iattrs;

#line 126 
struct kernfs_root;

#line 126  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rbtree.h"
struct kernfs_elem_dir {
   unsigned long subdirs ;
   struct rb_root children ;
   struct kernfs_root *root ;
};

#line 85  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_node;

#line 85  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_elem_symlink {
   struct kernfs_node *target_kn ;
};

#line 89 
struct kernfs_ops;

#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_elem_attr {
   struct kernfs_ops const *ops ;
   struct kernfs_open_node *open ;
   loff_t size ;
   struct kernfs_node *notify_next ;
};

#line 96  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
union __anonunion_51 {
   struct kernfs_elem_dir dir ;
   struct kernfs_elem_symlink symlink ;
   struct kernfs_elem_attr attr ;
};

#line 96  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_node {
   atomic_t count ;
   atomic_t active ;
   struct lockdep_map dep_map ;
   struct kernfs_node *parent ;
   char const *name ;
   struct rb_node rb ;
   void const *ns ;
   unsigned int hash ;
   union __anonunion_51 __anonCompField_kernfs_node_20 ;
   void *priv ;
   unsigned short flags ;
   umode_t mode ;
   unsigned int ino ;
   struct kernfs_iattrs *iattr ;
};

#line 138  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_syscall_ops {
   int (*remount_fs)(struct kernfs_root *, int *, char *) ;
   int (*show_options)(struct seq_file *, struct kernfs_root *) ;
   int (*mkdir)(struct kernfs_node *, char const *, umode_t ) ;
   int (*rmdir)(struct kernfs_node *) ;
   int (*rename)(struct kernfs_node *, struct kernfs_node *, char const *) ;
};

#line 155  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_root {
   struct kernfs_node *kn ;
   unsigned int flags ;
   struct ida ino_ida ;
   struct kernfs_syscall_ops *syscall_ops ;
   struct list_head supers ;
   wait_queue_head_t deactivate_waitq ;
};

#line 171 
struct vm_operations_struct;

#line 171  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_open_file {
   struct kernfs_node *kn ;
   struct file *file ;
   void *priv ;
   struct mutex mutex ;
   int event ;
   struct list_head list ;
   char *prealloc_buf ;
   size_t atomic_write_len ;
   bool mmapped ;
   struct vm_operations_struct const *vm_ops ;
};

#line 188  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_ops {
   int (*seq_show)(struct seq_file *, void *) ;
   void *(*seq_start)(struct seq_file *, loff_t *) ;
   void *(*seq_next)(struct seq_file *, void *, loff_t *) ;
   void (*seq_stop)(struct seq_file *, void *) ;
   ssize_t (*read)(struct kernfs_open_file *, char *, size_t , loff_t ) ;
   size_t atomic_write_len ;
   bool prealloc ;
   ssize_t (*write)(struct kernfs_open_file *, char *, size_t , loff_t ) ;
   int (*mmap)(struct kernfs_open_file *, struct vm_area_struct *) ;
   struct lock_class_key lockdep_key ;
};

#line 281 
struct inode;

#line 477 
struct sock;

#line 478 
struct kobject;

#line 479 
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
};

#line 485  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   bool (*current_may_mount)(void) ;
   void *(*grab_current_ns)(void) ;
   void const *(*netlink_ns)(struct sock *) ;
   void const *(*initial_ns)(void) ;
   void (*drop_ns)(void *) ;
};

#line 83  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/highuid.h"
struct user_namespace;

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uidgid.h"
struct __anonstruct_kuid_t_52 {
   uid_t val ;
};

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uidgid.h"
typedef struct __anonstruct_kuid_t_52 kuid_t;

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uidgid.h"
struct __anonstruct_kgid_t_53 {
   gid_t val ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uidgid.h"
typedef struct __anonstruct_kgid_t_53 kgid_t;

#line 139  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uidgid.h"
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   kuid_t uid ;
   kgid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};

#line 36  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/stat.h"
struct bin_attribute;

#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/stat.h"
struct attribute {
   char const *name ;
   umode_t mode ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ignore_lockdep : 1 ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};

#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysfs.h"
struct attribute_group {
   char const *name ;
   umode_t (*is_visible)(struct kobject *, struct attribute *, int ) ;
   struct attribute **attrs ;
   struct bin_attribute **bin_attrs ;
};

#line 82  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysfs.h"
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file *, struct kobject *, struct bin_attribute *, char *, loff_t , size_t ) ;
   ssize_t (*write)(struct file *, struct kobject *, struct bin_attribute *, char *, loff_t , size_t ) ;
   int (*mmap)(struct file *, struct kobject *, struct bin_attribute *, struct vm_area_struct *) ;
};

#line 155  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject *, struct attribute *, char *) ;
   ssize_t (*store)(struct kobject *, struct attribute *, char const *, size_t ) ;
};

#line 509  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysfs.h"
struct kref {
   atomic_t refcount ;
};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kref.h"
struct timer_list {
   struct hlist_node entry ;
   unsigned long expires ;
   void (*function)(unsigned long ) ;
   unsigned long data ;
   u32 flags ;
   int slack ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
   struct lockdep_map lockdep_map ;
};

#line 238  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timer.h"
struct hrtimer;

#line 239 
enum hrtimer_restart;

#line 837  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/sysctl.h"
struct ctl_table;

#line 838 
struct nsproxy;

#line 839 
struct ctl_table_root;

#line 840 
struct ctl_table_header;

#line 841 
struct ctl_dir;

#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
typedef int proc_handler(struct ctl_table *, int , void *, size_t *, loff_t *);

#line 57  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_table_poll {
   atomic_t event ;
   wait_queue_head_t wait ;
};

#line 96  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_table {
   char const *procname ;
   void *data ;
   int maxlen ;
   umode_t mode ;
   struct ctl_table *child ;
   proc_handler *proc_handler ;
   struct ctl_table_poll *poll ;
   void *extra1 ;
   void *extra2 ;
};

#line 117  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_node {
   struct rb_node node ;
   struct ctl_table_header *header ;
};

#line 122  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct __anonstruct_55 {
   struct ctl_table *ctl_table ;
   int used ;
   int count ;
   int nreg ;
};

#line 122  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
union __anonunion_54 {
   struct __anonstruct_55 __anonCompField___anonunion_54_21 ;
   struct callback_head rcu ;
};

#line 122 
struct ctl_table_set;

#line 122  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_table_header {
   union __anonunion_54 __anonCompField_ctl_table_header_22 ;
   struct completion *unregistering ;
   struct ctl_table *ctl_table_arg ;
   struct ctl_table_root *root ;
   struct ctl_table_set *set ;
   struct ctl_dir *parent ;
   struct ctl_node *node ;
};

#line 143  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_dir {
   struct ctl_table_header header ;
   struct rb_root root ;
};

#line 149  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_table_set {
   int (*is_seen)(struct ctl_table_set *) ;
   struct ctl_dir dir ;
};

#line 154  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_table_root {
   struct ctl_table_set default_set ;
   struct ctl_table_set *(*lookup)(struct ctl_table_root *, struct nsproxy *) ;
   int (*permissions)(struct ctl_table_header *, struct ctl_table *) ;
};

#line 259  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timer.h"
struct workqueue_struct;

#line 260 
struct work_struct;

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct *) ;
   struct lockdep_map lockdep_map ;
};

#line 107  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/workqueue.h"
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
   struct workqueue_struct *wq ;
   int cpu ;
};

#line 52  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kset;

#line 52 
struct kobj_type;

#line 52  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kobject {
   char const *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct kernfs_node *sd ;
   struct kref kref ;
   struct delayed_work release ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) state_initialized : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) state_in_sysfs : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) state_add_uevent_sent : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) state_remove_uevent_sent : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) uevent_suppress : 1 ;
};

#line 115  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject *) ;
   struct sysfs_ops const *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations const *(*child_ns_type)(struct kobject *) ;
   void const *(*namespace)(struct kobject *) ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kobj_uevent_env {
   char *argv[3U] ;
   char *envp[32U] ;
   int envp_idx ;
   char buf[2048U] ;
   int buflen ;
};

#line 131  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kset_uevent_ops {
   int (* const filter)(struct kset *, struct kobject *) ;
   char const *(* const name)(struct kset *, struct kobject *) ;
   int (* const uevent)(struct kset *, struct kobject *, struct kobj_uevent_env *) ;
};

#line 148  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops const *uevent_ops ;
};

#line 223 
struct klist_node;

#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/klist.h"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};

#line 95  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nodemask.h"
struct __anonstruct_nodemask_t_56 {
   unsigned long bits[16U] ;
};

#line 95  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nodemask.h"
typedef struct __anonstruct_nodemask_t_56 nodemask_t;

#line 520 
struct path;

#line 521  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nodemask.h"
struct seq_file {
   char *buf ;
   size_t size ;
   size_t from ;
   size_t count ;
   size_t pad_until ;
   loff_t index ;
   loff_t read_pos ;
   u64 version ;
   struct mutex lock ;
   struct seq_operations const *op ;
   int poll_event ;
   struct user_namespace *user_ns ;
   void *private ;
};

#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/seq_file.h"
struct seq_operations {
   void *(*start)(struct seq_file *, loff_t *) ;
   void (*stop)(struct seq_file *, void *) ;
   void *(*next)(struct seq_file *, void *, loff_t *) ;
   int (*show)(struct seq_file *, void *) ;
};

#line 222 
struct pinctrl;

#line 223 
struct pinctrl_state;

#line 194  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pinctrl/consumer.h"
struct dev_pin_info {
   struct pinctrl *p ;
   struct pinctrl_state *default_state ;
   struct pinctrl_state *sleep_state ;
   struct pinctrl_state *idle_state ;
};

#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm.h"
struct pm_message {
   int event ;
};

#line 64  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm.h"
typedef struct pm_message pm_message_t;

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device *) ;
   void (*complete)(struct device *) ;
   int (*suspend)(struct device *) ;
   int (*resume)(struct device *) ;
   int (*freeze)(struct device *) ;
   int (*thaw)(struct device *) ;
   int (*poweroff)(struct device *) ;
   int (*restore)(struct device *) ;
   int (*suspend_late)(struct device *) ;
   int (*resume_early)(struct device *) ;
   int (*freeze_late)(struct device *) ;
   int (*thaw_early)(struct device *) ;
   int (*poweroff_late)(struct device *) ;
   int (*restore_early)(struct device *) ;
   int (*suspend_noirq)(struct device *) ;
   int (*resume_noirq)(struct device *) ;
   int (*freeze_noirq)(struct device *) ;
   int (*thaw_noirq)(struct device *) ;
   int (*poweroff_noirq)(struct device *) ;
   int (*restore_noirq)(struct device *) ;
   int (*runtime_suspend)(struct device *) ;
   int (*runtime_resume)(struct device *) ;
   int (*runtime_idle)(struct device *) ;
};

#line 320 
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
};

#line 327 
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
};

#line 335 
struct wakeup_source;

#line 336 
struct wake_irq;

#line 338  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm.h"
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
   struct list_head clock_list ;
};

#line 553 
struct dev_pm_qos;

#line 553  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) can_wakeup : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) async_suspend : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_prepared : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_suspended : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_noirq_suspended : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_late_suspended : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ignore_children : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) early_init : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) direct_complete : 1 ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) wakeup_path : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) syscore : 1 ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   struct wake_irq *wakeirq ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) disable_depth : 3 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) idle_notification : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) request_pending : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) deferred_resume : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) run_wake : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) runtime_auto : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) no_callbacks : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) irq_safe : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) use_autosuspend : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) timer_autosuspends : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) memalloc_noio : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
   int autosuspend_delay ;
   unsigned long last_busy ;
   unsigned long active_jiffies ;
   unsigned long suspended_jiffies ;
   unsigned long accounting_timestamp ;
   struct pm_subsys_data *subsys_data ;
   void (*set_latency_tolerance)(struct device *, s32 ) ;
   struct dev_pm_qos *qos ;
};

#line 615  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm.h"
struct dev_pm_domain {
   struct dev_pm_ops ops ;
   void (*detach)(struct device *, bool ) ;
   int (*activate)(struct device *) ;
   void (*sync)(struct device *) ;
   void (*dismiss)(struct device *) ;
};

#line 796  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mmzone.h"
struct rw_semaphore;

#line 797  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mmzone.h"
struct rw_semaphore {
   long count ;
   struct list_head wait_list ;
   raw_spinlock_t wait_lock ;
   struct optimistic_spin_queue osq ;
   struct task_struct *owner ;
   struct lockdep_map dep_map ;
};

#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/notifier.h"
struct notifier_block {
   int (*notifier_call)(struct notifier_block *, unsigned long , void *) ;
   struct notifier_block *next ;
   int priority ;
};

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/mmu.h"
struct ldt_struct;

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/mmu.h"
struct __anonstruct_mm_context_t_121 {
   struct ldt_struct *ldt ;
   unsigned short ia32_compat ;
   struct mutex lock ;
   void *vdso ;
   atomic_t perf_rdpmc_allowed ;
};

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/mmu.h"
typedef struct __anonstruct_mm_context_t_121 mm_context_t;

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/xen/features.h"
struct bio_vec;

#line 1281  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mmzone.h"
struct llist_node;

#line 64  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/llist.h"
struct llist_node {
   struct llist_node *next ;
};

#line 428  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/gfp.h"
struct dma_map_ops;

#line 428  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/gfp.h"
struct dev_archdata {
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/device.h"
struct pdev_archdata {
   
};

#line 15 
struct device_driver;

#line 16 
struct driver_private;

#line 17 
struct class;

#line 18 
struct subsys_private;

#line 19 
struct bus_type;

#line 20 
struct device_node;

#line 21 
struct fwnode_handle;

#line 22 
struct iommu_ops;

#line 23 
struct iommu_group;

#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct device_attribute;

#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct bus_type {
   char const *name ;
   char const *dev_name ;
   struct device *dev_root ;
   struct device_attribute *dev_attrs ;
   struct attribute_group const **bus_groups ;
   struct attribute_group const **dev_groups ;
   struct attribute_group const **drv_groups ;
   int (*match)(struct device *, struct device_driver *) ;
   int (*uevent)(struct device *, struct kobj_uevent_env *) ;
   int (*probe)(struct device *) ;
   int (*remove)(struct device *) ;
   void (*shutdown)(struct device *) ;
   int (*online)(struct device *) ;
   int (*offline)(struct device *) ;
   int (*suspend)(struct device *, pm_message_t ) ;
   int (*resume)(struct device *) ;
   struct dev_pm_ops const *pm ;
   struct iommu_ops const *iommu_ops ;
   struct subsys_private *p ;
   struct lock_class_key lock_key ;
};

#line 139 
struct device_type;

#line 197 
enum probe_type {
    PROBE_DEFAULT_STRATEGY = 0,
    PROBE_PREFER_ASYNCHRONOUS = 1,
    PROBE_FORCE_SYNCHRONOUS = 2
};

#line 203 
struct of_device_id;

#line 203 
struct acpi_device_id;

#line 203  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct device_driver {
   char const *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const *mod_name ;
   bool suppress_bind_attrs ;
   enum probe_type probe_type ;
   struct of_device_id const *of_match_table ;
   struct acpi_device_id const *acpi_match_table ;
   int (*probe)(struct device *) ;
   int (*remove)(struct device *) ;
   void (*shutdown)(struct device *) ;
   int (*suspend)(struct device *, pm_message_t ) ;
   int (*resume)(struct device *) ;
   struct attribute_group const **groups ;
   struct dev_pm_ops const *pm ;
   struct driver_private *p ;
};

#line 353 
struct class_attribute;

#line 353  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct class {
   char const *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct attribute_group const **dev_groups ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device *, struct kobj_uevent_env *) ;
   char *(*devnode)(struct device *, umode_t *) ;
   void (*class_release)(struct class *) ;
   void (*dev_release)(struct device *) ;
   int (*suspend)(struct device *, pm_message_t ) ;
   int (*resume)(struct device *) ;
   struct kobj_ns_type_operations const *ns_type ;
   void const *(*namespace)(struct device *) ;
   struct dev_pm_ops const *pm ;
   struct subsys_private *p ;
};

#line 446  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class *, struct class_attribute *, char *) ;
   ssize_t (*store)(struct class *, struct class_attribute *, char const *, size_t ) ;
};

#line 514  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct device_type {
   char const *name ;
   struct attribute_group const **groups ;
   int (*uevent)(struct device *, struct kobj_uevent_env *) ;
   char *(*devnode)(struct device *, umode_t *, kuid_t *, kgid_t *) ;
   void (*release)(struct device *) ;
   struct dev_pm_ops const *pm ;
};

#line 542  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device *, struct device_attribute *, char *) ;
   ssize_t (*store)(struct device *, struct device_attribute *, char const *, size_t ) ;
};

#line 675  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};

#line 684 
struct dma_coherent_mem;

#line 684 
struct cma;

#line 684  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const *init_name ;
   struct device_type const *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   void *driver_data ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   struct dev_pin_info *pins ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   unsigned long dma_pfn_offset ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct cma *cma_area ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   struct fwnode_handle *fwnode ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group const **groups ;
   void (*release)(struct device *) ;
   struct iommu_group *iommu_group ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) offline_disabled : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) offline : 1 ;
};

#line 830  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct wakeup_source {
   char const *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct wake_irq *wakeirq ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   ktime_t start_prevent_time ;
   ktime_t prevent_sleep_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long expire_count ;
   unsigned long wakeup_count ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) active : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) autosleep_enabled : 1 ;
};

#line 13  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mod_devicetable.h"
typedef unsigned long kernel_ulong_t;

#line 186  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mod_devicetable.h"
struct acpi_device_id {
   __u8 id[9U] ;
   kernel_ulong_t driver_data ;
   __u32 cls ;
   __u32 cls_msk ;
};

#line 221  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mod_devicetable.h"
struct of_device_id {
   char name[32U] ;
   char type[32U] ;
   char compatible[128U] ;
   void const *data ;
};

#line 476  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mod_devicetable.h"
struct platform_device_id {
   char name[20U] ;
   kernel_ulong_t driver_data ;
};

#line 652 
struct mfd_cell;

#line 653  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mod_devicetable.h"
struct platform_device {
   char const *name ;
   int id ;
   bool id_auto ;
   struct device dev ;
   u32 num_resources ;
   struct resource *resource ;
   struct platform_device_id const *id_entry ;
   char *driver_override ;
   struct mfd_cell *mfd_cell ;
   struct pdev_archdata archdata ;
};

#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uprobes.h"
struct arch_uprobe_task {
   unsigned long saved_scratch_register ;
   unsigned int saved_trap_nr ;
   unsigned int saved_tf ;
};

#line 66 
enum uprobe_task_state {
    UTASK_RUNNING = 0,
    UTASK_SSTEP = 1,
    UTASK_SSTEP_ACK = 2,
    UTASK_SSTEP_TRAPPED = 3
};

#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uprobes.h"
struct __anonstruct_156 {
   struct arch_uprobe_task autask ;
   unsigned long vaddr ;
};

#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uprobes.h"
struct __anonstruct_157 {
   struct callback_head dup_xol_work ;
   unsigned long dup_xol_addr ;
};

#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uprobes.h"
union __anonunion_155 {
   struct __anonstruct_156 __anonCompField___anonunion_155_35 ;
   struct __anonstruct_157 __anonCompField___anonunion_155_36 ;
};

#line 73 
struct uprobe;

#line 73 
struct return_instance;

#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uprobes.h"
struct uprobe_task {
   enum uprobe_task_state state ;
   union __anonunion_155 __anonCompField_uprobe_task_37 ;
   struct uprobe *active_uprobe ;
   unsigned long xol_vaddr ;
   struct return_instance *return_instances ;
   unsigned int depth ;
};

#line 94  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uprobes.h"
struct xol_area;

#line 95  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uprobes.h"
struct uprobes_state {
   struct xol_area *xol_area ;
};

#line 133 
struct address_space;

#line 134 
struct mem_cgroup;

#line 31  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
typedef void compound_page_dtor(struct page *);

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
union __anonunion_158 {
   struct address_space *mapping ;
   void *s_mem ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
union __anonunion_160 {
   unsigned long index ;
   void *freelist ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct __anonstruct_164 {
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))) inuse : 16 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(15))) objects : 15 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) frozen : 1 ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
union __anonunion_163 {
   atomic_t _mapcount ;
   struct __anonstruct_164 __anonCompField___anonunion_163_40 ;
   int units ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct __anonstruct_162 {
   union __anonunion_163 __anonCompField___anonstruct_162_41 ;
   atomic_t _count ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
union __anonunion_161 {
   unsigned long counters ;
   struct __anonstruct_162 __anonCompField___anonunion_161_42 ;
   unsigned int active ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct __anonstruct_159 {
   union __anonunion_160 __anonCompField___anonstruct_159_39 ;
   union __anonunion_161 __anonCompField___anonstruct_159_43 ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct __anonstruct_166 {
   struct page *next ;
   int pages ;
   int pobjects ;
};

#line 32 
struct slab;

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct __anonstruct_167 {
   compound_page_dtor *compound_dtor ;
   unsigned long compound_order ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
union __anonunion_165 {
   struct list_head lru ;
   struct __anonstruct_166 __anonCompField___anonunion_165_45 ;
   struct slab *slab_page ;
   struct callback_head callback_head ;
   struct __anonstruct_167 __anonCompField___anonunion_165_46 ;
   pgtable_t pmd_huge_pte ;
};

#line 32 
struct kmem_cache;

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
union __anonunion_168 {
   unsigned long private ;
   spinlock_t *ptl ;
   struct kmem_cache *slab_cache ;
   struct page *first_page ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct page {
   unsigned long flags ;
   union __anonunion_158 __anonCompField_page_38 ;
   struct __anonstruct_159 __anonCompField_page_44 ;
   union __anonunion_165 __anonCompField_page_47 ;
   union __anonunion_168 __anonCompField_page_48 ;
   struct mem_cgroup *mem_cgroup ;
};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct page_frag {
   struct page *page ;
   __u32 offset ;
   __u32 size ;
};

#line 257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct __anonstruct_shared_169 {
   struct rb_node rb ;
   unsigned long rb_subtree_last ;
};

#line 257 
struct anon_vma;

#line 257 
struct mempolicy;

#line 257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct vm_area_struct {
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   struct rb_node vm_rb ;
   unsigned long rb_subtree_gap ;
   struct mm_struct *vm_mm ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   struct __anonstruct_shared_169 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct const *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   struct mempolicy *vm_policy ;
};

#line 325  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};

#line 331  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};

#line 344  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct task_rss_stat {
   int events ;
   int count[3U] ;
};

#line 352  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct mm_rss_stat {
   atomic_long_t count[3U] ;
};

#line 357 
struct kioctx_table;

#line 358 
struct linux_binfmt;

#line 358 
struct mmu_notifier_mm;

#line 358  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   u32 vmacache_seqnum ;
   unsigned long (*get_unmapped_area)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ) ;
   unsigned long mmap_base ;
   unsigned long mmap_legacy_base ;
   unsigned long task_size ;
   unsigned long highest_vm_end ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   atomic_long_t nr_ptes ;
   atomic_long_t nr_pmds ;
   int map_count ;
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long pinned_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long def_flags ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[46U] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   cpumask_var_t cpu_vm_mask_var ;
   mm_context_t context ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct kioctx_table *ioctx_table ;
   struct task_struct *owner ;
   struct file *exe_file ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   struct cpumask cpumask_allocation ;
   unsigned long numa_next_scan ;
   unsigned long numa_scan_offset ;
   int numa_scan_seq ;
   bool tlb_flush_pending ;
   struct uprobes_state uprobes_state ;
   void *bd_addr ;
};

#line 158  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kmemcheck.h"
struct iovec {
   void *iov_base ;
   __kernel_size_t iov_len ;
};

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/uio.h"
struct kvec {
   void *iov_base ;
   size_t iov_len ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uio.h"
union __anonunion_171 {
   struct iovec const *iov ;
   struct kvec const *kvec ;
   struct bio_vec const *bvec ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uio.h"
struct iov_iter {
   int type ;
   size_t iov_offset ;
   size_t count ;
   union __anonunion_171 __anonCompField_iov_iter_49 ;
   unsigned long nr_segs ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/socket.h"
typedef unsigned short __kernel_sa_family_t;

#line 18 
struct pid;

#line 19 
struct cred;

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/socket.h"
typedef __kernel_sa_family_t sa_family_t;

#line 24  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14U] ;
};

#line 38 
struct kiocb;

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/socket.h"
struct msghdr {
   void *msg_name ;
   int msg_namelen ;
   struct iov_iter msg_iter ;
   void *msg_control ;
   __kernel_size_t msg_controllen ;
   unsigned int msg_flags ;
   struct kiocb *msg_iocb ;
};

#line 217  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/fcntl.h"
enum ldv_15872 {
    SS_FREE = 0,
    SS_UNCONNECTED = 1,
    SS_CONNECTING = 2,
    SS_CONNECTED = 3,
    SS_DISCONNECTING = 4
};

#line 53  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/net.h"
typedef enum ldv_15872 socket_state;

#line 55 
struct pipe_inode_info;

#line 56 
struct net;

#line 73 
struct fasync_struct;

#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/net.h"
struct socket_wq {
   wait_queue_head_t wait ;
   struct fasync_struct *fasync_list ;
   struct callback_head rcu ;
};

#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/net.h"
struct proto_ops;

#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/net.h"
struct socket {
   socket_state state ;
   short type ;
   unsigned long flags ;
   struct socket_wq *wq ;
   struct file *file ;
   struct sock *sk ;
   struct proto_ops const *ops ;
};

#line 119  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/net.h"
struct proto_ops {
   int family ;
   struct module *owner ;
   int (*release)(struct socket *) ;
   int (*bind)(struct socket *, struct sockaddr *, int ) ;
   int (*connect)(struct socket *, struct sockaddr *, int , int ) ;
   int (*socketpair)(struct socket *, struct socket *) ;
   int (*accept)(struct socket *, struct socket *, int ) ;
   int (*getname)(struct socket *, struct sockaddr *, int *, int ) ;
   unsigned int (*poll)(struct file *, struct socket *, struct poll_table_struct *) ;
   int (*ioctl)(struct socket *, unsigned int , unsigned long ) ;
   int (*compat_ioctl)(struct socket *, unsigned int , unsigned long ) ;
   int (*listen)(struct socket *, int ) ;
   int (*shutdown)(struct socket *, int ) ;
   int (*setsockopt)(struct socket *, int , int , char *, unsigned int ) ;
   int (*getsockopt)(struct socket *, int , int , char *, int *) ;
   int (*compat_setsockopt)(struct socket *, int , int , char *, unsigned int ) ;
   int (*compat_getsockopt)(struct socket *, int , int , char *, int *) ;
   int (*sendmsg)(struct socket *, struct msghdr *, size_t ) ;
   int (*recvmsg)(struct socket *, struct msghdr *, size_t , int ) ;
   int (*mmap)(struct file *, struct socket *, struct vm_area_struct *) ;
   ssize_t (*sendpage)(struct socket *, struct page *, int , size_t , int ) ;
   ssize_t (*splice_read)(struct socket *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ) ;
   int (*set_peek_off)(struct sock *, int ) ;
};

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/capability.h"
struct kernel_cap_struct {
   __u32 cap[2U] ;
};

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/capability.h"
typedef struct kernel_cap_struct kernel_cap_t;

#line 84  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/plist.h"
struct plist_node {
   int prio ;
   struct list_head prio_list ;
   struct list_head node_list ;
};

#line 4  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/cputime_jiffies.h"
typedef unsigned long cputime_t;

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sem.h"
struct sem_undo_list;

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sem.h"
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};

#line 78  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/shm.h"
struct user_struct;

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/shm.h"
struct sysv_shm {
   struct list_head shm_clist ;
};

#line 24  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/signal.h"
struct __anonstruct_sigset_t_173 {
   unsigned long sig[1U] ;
};

#line 24  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/signal.h"
typedef struct __anonstruct_sigset_t_173 sigset_t;

#line 25 
struct siginfo;

#line 17  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/signal-defs.h"
typedef void __signalfn_t(int );

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/signal-defs.h"
typedef __signalfn_t *__sighandler_t;

#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/signal-defs.h"
typedef void __restorefn_t(void);

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/signal-defs.h"
typedef __restorefn_t *__sigrestore_t;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/signal.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};

#line 10  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
typedef union sigval sigval_t;

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__kill_175 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__timer_176 {
   __kernel_timer_t _tid ;
   int _overrun ;
   char _pad[0U] ;
   sigval_t _sigval ;
   int _sys_private ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__rt_177 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigchld_178 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__addr_bnd_180 {
   void *_lower ;
   void *_upper ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigfault_179 {
   void *_addr ;
   short _addr_lsb ;
   struct __anonstruct__addr_bnd_180 _addr_bnd ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigpoll_181 {
   long _band ;
   int _fd ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigsys_182 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
union __anonunion__sifields_174 {
   int _pad[28U] ;
   struct __anonstruct__kill_175 _kill ;
   struct __anonstruct__timer_176 _timer ;
   struct __anonstruct__rt_177 _rt ;
   struct __anonstruct__sigchld_178 _sigchld ;
   struct __anonstruct__sigfault_179 _sigfault ;
   struct __anonstruct__sigpoll_181 _sigpoll ;
   struct __anonstruct__sigsys_182 _sigsys ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_174 _sifields ;
};

#line 113  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
typedef struct siginfo siginfo_t;

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/signal.h"
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};

#line 243  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/signal.h"
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};

#line 257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/signal.h"
struct k_sigaction {
   struct sigaction sa ;
};

#line 443 
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
};

#line 450 
struct pid_namespace;

#line 450  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/signal.h"
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};

#line 56  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pid.h"
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3U] ;
   struct callback_head rcu ;
   struct upid numbers[1U] ;
};

#line 68  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pid.h"
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};

#line 174  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pid.h"
struct percpu_counter {
   raw_spinlock_t lock ;
   s64 count ;
   struct list_head list ;
   s32 *counters ;
};

#line 53  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/seccomp.h"
struct seccomp_filter;

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/seccomp.h"
struct seccomp {
   int mode ;
   struct seccomp_filter *filter ;
};

#line 40  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rtmutex.h"
struct rt_mutex_waiter;

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/resource.h"
struct rlimit {
   __kernel_ulong_t rlim_cur ;
   __kernel_ulong_t rlim_max ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/resource.h"
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};

#line 12  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timerqueue.h"
struct timerqueue_head {
   struct rb_root head ;
   struct timerqueue_node *next ;
};

#line 50 
struct hrtimer_clock_base;

#line 51 
struct hrtimer_cpu_base;

#line 60 
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
};

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timerqueue.h"
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer *) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/hrtimer.h"
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   int index ;
   clockid_t clockid ;
   struct timerqueue_head active ;
   ktime_t (*get_time)(void) ;
   ktime_t offset ;
};

#line 156  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/hrtimer.h"
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   seqcount_t seq ;
   struct hrtimer *running ;
   unsigned int cpu ;
   unsigned int active_bases ;
   unsigned int clock_was_set_seq ;
   bool migration_enabled ;
   bool nohz_active ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) in_hrtirq : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) hres_active : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) hang_detected : 1 ;
   ktime_t expires_next ;
   struct hrtimer *next_timer ;
   unsigned int nr_events ;
   unsigned int nr_retries ;
   unsigned int nr_hangs ;
   unsigned int max_hang_time ;
   struct hrtimer_clock_base clock_base[4U] ;
};

#line 466  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/hrtimer.h"
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};

#line 45  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/task_io_accounting.h"
struct latency_record {
   unsigned long backtrace[12U] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/latencytop.h"
struct assoc_array_ptr;

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/latencytop.h"
struct assoc_array {
   struct assoc_array_ptr *root ;
   unsigned long nr_leaves_on_tree ;
};

#line 31  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
typedef int32_t key_serial_t;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
typedef uint32_t key_perm_t;

#line 35 
struct key;

#line 36 
struct signal_struct;

#line 37 
struct key_type;

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
struct keyring_index_key {
   struct key_type *type ;
   char const *description ;
   size_t desc_len ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
union __anonunion_189 {
   struct list_head graveyard_link ;
   struct rb_node serial_node ;
};

#line 123 
struct key_user;

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
union __anonunion_190 {
   time_t expiry ;
   time_t revoked_at ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
struct __anonstruct_192 {
   struct key_type *type ;
   char *description ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
union __anonunion_191 {
   struct keyring_index_key index_key ;
   struct __anonstruct_192 __anonCompField___anonunion_191_52 ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
union __anonunion_type_data_193 {
   struct list_head link ;
   unsigned long x[2U] ;
   void *p[2U] ;
   int reject_error ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
union __anonunion_payload_195 {
   unsigned long value ;
   void *rcudata ;
   void *data ;
   void *data2[2U] ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
union __anonunion_194 {
   union __anonunion_payload_195 payload ;
   struct assoc_array keys ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   union __anonunion_189 __anonCompField_key_50 ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion_190 __anonCompField_key_51 ;
   time_t last_used_at ;
   kuid_t uid ;
   kgid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   union __anonunion_191 __anonCompField_key_53 ;
   union __anonunion_type_data_193 type_data ;
   union __anonunion_194 __anonCompField_key_54 ;
};

#line 358 
struct audit_context;

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/selinux.h"
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   kgid_t small_block[32U] ;
   kgid_t *blocks[0U] ;
};

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cred.h"
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   kuid_t uid ;
   kgid_t gid ;
   kuid_t suid ;
   kgid_t sgid ;
   kuid_t euid ;
   kgid_t egid ;
   kuid_t fsuid ;
   kgid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   struct callback_head rcu ;
};

#line 369 
struct percpu_ref;

#line 55  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/percpu-refcount.h"
typedef void percpu_ref_func_t(struct percpu_ref *);

#line 68  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/percpu-refcount.h"
struct percpu_ref {
   atomic_long_t count ;
   unsigned long percpu_count_ptr ;
   percpu_ref_func_t *release ;
   percpu_ref_func_t *confirm_switch ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) force_atomic : 1 ;
   struct callback_head rcu ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/percpu-rwsem.h"
struct cgroup;

#line 28 
struct cgroup_root;

#line 29 
struct cgroup_subsys;

#line 30 
struct cgroup_taskset;

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/percpu-rwsem.h"
struct cgroup_subsys_state {
   struct cgroup *cgroup ;
   struct cgroup_subsys *ss ;
   struct percpu_ref refcnt ;
   struct cgroup_subsys_state *parent ;
   struct list_head sibling ;
   struct list_head children ;
   int id ;
   unsigned int flags ;
   u64 serial_nr ;
   struct callback_head callback_head ;
   struct work_struct destroy_work ;
};

#line 124  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cgroup-defs.h"
struct css_set {
   atomic_t refcount ;
   struct hlist_node hlist ;
   struct list_head tasks ;
   struct list_head mg_tasks ;
   struct list_head cgrp_links ;
   struct cgroup *dfl_cgrp ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct list_head mg_preload_node ;
   struct list_head mg_node ;
   struct cgroup *mg_src_cgrp ;
   struct css_set *mg_dst_cset ;
   struct list_head e_cset_node[12U] ;
   struct callback_head callback_head ;
};

#line 197  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cgroup-defs.h"
struct cgroup {
   struct cgroup_subsys_state self ;
   unsigned long flags ;
   int id ;
   int populated_cnt ;
   struct kernfs_node *kn ;
   struct kernfs_node *procs_kn ;
   struct kernfs_node *populated_kn ;
   unsigned int subtree_control ;
   unsigned int child_subsys_mask ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct cgroup_root *root ;
   struct list_head cset_links ;
   struct list_head e_csets[12U] ;
   struct list_head pidlists ;
   struct mutex pidlist_mutex ;
   wait_queue_head_t offline_waitq ;
   struct work_struct release_agent_work ;
};

#line 270  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cgroup-defs.h"
struct cgroup_root {
   struct kernfs_root *kf_root ;
   unsigned int subsys_mask ;
   int hierarchy_id ;
   struct cgroup cgrp ;
   atomic_t nr_cgrps ;
   struct list_head root_list ;
   unsigned int flags ;
   struct idr cgroup_idr ;
   char release_agent_path[4096U] ;
   char name[64U] ;
};

#line 306  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cgroup-defs.h"
struct cftype {
   char name[64U] ;
   int private ;
   umode_t mode ;
   size_t max_write_len ;
   unsigned int flags ;
   struct cgroup_subsys *ss ;
   struct list_head node ;
   struct kernfs_ops *kf_ops ;
   u64 (*read_u64)(struct cgroup_subsys_state *, struct cftype *) ;
   s64 (*read_s64)(struct cgroup_subsys_state *, struct cftype *) ;
   int (*seq_show)(struct seq_file *, void *) ;
   void *(*seq_start)(struct seq_file *, loff_t *) ;
   void *(*seq_next)(struct seq_file *, void *, loff_t *) ;
   void (*seq_stop)(struct seq_file *, void *) ;
   int (*write_u64)(struct cgroup_subsys_state *, struct cftype *, u64 ) ;
   int (*write_s64)(struct cgroup_subsys_state *, struct cftype *, s64 ) ;
   ssize_t (*write)(struct kernfs_open_file *, char *, size_t , loff_t ) ;
   struct lock_class_key lockdep_key ;
};

#line 388  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cgroup-defs.h"
struct cgroup_subsys {
   struct cgroup_subsys_state *(*css_alloc)(struct cgroup_subsys_state *) ;
   int (*css_online)(struct cgroup_subsys_state *) ;
   void (*css_offline)(struct cgroup_subsys_state *) ;
   void (*css_released)(struct cgroup_subsys_state *) ;
   void (*css_free)(struct cgroup_subsys_state *) ;
   void (*css_reset)(struct cgroup_subsys_state *) ;
   void (*css_e_css_changed)(struct cgroup_subsys_state *) ;
   int (*can_attach)(struct cgroup_subsys_state *, struct cgroup_taskset *) ;
   void (*cancel_attach)(struct cgroup_subsys_state *, struct cgroup_taskset *) ;
   void (*attach)(struct cgroup_subsys_state *, struct cgroup_taskset *) ;
   void (*fork)(struct task_struct *) ;
   void (*exit)(struct cgroup_subsys_state *, struct cgroup_subsys_state *, struct task_struct *) ;
   void (*bind)(struct cgroup_subsys_state *) ;
   int disabled ;
   int early_init ;
   bool broken_hierarchy ;
   bool warned_broken_hierarchy ;
   int id ;
   char const *name ;
   struct cgroup_root *root ;
   struct idr css_idr ;
   struct list_head cfts ;
   struct cftype *dfl_cftypes ;
   struct cftype *legacy_cftypes ;
   unsigned int depends_on ;
};

#line 128  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct futex_pi_state;

#line 129 
struct robust_list_head;

#line 130 
struct bio_list;

#line 131 
struct fs_struct;

#line 132 
struct perf_event_context;

#line 133 
struct blk_plug;

#line 135 
struct nameidata;

#line 188 
struct cfs_rq;

#line 189 
struct task_group;

#line 477  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64U] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};

#line 516  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};

#line 524  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct cpu_itimer {
   cputime_t expires ;
   cputime_t incr ;
   u32 error ;
   u32 incr_error ;
};

#line 531  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct cputime {
   cputime_t utime ;
   cputime_t stime ;
};

#line 543  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};

#line 563  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct task_cputime_atomic {
   atomic64_t utime ;
   atomic64_t stime ;
   atomic64_t sum_exec_runtime ;
};

#line 584  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct thread_group_cputimer {
   struct task_cputime_atomic cputime_atomic ;
   int running ;
};

#line 620 
struct autogroup;

#line 621 
struct tty_struct;

#line 621 
struct taskstats;

#line 621 
struct tty_audit_buf;

#line 621  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct signal_struct {
   atomic_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
   struct list_head thread_head ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_child_subreaper : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) has_child_subreaper : 1 ;
   int posix_timer_id ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2U] ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   seqlock_t stats_lock ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   unsigned long maxrss ;
   unsigned long cmaxrss ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16U] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   unsigned int audit_tty_log_passwd ;
   struct tty_audit_buf *tty_audit_buf ;
   struct rw_semaphore group_rwsem ;
   oom_flags_t oom_flags ;
   short oom_score_adj ;
   short oom_score_adj_min ;
   struct mutex cred_guard_mutex ;
};

#line 802  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   kuid_t uid ;
   atomic_long_t locked_vm ;
};

#line 845 
struct backing_dev_info;

#line 846 
struct reclaim_state;

#line 847  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
};

#line 861  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   u64 blkio_start ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   u64 freepages_start ;
   u64 freepages_delay ;
   u32 freepages_count ;
};

#line 909  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct wake_q_node {
   struct wake_q_node *next ;
};

#line 1138 
struct io_context;

#line 1172 
struct uts_namespace;

#line 1173  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct load_weight {
   unsigned long weight ;
   u32 inv_weight ;
};

#line 1181  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sched_avg {
   u64 last_runnable_update ;
   s64 decay_count ;
   unsigned long load_avg_contrib ;
   unsigned long utilization_avg_contrib ;
   u32 runnable_avg_sum ;
   u32 avg_period ;
   u32 running_avg_sum ;
};

#line 1206  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};

#line 1241  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   int depth ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
   struct sched_avg avg ;
};

#line 1273 
struct rt_rq;

#line 1273  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned long watchdog_stamp ;
   unsigned int time_slice ;
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
};

#line 1289  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sched_dl_entity {
   struct rb_node rb_node ;
   u64 dl_runtime ;
   u64 dl_deadline ;
   u64 dl_period ;
   u64 dl_bw ;
   s64 runtime ;
   u64 deadline ;
   unsigned int flags ;
   int dl_throttled ;
   int dl_new ;
   int dl_boosted ;
   int dl_yielded ;
   struct hrtimer dl_timer ;
};

#line 1355  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct memcg_oom_info {
   struct mem_cgroup *memcg ;
   gfp_t gfp_mask ;
   int order ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) may_oom : 1 ;
};

#line 1779 
struct sched_class;

#line 1779 
struct files_struct;

#line 1779 
struct compat_robust_list_head;

#line 1779 
struct numa_group;

#line 1779 
struct ftrace_ret_stack;

#line 1779  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct task_struct {
   long volatile state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   struct llist_node wake_entry ;
   int on_cpu ;
   struct task_struct *last_wakee ;
   unsigned long wakee_flips ;
   unsigned long wakee_flip_decay_ts ;
   int wake_cpu ;
   int on_rq ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class const *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct task_group *sched_task_group ;
   struct sched_dl_entity dl ;
   struct hlist_head preempt_notifiers ;
   unsigned int btrace_seq ;
   unsigned int policy ;
   int nr_cpus_allowed ;
   cpumask_t cpus_allowed ;
   unsigned long rcu_tasks_nvcsw ;
   bool rcu_tasks_holdout ;
   struct list_head rcu_tasks_holdout_list ;
   int rcu_tasks_idle_cpu ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct rb_node pushable_dl_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   u32 vmacache_seqnum ;
   struct vm_area_struct *vmacache[4U] ;
   struct task_rss_stat rss_stat ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned long jobctl ;
   unsigned int personality ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) in_execve : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) in_iowait : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) sched_reset_on_fork : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) sched_contributes_to_load : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) sched_migrated : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) memcg_kmem_skip_account : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) brk_randomized : 1 ;
   unsigned long atomic_flags ;
   struct restart_block restart_block ;
   pid_t pid ;
   pid_t tgid ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3U] ;
   struct list_head thread_group ;
   struct list_head thread_node ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   u64 start_time ;
   u64 real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct cred const *real_cred ;
   struct cred const *cred ;
   char comm[16U] ;
   struct nameidata *nameidata ;
   struct sysv_sem sysvsem ;
   struct sysv_shm sysvshm ;
   unsigned long last_switch_count ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void *) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct callback_head *task_works ;
   struct audit_context *audit_context ;
   kuid_t loginuid ;
   unsigned int sessionid ;
   struct seccomp seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   raw_spinlock_t pi_lock ;
   struct wake_q_node wake_q ;
   struct rb_root pi_waiters ;
   struct rb_node *pi_waiters_leftmost ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct mutex_waiter *blocked_on ;
   unsigned int irq_events ;
   unsigned long hardirq_enable_ip ;
   unsigned long hardirq_disable_ip ;
   unsigned int hardirq_enable_event ;
   unsigned int hardirq_disable_event ;
   int hardirqs_enabled ;
   int hardirq_context ;
   unsigned long softirq_disable_ip ;
   unsigned long softirq_enable_ip ;
   unsigned int softirq_disable_event ;
   unsigned int softirq_enable_event ;
   int softirqs_enabled ;
   int softirq_context ;
   u64 curr_chain_key ;
   int lockdep_depth ;
   unsigned int lockdep_recursion ;
   struct held_lock held_locks[48U] ;
   gfp_t lockdep_reclaim_gfp ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   seqcount_t mems_allowed_seq ;
   int cpuset_mem_spread_rotor ;
   int cpuset_slab_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct perf_event_context *perf_event_ctxp[2U] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_next ;
   short pref_node_fork ;
   int numa_scan_seq ;
   unsigned int numa_scan_period ;
   unsigned int numa_scan_period_max ;
   int numa_preferred_nid ;
   unsigned long numa_migrate_retry ;
   u64 node_stamp ;
   u64 last_task_numa_placement ;
   u64 last_sum_exec_runtime ;
   struct callback_head numa_work ;
   struct list_head numa_entry ;
   struct numa_group *numa_group ;
   unsigned long *numa_faults ;
   unsigned long total_numa_faults ;
   unsigned long numa_faults_locality[3U] ;
   unsigned long numa_pages_migrated ;
   struct callback_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct page_frag task_frag ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   int nr_dirtied ;
   int nr_dirtied_pause ;
   unsigned long dirty_paused_when ;
   int latency_record_count ;
   struct latency_record latency_record[32U] ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   unsigned int kasan_depth ;
   int curr_ret_stack ;
   struct ftrace_ret_stack *ret_stack ;
   unsigned long long ftrace_timestamp ;
   atomic_t trace_overrun ;
   atomic_t tracing_graph_pause ;
   unsigned long trace ;
   unsigned long trace_recursion ;
   struct memcg_oom_info memcg_oom ;
   struct uprobe_task *utask ;
   unsigned int sequential_io ;
   unsigned int sequential_io_avg ;
   unsigned long task_state_change ;
   int pagefault_disabled ;
   struct thread_struct thread ;
};

#line 161  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/checksum_64.h"
struct in6_addr;

#line 140  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/checksum.h"
struct sk_buff;

#line 187  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/checksum.h"
struct dma_attrs {
   unsigned long flags[1U] ;
};

#line 70  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dma-attrs.h"
enum dma_data_direction {
    DMA_BIDIRECTIONAL = 0,
    DMA_TO_DEVICE = 1,
    DMA_FROM_DEVICE = 2,
    DMA_NONE = 3
};

#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bit_spinlock.h"
struct shrink_control {
   gfp_t gfp_mask ;
   unsigned long nr_to_scan ;
   int nid ;
   struct mem_cgroup *memcg ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/shrinker.h"
struct shrinker {
   unsigned long (*count_objects)(struct shrinker *, struct shrink_control *) ;
   unsigned long (*scan_objects)(struct shrinker *, struct shrink_control *) ;
   int seeks ;
   long batch ;
   unsigned long flags ;
   struct list_head list ;
   atomic_long_t *nr_deferred ;
};

#line 64  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/page_ext.h"
struct file_ra_state;

#line 65 
struct writeback_control;

#line 66 
struct bdi_writeback;

#line 207  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm.h"
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *cow_page ;
   struct page *page ;
   unsigned long max_pgoff ;
   pte_t *pte ;
};

#line 239  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm.h"
struct vm_operations_struct {
   void (*open)(struct vm_area_struct *) ;
   void (*close)(struct vm_area_struct *) ;
   int (*fault)(struct vm_area_struct *, struct vm_fault *) ;
   void (*map_pages)(struct vm_area_struct *, struct vm_fault *) ;
   int (*page_mkwrite)(struct vm_area_struct *, struct vm_fault *) ;
   int (*pfn_mkwrite)(struct vm_area_struct *, struct vm_fault *) ;
   int (*access)(struct vm_area_struct *, unsigned long , void *, int , int ) ;
   char const *(*name)(struct vm_area_struct *) ;
   int (*set_policy)(struct vm_area_struct *, struct mempolicy *) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct *, unsigned long ) ;
   struct page *(*find_special_page)(struct vm_area_struct *, unsigned long ) ;
};

#line 2291  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm.h"
struct scatterlist {
   unsigned long sg_magic ;
   unsigned long page_link ;
   unsigned int offset ;
   unsigned int length ;
   dma_addr_t dma_address ;
   unsigned int dma_length ;
};

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/scatterlist.h"
struct sg_table {
   struct scatterlist *sgl ;
   unsigned int nents ;
   unsigned int orig_nents ;
};

#line 380  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/scatterlist.h"
struct dma_map_ops {
   void *(*alloc)(struct device *, size_t , dma_addr_t *, gfp_t , struct dma_attrs *) ;
   void (*free)(struct device *, size_t , void *, dma_addr_t , struct dma_attrs *) ;
   int (*mmap)(struct device *, struct vm_area_struct *, void *, dma_addr_t , size_t , struct dma_attrs *) ;
   int (*get_sgtable)(struct device *, struct sg_table *, void *, dma_addr_t , size_t , struct dma_attrs *) ;
   dma_addr_t (*map_page)(struct device *, struct page *, unsigned long , size_t , enum dma_data_direction , struct dma_attrs *) ;
   void (*unmap_page)(struct device *, dma_addr_t , size_t , enum dma_data_direction , struct dma_attrs *) ;
   int (*map_sg)(struct device *, struct scatterlist *, int , enum dma_data_direction , struct dma_attrs *) ;
   void (*unmap_sg)(struct device *, struct scatterlist *, int , enum dma_data_direction , struct dma_attrs *) ;
   void (*sync_single_for_cpu)(struct device *, dma_addr_t , size_t , enum dma_data_direction ) ;
   void (*sync_single_for_device)(struct device *, dma_addr_t , size_t , enum dma_data_direction ) ;
   void (*sync_sg_for_cpu)(struct device *, struct scatterlist *, int , enum dma_data_direction ) ;
   void (*sync_sg_for_device)(struct device *, struct scatterlist *, int , enum dma_data_direction ) ;
   int (*mapping_error)(struct device *, dma_addr_t ) ;
   int (*dma_supported)(struct device *, u64 ) ;
   int (*set_dma_mask)(struct device *, u64 ) ;
   int is_phys ;
};

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdev_features.h"
typedef u64 netdev_features_t;

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdev_features.h"
union __anonunion_in6_u_210 {
   __u8 u6_addr8[16U] ;
   __be16 u6_addr16[8U] ;
   __be32 u6_addr32[4U] ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdev_features.h"
struct in6_addr {
   union __anonunion_in6_u_210 in6_u ;
};

#line 46  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/in6.h"
struct ethhdr {
   unsigned char h_dest[6U] ;
   unsigned char h_source[6U] ;
   __be16 h_proto ;
};

#line 218  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flow_dissector.h"
struct pipe_buf_operations;

#line 218  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flow_dissector.h"
struct pipe_buffer {
   struct page *page ;
   unsigned int offset ;
   unsigned int len ;
   struct pipe_buf_operations const *ops ;
   unsigned int flags ;
   unsigned long private ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pipe_fs_i.h"
struct pipe_inode_info {
   struct mutex mutex ;
   wait_queue_head_t wait ;
   unsigned int nrbufs ;
   unsigned int curbuf ;
   unsigned int buffers ;
   unsigned int readers ;
   unsigned int writers ;
   unsigned int files ;
   unsigned int waiting_writers ;
   unsigned int r_counter ;
   unsigned int w_counter ;
   struct page *tmp_page ;
   struct fasync_struct *fasync_readers ;
   struct fasync_struct *fasync_writers ;
   struct pipe_buffer *bufs ;
};

#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pipe_fs_i.h"
struct pipe_buf_operations {
   int can_merge ;
   int (*confirm)(struct pipe_inode_info *, struct pipe_buffer *) ;
   void (*release)(struct pipe_inode_info *, struct pipe_buffer *) ;
   int (*steal)(struct pipe_inode_info *, struct pipe_buffer *) ;
   void (*get)(struct pipe_inode_info *, struct pipe_buffer *) ;
};

#line 86  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/splice.h"
struct napi_struct;

#line 87  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/splice.h"
struct nf_conntrack {
   atomic_t use ;
};

#line 166  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
enum ldv_22576 {
    BRNF_PROTO_UNCHANGED = 0,
    BRNF_PROTO_8021Q = 1,
    BRNF_PROTO_PPPOE = 2
};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_215 {
   struct net_device *physoutdev ;
   char neigh_header[8U] ;
};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_216 {
   __be32 ipv4_daddr ;
   struct in6_addr ipv6_daddr ;
};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct nf_bridge_info {
   atomic_t use ;
   enum ldv_22576 __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) orig_proto : 8 ;
   bool pkt_otherhost ;
   __u16 frag_max_size ;
   unsigned int mask ;
   struct net_device *physindev ;
   union __anonunion_215 __anonCompField_nf_bridge_info_61 ;
   union __anonunion_216 __anonCompField_nf_bridge_info_62 ;
};

#line 189  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct sk_buff_head {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   __u32 qlen ;
   spinlock_t lock ;
};

#line 403  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
typedef unsigned int sk_buff_data_t;

#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct __anonstruct_219 {
   u32 stamp_us ;
   u32 stamp_jiffies ;
};

#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_218 {
   u64 v64 ;
   struct __anonstruct_219 __anonCompField___anonunion_218_63 ;
};

#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct skb_mstamp {
   union __anonunion_218 __anonCompField_skb_mstamp_64 ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_222 {
   ktime_t tstamp ;
   struct skb_mstamp skb_mstamp ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct __anonstruct_221 {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   union __anonunion_222 __anonCompField___anonstruct_221_65 ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_220 {
   struct __anonstruct_221 __anonCompField___anonunion_220_66 ;
   struct rb_node rbnode ;
};

#line 457 
struct sec_path;

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct __anonstruct_224 {
   __u16 csum_start ;
   __u16 csum_offset ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_223 {
   __wsum csum ;
   struct __anonstruct_224 __anonCompField___anonunion_223_68 ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_225 {
   unsigned int napi_id ;
   unsigned int sender_cpu ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_226 {
   __u32 mark ;
   __u32 reserved_tailroom ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_227 {
   __be16 inner_protocol ;
   __u8 inner_ipproto ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct sk_buff {
   union __anonunion_220 __anonCompField_sk_buff_67 ;
   struct sock *sk ;
   struct net_device *dev ;
   char cb[48U] ;
   unsigned long _skb_refdst ;
   void (*destructor)(struct sk_buff *) ;
   struct sec_path *sp ;
   struct nf_conntrack *nfct ;
   struct nf_bridge_info *nf_bridge ;
   unsigned int len ;
   unsigned int data_len ;
   __u16 mac_len ;
   __u16 hdr_len ;
   __u16 queue_mapping ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) cloned : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) nohdr : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) fclone : 2 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) peeked : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) head_frag : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) xmit_more : 1 ;
   __u32 headers_start[0U] ;
   __u8 __pkt_type_offset[0U] ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) pkt_type : 3 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) pfmemalloc : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ignore_df : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) nfctinfo : 3 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) nf_trace : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) ip_summed : 2 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ooo_okay : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) l4_hash : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) sw_hash : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) wifi_acked_valid : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) wifi_acked : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) no_fcs : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) encapsulation : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) encap_hdr_csum : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) csum_valid : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) csum_complete_sw : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) csum_level : 2 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) csum_bad : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) ndisc_nodetype : 2 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ipvs_property : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) inner_protocol_type : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) remcsum_offload : 1 ;
   __u16 tc_index ;
   __u16 tc_verd ;
   union __anonunion_223 __anonCompField_sk_buff_69 ;
   __u32 priority ;
   int skb_iif ;
   __u32 hash ;
   __be16 vlan_proto ;
   __u16 vlan_tci ;
   union __anonunion_225 __anonCompField_sk_buff_70 ;
   __u32 secmark ;
   union __anonunion_226 __anonCompField_sk_buff_71 ;
   union __anonunion_227 __anonCompField_sk_buff_72 ;
   __u16 inner_transport_header ;
   __u16 inner_network_header ;
   __u16 inner_mac_header ;
   __be16 protocol ;
   __u16 transport_header ;
   __u16 network_header ;
   __u16 mac_header ;
   __u32 headers_end[0U] ;
   sk_buff_data_t tail ;
   sk_buff_data_t end ;
   unsigned char *head ;
   unsigned char *data ;
   unsigned int truesize ;
   atomic_t users ;
};

#line 718 
struct dst_entry;

#line 1161  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ieee80211.h"
struct ieee80211_p2p_noa_desc {
   u8 count ;
   __le32 duration ;
   __le32 interval ;
   __le32 start_time ;
};

#line 1180  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ieee80211.h"
struct ieee80211_p2p_noa_attr {
   u8 index ;
   u8 oppps_ctwindow ;
   struct ieee80211_p2p_noa_desc desc[4U] ;
};

#line 1204  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ieee80211.h"
struct ieee80211_mcs_info {
   u8 rx_mask[10U] ;
   __le16 rx_highest ;
   u8 tx_params ;
   u8 reserved[3U] ;
};

#line 1229  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ieee80211.h"
struct ieee80211_ht_cap {
   __le16 cap_info ;
   u8 ampdu_params_info ;
   struct ieee80211_mcs_info mcs ;
   __le16 extended_ht_cap_info ;
   __le32 tx_BF_cap_info ;
   u8 antenna_selection_info ;
};

#line 1354  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ieee80211.h"
struct ieee80211_vht_mcs_info {
   __le16 rx_mcs_map ;
   __le16 rx_highest ;
   __le16 tx_mcs_map ;
   __le16 tx_highest ;
};

#line 1435  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ieee80211.h"
struct ieee80211_vht_cap {
   __le32 vht_cap_info ;
   struct ieee80211_vht_mcs_info supp_mcs ;
};

#line 1182  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dmaengine.h"
struct dql {
   unsigned int num_queued ;
   unsigned int adj_limit ;
   unsigned int last_obj_cnt ;
   unsigned int limit ;
   unsigned int num_completed ;
   unsigned int prev_ovlimit ;
   unsigned int prev_num_queued ;
   unsigned int prev_last_obj_cnt ;
   unsigned int lowest_slack ;
   unsigned long slack_start_time ;
   unsigned int max_limit ;
   unsigned int min_limit ;
   unsigned int slack_hold_time ;
};

#line 43  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_sync_serial_settings_268 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
};

#line 43  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_sync_serial_settings_268 sync_serial_settings;

#line 50  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_te1_settings_269 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
   unsigned int slot_map ;
};

#line 50  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_te1_settings_269 te1_settings;

#line 55  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_raw_hdlc_proto_270 {
   unsigned short encoding ;
   unsigned short parity ;
};

#line 55  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_raw_hdlc_proto_270 raw_hdlc_proto;

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_271 {
   unsigned int t391 ;
   unsigned int t392 ;
   unsigned int n391 ;
   unsigned int n392 ;
   unsigned int n393 ;
   unsigned short lmi ;
   unsigned short dce ;
};

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_271 fr_proto;

#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_272 {
   unsigned int dlci ;
};

#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_272 fr_proto_pvc;

#line 74  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_info_273 {
   unsigned int dlci ;
   char master[16U] ;
};

#line 74  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_info_273 fr_proto_pvc_info;

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_cisco_proto_274 {
   unsigned int interval ;
   unsigned int timeout ;
};

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_cisco_proto_274 cisco_proto;

#line 117  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};

#line 177  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if.h"
union __anonunion_ifs_ifsu_275 {
   raw_hdlc_proto *raw_hdlc ;
   cisco_proto *cisco ;
   fr_proto *fr ;
   fr_proto_pvc *fr_pvc ;
   fr_proto_pvc_info *fr_pvc_info ;
   sync_serial_settings *sync ;
   te1_settings *te1 ;
};

#line 177  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if.h"
struct if_settings {
   unsigned int type ;
   unsigned int size ;
   union __anonunion_ifs_ifsu_275 ifs_ifsu ;
};

#line 195  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if.h"
union __anonunion_ifr_ifrn_276 {
   char ifrn_name[16U] ;
};

#line 195  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if.h"
union __anonunion_ifr_ifru_277 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16U] ;
   char ifru_newname[16U] ;
   void *ifru_data ;
   struct if_settings ifru_settings ;
};

#line 195  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_276 ifr_ifrn ;
   union __anonunion_ifr_ifru_277 ifr_ifru ;
};

#line 91  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kdev_t.h"
struct hlist_bl_node;

#line 91  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kdev_t.h"
struct hlist_bl_head {
   struct hlist_bl_node *first ;
};

#line 36  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list_bl.h"
struct hlist_bl_node {
   struct hlist_bl_node *next ;
   struct hlist_bl_node **pprev ;
};

#line 114  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rculist_bl.h"
struct __anonstruct_282 {
   spinlock_t lock ;
   int count ;
};

#line 114  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rculist_bl.h"
union __anonunion_281 {
   struct __anonstruct_282 __anonCompField___anonunion_281_74 ;
};

#line 114  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rculist_bl.h"
struct lockref {
   union __anonunion_281 __anonCompField_lockref_75 ;
};

#line 50  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockref.h"
struct vfsmount;

#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockref.h"
struct __anonstruct_284 {
   u32 hash ;
   u32 len ;
};

#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockref.h"
union __anonunion_283 {
   struct __anonstruct_284 __anonCompField___anonunion_283_76 ;
   u64 hash_len ;
};

#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockref.h"
struct qstr {
   union __anonunion_283 __anonCompField_qstr_77 ;
   unsigned char const *name ;
};

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dcache.h"
struct dentry_operations;

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dcache.h"
union __anonunion_d_u_285 {
   struct hlist_node d_alias ;
   struct callback_head d_rcu ;
};

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dcache.h"
struct dentry {
   unsigned int d_flags ;
   seqcount_t d_seq ;
   struct hlist_bl_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct inode *d_inode ;
   unsigned char d_iname[32U] ;
   struct lockref d_lockref ;
   struct dentry_operations const *d_op ;
   struct super_block *d_sb ;
   unsigned long d_time ;
   void *d_fsdata ;
   struct list_head d_lru ;
   struct list_head d_child ;
   struct list_head d_subdirs ;
   union __anonunion_d_u_285 d_u ;
};

#line 142  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dcache.h"
struct dentry_operations {
   int (*d_revalidate)(struct dentry *, unsigned int ) ;
   int (*d_weak_revalidate)(struct dentry *, unsigned int ) ;
   int (*d_hash)(struct dentry const *, struct qstr *) ;
   int (*d_compare)(struct dentry const *, struct dentry const *, unsigned int , char const *, struct qstr const *) ;
   int (*d_delete)(struct dentry const *) ;
   void (*d_release)(struct dentry *) ;
   void (*d_prune)(struct dentry *) ;
   void (*d_iput)(struct dentry *, struct inode *) ;
   char *(*d_dname)(struct dentry *, char *, int ) ;
   struct vfsmount *(*d_automount)(struct path *) ;
   int (*d_manage)(struct dentry *, bool ) ;
   struct inode *(*d_select_inode)(struct dentry *, unsigned int ) ;
};

#line 586  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dcache.h"
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/path.h"
struct list_lru_one {
   struct list_head list ;
   long nr_items ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list_lru.h"
struct list_lru_memcg {
   struct list_lru_one *lru[0U] ;
};

#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list_lru.h"
struct list_lru_node {
   spinlock_t lock ;
   struct list_lru_one lru ;
   struct list_lru_memcg *memcg_lrus ;
};

#line 47  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list_lru.h"
struct list_lru {
   struct list_lru_node *node ;
   struct list_head list ;
};

#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/radix-tree.h"
struct __anonstruct_289 {
   struct radix_tree_node *parent ;
   void *private_data ;
};

#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/radix-tree.h"
union __anonunion_288 {
   struct __anonstruct_289 __anonCompField___anonunion_288_78 ;
   struct callback_head callback_head ;
};

#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/radix-tree.h"
struct radix_tree_node {
   unsigned int path ;
   unsigned int count ;
   union __anonunion_288 __anonCompField_radix_tree_node_79 ;
   struct list_head private_list ;
   void *slots[64U] ;
   unsigned long tags[3U][1U] ;
};

#line 105  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/radix-tree.h"
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};

#line 45  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/semaphore.h"
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2U] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3U] ;
};

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/fiemap.h"
enum migrate_mode {
    MIGRATE_ASYNC = 0,
    MIGRATE_SYNC_LIGHT = 1,
    MIGRATE_SYNC = 2
};

#line 47 
struct block_device;

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/blk_types.h"
struct bio_vec {
   struct page *bv_page ;
   unsigned int bv_len ;
   unsigned int bv_offset ;
};

#line 60  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/fs.h"
struct export_operations;

#line 62 
struct kstatfs;

#line 63 
struct swap_info_struct;

#line 75  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   kuid_t ia_uid ;
   kgid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};

#line 212  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dqblk_xfs.h"
struct dquot;

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/projid.h"
typedef __kernel_uid32_t projid_t;

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/projid.h"
struct __anonstruct_kprojid_t_293 {
   projid_t val ;
};

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/projid.h"
typedef struct __anonstruct_kprojid_t_293 kprojid_t;

#line 166  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/quota.h"
enum quota_type {
    USRQUOTA = 0,
    GRPQUOTA = 1,
    PRJQUOTA = 2
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
typedef long long qsize_t;

#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
union __anonunion_294 {
   kuid_t uid ;
   kgid_t gid ;
   kprojid_t projid ;
};

#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct kqid {
   union __anonunion_294 __anonCompField_kqid_81 ;
   enum quota_type type ;
};

#line 184  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};

#line 206 
struct quota_format_type;

#line 207  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_max_spc_limit ;
   qsize_t dqi_max_ino_limit ;
   void *dqi_priv ;
};

#line 272  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   struct kqid dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   struct mem_dqblk dq_dqb ;
};

#line 299  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct quota_format_ops {
   int (*check_quota_file)(struct super_block *, int ) ;
   int (*read_file_info)(struct super_block *, int ) ;
   int (*write_file_info)(struct super_block *, int ) ;
   int (*free_file_info)(struct super_block *, int ) ;
   int (*read_dqblk)(struct dquot *) ;
   int (*commit_dqblk)(struct dquot *) ;
   int (*release_dqblk)(struct dquot *) ;
};

#line 310  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct dquot_operations {
   int (*write_dquot)(struct dquot *) ;
   struct dquot *(*alloc_dquot)(struct super_block *, int ) ;
   void (*destroy_dquot)(struct dquot *) ;
   int (*acquire_dquot)(struct dquot *) ;
   int (*release_dquot)(struct dquot *) ;
   int (*mark_dirty)(struct dquot *) ;
   int (*write_info)(struct super_block *, int ) ;
   qsize_t *(*get_reserved_space)(struct inode *) ;
   int (*get_projid)(struct inode *, kprojid_t *) ;
};

#line 325  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct qc_dqblk {
   int d_fieldmask ;
   u64 d_spc_hardlimit ;
   u64 d_spc_softlimit ;
   u64 d_ino_hardlimit ;
   u64 d_ino_softlimit ;
   u64 d_space ;
   u64 d_ino_count ;
   s64 d_ino_timer ;
   s64 d_spc_timer ;
   int d_ino_warns ;
   int d_spc_warns ;
   u64 d_rt_spc_hardlimit ;
   u64 d_rt_spc_softlimit ;
   u64 d_rt_space ;
   s64 d_rt_spc_timer ;
   int d_rt_spc_warns ;
};

#line 348  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct qc_type_state {
   unsigned int flags ;
   unsigned int spc_timelimit ;
   unsigned int ino_timelimit ;
   unsigned int rt_spc_timelimit ;
   unsigned int spc_warnlimit ;
   unsigned int ino_warnlimit ;
   unsigned int rt_spc_warnlimit ;
   unsigned long long ino ;
   blkcnt_t blocks ;
   blkcnt_t nextents ;
};

#line 394  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct qc_state {
   unsigned int s_incoredqs ;
   struct qc_type_state s_state[3U] ;
};

#line 405  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct qc_info {
   int i_fieldmask ;
   unsigned int i_flags ;
   unsigned int i_spc_timelimit ;
   unsigned int i_ino_timelimit ;
   unsigned int i_rt_spc_timelimit ;
   unsigned int i_spc_warnlimit ;
   unsigned int i_ino_warnlimit ;
   unsigned int i_rt_spc_warnlimit ;
};

#line 418  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct quotactl_ops {
   int (*quota_on)(struct super_block *, int , int , struct path *) ;
   int (*quota_off)(struct super_block *, int ) ;
   int (*quota_enable)(struct super_block *, unsigned int ) ;
   int (*quota_disable)(struct super_block *, unsigned int ) ;
   int (*quota_sync)(struct super_block *, int ) ;
   int (*set_info)(struct super_block *, int , struct qc_info *) ;
   int (*get_dqblk)(struct super_block *, struct kqid , struct qc_dqblk *) ;
   int (*set_dqblk)(struct super_block *, struct kqid , struct qc_dqblk *) ;
   int (*get_state)(struct super_block *, struct qc_state *) ;
   int (*rm_xquota)(struct super_block *, unsigned int ) ;
};

#line 432  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops const *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};

#line 496  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct inode *files[3U] ;
   struct mem_dqinfo info[3U] ;
   struct quota_format_ops const *ops[3U] ;
};

#line 526  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct kiocb {
   struct file *ki_filp ;
   loff_t ki_pos ;
   void (*ki_complete)(struct kiocb *, long , long ) ;
   void *private ;
   int ki_flags ;
};

#line 366  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct address_space_operations {
   int (*writepage)(struct page *, struct writeback_control *) ;
   int (*readpage)(struct file *, struct page *) ;
   int (*writepages)(struct address_space *, struct writeback_control *) ;
   int (*set_page_dirty)(struct page *) ;
   int (*readpages)(struct file *, struct address_space *, struct list_head *, unsigned int ) ;
   int (*write_begin)(struct file *, struct address_space *, loff_t , unsigned int , unsigned int , struct page **, void **) ;
   int (*write_end)(struct file *, struct address_space *, loff_t , unsigned int , unsigned int , struct page *, void *) ;
   sector_t (*bmap)(struct address_space *, sector_t ) ;
   void (*invalidatepage)(struct page *, unsigned int , unsigned int ) ;
   int (*releasepage)(struct page *, gfp_t ) ;
   void (*freepage)(struct page *) ;
   ssize_t (*direct_IO)(struct kiocb *, struct iov_iter *, loff_t ) ;
   int (*migratepage)(struct address_space *, struct page *, struct page *, enum migrate_mode ) ;
   int (*launder_page)(struct page *) ;
   int (*is_partially_uptodate)(struct page *, unsigned long , unsigned long ) ;
   void (*is_dirty_writeback)(struct page *, bool *, bool *) ;
   int (*error_remove_page)(struct address_space *, struct page *) ;
   int (*swap_activate)(struct swap_info_struct *, struct file *, sector_t *) ;
   void (*swap_deactivate)(struct file *) ;
};

#line 423  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   atomic_t i_mmap_writable ;
   struct rb_root i_mmap ;
   struct rw_semaphore i_mmap_rwsem ;
   unsigned long nrpages ;
   unsigned long nrshadows ;
   unsigned long writeback_index ;
   struct address_space_operations const *a_ops ;
   unsigned long flags ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   void *private_data ;
};

#line 443 
struct request_queue;

#line 444 
struct hd_struct;

#line 444 
struct gendisk;

#line 444  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct block_device {
   dev_t bd_dev ;
   int bd_openers ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   struct mutex bd_mutex ;
   struct list_head bd_inodes ;
   void *bd_claiming ;
   void *bd_holder ;
   int bd_holders ;
   bool bd_write_holder ;
   struct list_head bd_holder_disks ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct request_queue *bd_queue ;
   struct list_head bd_list ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};

#line 560 
struct posix_acl;

#line 561 
struct inode_operations;

#line 561  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
union __anonunion_297 {
   unsigned int const i_nlink ;
   unsigned int __i_nlink ;
};

#line 561  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
union __anonunion_298 {
   struct hlist_head i_dentry ;
   struct callback_head i_rcu ;
};

#line 561 
struct file_lock_context;

#line 561 
struct cdev;

#line 561  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
union __anonunion_299 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
   char *i_link ;
};

#line 561  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct inode {
   umode_t i_mode ;
   unsigned short i_opflags ;
   kuid_t i_uid ;
   kgid_t i_gid ;
   unsigned int i_flags ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   struct inode_operations const *i_op ;
   struct super_block *i_sb ;
   struct address_space *i_mapping ;
   void *i_security ;
   unsigned long i_ino ;
   union __anonunion_297 __anonCompField_inode_82 ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   spinlock_t i_lock ;
   unsigned short i_bytes ;
   unsigned int i_blkbits ;
   blkcnt_t i_blocks ;
   unsigned long i_state ;
   struct mutex i_mutex ;
   unsigned long dirtied_when ;
   unsigned long dirtied_time_when ;
   struct hlist_node i_hash ;
   struct list_head i_wb_list ;
   struct bdi_writeback *i_wb ;
   int i_wb_frn_winner ;
   u16 i_wb_frn_avg_time ;
   u16 i_wb_frn_history ;
   struct list_head i_lru ;
   struct list_head i_sb_list ;
   union __anonunion_298 __anonCompField_inode_83 ;
   u64 i_version ;
   atomic_t i_count ;
   atomic_t i_dio_count ;
   atomic_t i_writecount ;
   atomic_t i_readcount ;
   struct file_operations const *i_fop ;
   struct file_lock_context *i_flctx ;
   struct address_space i_data ;
   struct list_head i_devices ;
   union __anonunion_299 __anonCompField_inode_84 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct hlist_head i_fsnotify_marks ;
   void *i_private ;
};

#line 807  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   kuid_t uid ;
   kuid_t euid ;
   int signum ;
};

#line 815  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   unsigned int mmap_miss ;
   loff_t prev_pos ;
};

#line 838  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
union __anonunion_f_u_300 {
   struct llist_node fu_llist ;
   struct callback_head fu_rcuhead ;
};

#line 838  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct file {
   union __anonunion_f_u_300 f_u ;
   struct path f_path ;
   struct inode *f_inode ;
   struct file_operations const *f_op ;
   spinlock_t f_lock ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   struct mutex f_pos_lock ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred const *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct list_head f_tfile_llink ;
   struct address_space *f_mapping ;
};

#line 923  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
typedef void *fl_owner_t;

#line 924 
struct file_lock;

#line 925  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock *, struct file_lock *) ;
   void (*fl_release_private)(struct file_lock *) ;
};

#line 931  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct lock_manager_operations {
   int (*lm_compare_owner)(struct file_lock *, struct file_lock *) ;
   unsigned long (*lm_owner_key)(struct file_lock *) ;
   fl_owner_t (*lm_get_owner)(fl_owner_t ) ;
   void (*lm_put_owner)(fl_owner_t ) ;
   void (*lm_notify)(struct file_lock *) ;
   int (*lm_grant)(struct file_lock *, int ) ;
   bool (*lm_break)(struct file_lock *) ;
   int (*lm_change)(struct file_lock *, int , struct list_head *) ;
   void (*lm_setup)(struct file_lock *, void **) ;
};

#line 952 
struct nlm_lockowner;

#line 953  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nfs_fs_i.h"
struct nfs4_lock_state;

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nfs_fs_i.h"
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nfs_fs_i.h"
struct __anonstruct_afs_302 {
   struct list_head link ;
   int state ;
};

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nfs_fs_i.h"
union __anonunion_fl_u_301 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_302 afs ;
};

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nfs_fs_i.h"
struct file_lock {
   struct file_lock *fl_next ;
   struct list_head fl_list ;
   struct hlist_node fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned int fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   int fl_link_cpu ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   unsigned long fl_downgrade_time ;
   struct file_lock_operations const *fl_ops ;
   struct lock_manager_operations const *fl_lmops ;
   union __anonunion_fl_u_301 fl_u ;
};

#line 1005  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct file_lock_context {
   spinlock_t flc_lock ;
   struct list_head flc_flock ;
   struct list_head flc_posix ;
   struct list_head flc_lease ;
};

#line 1221  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct fasync_struct {
   spinlock_t fa_lock ;
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
   struct callback_head fa_rcu ;
};

#line 1256  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct sb_writers {
   struct percpu_counter counter[3U] ;
   wait_queue_head_t wait ;
   int frozen ;
   wait_queue_head_t wait_unfrozen ;
   struct lockdep_map lock_map[3U] ;
};

#line 1287 
struct super_operations;

#line 1287 
struct xattr_handler;

#line 1287 
struct mtd_info;

#line 1287  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned char s_blocksize_bits ;
   unsigned long s_blocksize ;
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations const *s_op ;
   struct dquot_operations const *dq_op ;
   struct quotactl_ops const *s_qcop ;
   struct export_operations const *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_iflags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   int s_count ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler const **s_xattr ;
   struct list_head s_inodes ;
   struct hlist_bl_head s_anon ;
   struct list_head s_mounts ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct hlist_node s_instances ;
   unsigned int s_quota_types ;
   struct quota_info s_dquot ;
   struct sb_writers s_writers ;
   char s_id[32U] ;
   u8 s_uuid[16U] ;
   void *s_fs_info ;
   unsigned int s_max_links ;
   fmode_t s_mode ;
   u32 s_time_gran ;
   struct mutex s_vfs_rename_mutex ;
   char *s_subtype ;
   char *s_options ;
   struct dentry_operations const *s_d_op ;
   int cleancache_poolid ;
   struct shrinker s_shrink ;
   atomic_long_t s_remove_count ;
   int s_readonly_remount ;
   struct workqueue_struct *s_dio_done_wq ;
   struct hlist_head s_pins ;
   struct list_lru s_dentry_lru ;
   struct list_lru s_inode_lru ;
   struct callback_head rcu ;
   int s_stack_depth ;
};

#line 1526  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};

#line 1540 
struct dir_context;

#line 1565  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct dir_context {
   int (*actor)(struct dir_context *, char const *, int , loff_t , u64 , unsigned int ) ;
   loff_t pos ;
};

#line 1572  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file *, loff_t , int ) ;
   ssize_t (*read)(struct file *, char *, size_t , loff_t *) ;
   ssize_t (*write)(struct file *, char const *, size_t , loff_t *) ;
   ssize_t (*read_iter)(struct kiocb *, struct iov_iter *) ;
   ssize_t (*write_iter)(struct kiocb *, struct iov_iter *) ;
   int (*iterate)(struct file *, struct dir_context *) ;
   unsigned int (*poll)(struct file *, struct poll_table_struct *) ;
   long (*unlocked_ioctl)(struct file *, unsigned int , unsigned long ) ;
   long (*compat_ioctl)(struct file *, unsigned int , unsigned long ) ;
   int (*mmap)(struct file *, struct vm_area_struct *) ;
   int (*mremap)(struct file *, struct vm_area_struct *) ;
   int (*open)(struct inode *, struct file *) ;
   int (*flush)(struct file *, fl_owner_t ) ;
   int (*release)(struct inode *, struct file *) ;
   int (*fsync)(struct file *, loff_t , loff_t , int ) ;
   int (*aio_fsync)(struct kiocb *, int ) ;
   int (*fasync)(int , struct file *, int ) ;
   int (*lock)(struct file *, int , struct file_lock *) ;
   ssize_t (*sendpage)(struct file *, struct page *, int , size_t , loff_t *, int ) ;
   unsigned long (*get_unmapped_area)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ) ;
   int (*check_flags)(int ) ;
   int (*flock)(struct file *, int , struct file_lock *) ;
   ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ) ;
   ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ) ;
   int (*setlease)(struct file *, long , struct file_lock **, void **) ;
   long (*fallocate)(struct file *, int , loff_t , loff_t ) ;
   void (*show_fdinfo)(struct seq_file *, struct file *) ;
};

#line 1633  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct inode_operations {
   struct dentry *(*lookup)(struct inode *, struct dentry *, unsigned int ) ;
   char const *(*follow_link)(struct dentry *, void **) ;
   int (*permission)(struct inode *, int ) ;
   struct posix_acl *(*get_acl)(struct inode *, int ) ;
   int (*readlink)(struct dentry *, char *, int ) ;
   void (*put_link)(struct inode *, void *) ;
   int (*create)(struct inode *, struct dentry *, umode_t , bool ) ;
   int (*link)(struct dentry *, struct inode *, struct dentry *) ;
   int (*unlink)(struct inode *, struct dentry *) ;
   int (*symlink)(struct inode *, struct dentry *, char const *) ;
   int (*mkdir)(struct inode *, struct dentry *, umode_t ) ;
   int (*rmdir)(struct inode *, struct dentry *) ;
   int (*mknod)(struct inode *, struct dentry *, umode_t , dev_t ) ;
   int (*rename)(struct inode *, struct dentry *, struct inode *, struct dentry *) ;
   int (*rename2)(struct inode *, struct dentry *, struct inode *, struct dentry *, unsigned int ) ;
   int (*setattr)(struct dentry *, struct iattr *) ;
   int (*getattr)(struct vfsmount *, struct dentry *, struct kstat *) ;
   int (*setxattr)(struct dentry *, char const *, void const *, size_t , int ) ;
   ssize_t (*getxattr)(struct dentry *, char const *, void *, size_t ) ;
   ssize_t (*listxattr)(struct dentry *, char *, size_t ) ;
   int (*removexattr)(struct dentry *, char const *) ;
   int (*fiemap)(struct inode *, struct fiemap_extent_info *, u64 , u64 ) ;
   int (*update_time)(struct inode *, struct timespec *, int ) ;
   int (*atomic_open)(struct inode *, struct dentry *, struct file *, unsigned int , umode_t , int *) ;
   int (*tmpfile)(struct inode *, struct dentry *, umode_t ) ;
   int (*set_acl)(struct inode *, struct posix_acl *, int ) ;
};

#line 1687  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block *) ;
   void (*destroy_inode)(struct inode *) ;
   void (*dirty_inode)(struct inode *, int ) ;
   int (*write_inode)(struct inode *, struct writeback_control *) ;
   int (*drop_inode)(struct inode *) ;
   void (*evict_inode)(struct inode *) ;
   void (*put_super)(struct super_block *) ;
   int (*sync_fs)(struct super_block *, int ) ;
   int (*freeze_super)(struct super_block *) ;
   int (*freeze_fs)(struct super_block *) ;
   int (*thaw_super)(struct super_block *) ;
   int (*unfreeze_fs)(struct super_block *) ;
   int (*statfs)(struct dentry *, struct kstatfs *) ;
   int (*remount_fs)(struct super_block *, int *, char *) ;
   void (*umount_begin)(struct super_block *) ;
   int (*show_options)(struct seq_file *, struct dentry *) ;
   int (*show_devname)(struct seq_file *, struct dentry *) ;
   int (*show_path)(struct seq_file *, struct dentry *) ;
   int (*show_stats)(struct seq_file *, struct dentry *) ;
   ssize_t (*quota_read)(struct super_block *, int , char *, size_t , loff_t ) ;
   ssize_t (*quota_write)(struct super_block *, int , char const *, size_t , loff_t ) ;
   struct dquot **(*get_dquots)(struct inode *) ;
   int (*bdev_try_to_free_page)(struct super_block *, struct page *, gfp_t ) ;
   long (*nr_cached_objects)(struct super_block *, struct shrink_control *) ;
   long (*free_cached_objects)(struct super_block *, struct shrink_control *) ;
};

#line 1926  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct file_system_type {
   char const *name ;
   int fs_flags ;
   struct dentry *(*mount)(struct file_system_type *, int , char const *, void *) ;
   void (*kill_sb)(struct super_block *) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct hlist_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key s_vfs_rename_key ;
   struct lock_class_key s_writers_key[3U] ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
};

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/compat.h"
typedef s32 compat_time_t;

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/compat.h"
typedef s32 compat_long_t;

#line 44  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/compat.h"
typedef u32 compat_uptr_t;

#line 45  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/compat.h"
struct compat_timespec {
   compat_time_t tv_sec ;
   s32 tv_nsec ;
};

#line 276  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/compat.h"
struct compat_robust_list {
   compat_uptr_t next ;
};

#line 280  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/compat.h"
struct compat_robust_list_head {
   struct compat_robust_list list ;
   compat_long_t futex_offset ;
   compat_uptr_t list_op_pending ;
};

#line 715  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/compat.h"
struct ethtool_cmd {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertising ;
   __u16 speed ;
   __u8 duplex ;
   __u8 port ;
   __u8 phy_address ;
   __u8 transceiver ;
   __u8 autoneg ;
   __u8 mdio_support ;
   __u32 maxtxpkt ;
   __u32 maxrxpkt ;
   __u16 speed_hi ;
   __u8 eth_tp_mdix ;
   __u8 eth_tp_mdix_ctrl ;
   __u32 lp_advertising ;
   __u32 reserved[2U] ;
};

#line 125  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_drvinfo {
   __u32 cmd ;
   char driver[32U] ;
   char version[32U] ;
   char fw_version[32U] ;
   char bus_info[32U] ;
   char erom_version[32U] ;
   char reserved2[12U] ;
   __u32 n_priv_flags ;
   __u32 n_stats ;
   __u32 testinfo_len ;
   __u32 eedump_len ;
   __u32 regdump_len ;
};

#line 189  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_wolinfo {
   __u32 cmd ;
   __u32 supported ;
   __u32 wolopts ;
   __u8 sopass[6U] ;
};

#line 233  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_tunable {
   __u32 cmd ;
   __u32 id ;
   __u32 type_id ;
   __u32 len ;
   void *data[0U] ;
};

#line 245  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_regs {
   __u32 cmd ;
   __u32 version ;
   __u32 len ;
   __u8 data[0U] ;
};

#line 267  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_eeprom {
   __u32 cmd ;
   __u32 magic ;
   __u32 offset ;
   __u32 len ;
   __u8 data[0U] ;
};

#line 293  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_eee {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertised ;
   __u32 lp_advertised ;
   __u32 eee_active ;
   __u32 eee_enabled ;
   __u32 tx_lpi_enabled ;
   __u32 tx_lpi_timer ;
   __u32 reserved[2U] ;
};

#line 322  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_modinfo {
   __u32 cmd ;
   __u32 type ;
   __u32 eeprom_len ;
   __u32 reserved[8U] ;
};

#line 339  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_coalesce {
   __u32 cmd ;
   __u32 rx_coalesce_usecs ;
   __u32 rx_max_coalesced_frames ;
   __u32 rx_coalesce_usecs_irq ;
   __u32 rx_max_coalesced_frames_irq ;
   __u32 tx_coalesce_usecs ;
   __u32 tx_max_coalesced_frames ;
   __u32 tx_coalesce_usecs_irq ;
   __u32 tx_max_coalesced_frames_irq ;
   __u32 stats_block_coalesce_usecs ;
   __u32 use_adaptive_rx_coalesce ;
   __u32 use_adaptive_tx_coalesce ;
   __u32 pkt_rate_low ;
   __u32 rx_coalesce_usecs_low ;
   __u32 rx_max_coalesced_frames_low ;
   __u32 tx_coalesce_usecs_low ;
   __u32 tx_max_coalesced_frames_low ;
   __u32 pkt_rate_high ;
   __u32 rx_coalesce_usecs_high ;
   __u32 rx_max_coalesced_frames_high ;
   __u32 tx_coalesce_usecs_high ;
   __u32 tx_max_coalesced_frames_high ;
   __u32 rate_sample_interval ;
};

#line 438  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_ringparam {
   __u32 cmd ;
   __u32 rx_max_pending ;
   __u32 rx_mini_max_pending ;
   __u32 rx_jumbo_max_pending ;
   __u32 tx_max_pending ;
   __u32 rx_pending ;
   __u32 rx_mini_pending ;
   __u32 rx_jumbo_pending ;
   __u32 tx_pending ;
};

#line 475  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_channels {
   __u32 cmd ;
   __u32 max_rx ;
   __u32 max_tx ;
   __u32 max_other ;
   __u32 max_combined ;
   __u32 rx_count ;
   __u32 tx_count ;
   __u32 other_count ;
   __u32 combined_count ;
};

#line 503  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_pauseparam {
   __u32 cmd ;
   __u32 autoneg ;
   __u32 rx_pause ;
   __u32 tx_pause ;
};

#line 605  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_test {
   __u32 cmd ;
   __u32 flags ;
   __u32 reserved ;
   __u32 len ;
   __u64 data[0U] ;
};

#line 637  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_stats {
   __u32 cmd ;
   __u32 n_stats ;
   __u64 data[0U] ;
};

#line 679  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_tcpip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be16 psrc ;
   __be16 pdst ;
   __u8 tos ;
};

#line 712  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_ah_espip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 spi ;
   __u8 tos ;
};

#line 728  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_usrip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 l4_4_bytes ;
   __u8 tos ;
   __u8 ip_ver ;
   __u8 proto ;
};

#line 748  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
union ethtool_flow_union {
   struct ethtool_tcpip4_spec tcp_ip4_spec ;
   struct ethtool_tcpip4_spec udp_ip4_spec ;
   struct ethtool_tcpip4_spec sctp_ip4_spec ;
   struct ethtool_ah_espip4_spec ah_ip4_spec ;
   struct ethtool_ah_espip4_spec esp_ip4_spec ;
   struct ethtool_usrip4_spec usr_ip4_spec ;
   struct ethhdr ether_spec ;
   __u8 hdata[52U] ;
};

#line 759  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_flow_ext {
   __u8 padding[2U] ;
   unsigned char h_dest[6U] ;
   __be16 vlan_etype ;
   __be16 vlan_tci ;
   __be32 data[2U] ;
};

#line 778  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_rx_flow_spec {
   __u32 flow_type ;
   union ethtool_flow_union h_u ;
   struct ethtool_flow_ext h_ext ;
   union ethtool_flow_union m_u ;
   struct ethtool_flow_ext m_ext ;
   __u64 ring_cookie ;
   __u32 location ;
};

#line 828  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_rxnfc {
   __u32 cmd ;
   __u32 flow_type ;
   __u64 data ;
   struct ethtool_rx_flow_spec fs ;
   __u32 rule_cnt ;
   __u32 rule_locs[0U] ;
};

#line 999  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_flash {
   __u32 cmd ;
   __u32 region ;
   char data[128U] ;
};

#line 1007  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_dump {
   __u32 cmd ;
   __u32 version ;
   __u32 flag ;
   __u32 len ;
   __u8 data[0U] ;
};

#line 1083  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_ts_info {
   __u32 cmd ;
   __u32 so_timestamping ;
   __s32 phc_index ;
   __u32 tx_types ;
   __u32 tx_reserved[3U] ;
   __u32 rx_filters ;
   __u32 rx_reserved[3U] ;
};

#line 44  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ethtool.h"
enum ethtool_phys_id_state {
    ETHTOOL_ID_INACTIVE = 0,
    ETHTOOL_ID_ACTIVE = 1,
    ETHTOOL_ID_ON = 2,
    ETHTOOL_ID_OFF = 3
};

#line 99  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ethtool.h"
struct ethtool_ops {
   int (*get_settings)(struct net_device *, struct ethtool_cmd *) ;
   int (*set_settings)(struct net_device *, struct ethtool_cmd *) ;
   void (*get_drvinfo)(struct net_device *, struct ethtool_drvinfo *) ;
   int (*get_regs_len)(struct net_device *) ;
   void (*get_regs)(struct net_device *, struct ethtool_regs *, void *) ;
   void (*get_wol)(struct net_device *, struct ethtool_wolinfo *) ;
   int (*set_wol)(struct net_device *, struct ethtool_wolinfo *) ;
   u32 (*get_msglevel)(struct net_device *) ;
   void (*set_msglevel)(struct net_device *, u32 ) ;
   int (*nway_reset)(struct net_device *) ;
   u32 (*get_link)(struct net_device *) ;
   int (*get_eeprom_len)(struct net_device *) ;
   int (*get_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *) ;
   int (*set_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *) ;
   int (*get_coalesce)(struct net_device *, struct ethtool_coalesce *) ;
   int (*set_coalesce)(struct net_device *, struct ethtool_coalesce *) ;
   void (*get_ringparam)(struct net_device *, struct ethtool_ringparam *) ;
   int (*set_ringparam)(struct net_device *, struct ethtool_ringparam *) ;
   void (*get_pauseparam)(struct net_device *, struct ethtool_pauseparam *) ;
   int (*set_pauseparam)(struct net_device *, struct ethtool_pauseparam *) ;
   void (*self_test)(struct net_device *, struct ethtool_test *, u64 *) ;
   void (*get_strings)(struct net_device *, u32 , u8 *) ;
   int (*set_phys_id)(struct net_device *, enum ethtool_phys_id_state ) ;
   void (*get_ethtool_stats)(struct net_device *, struct ethtool_stats *, u64 *) ;
   int (*begin)(struct net_device *) ;
   void (*complete)(struct net_device *) ;
   u32 (*get_priv_flags)(struct net_device *) ;
   int (*set_priv_flags)(struct net_device *, u32 ) ;
   int (*get_sset_count)(struct net_device *, int ) ;
   int (*get_rxnfc)(struct net_device *, struct ethtool_rxnfc *, u32 *) ;
   int (*set_rxnfc)(struct net_device *, struct ethtool_rxnfc *) ;
   int (*flash_device)(struct net_device *, struct ethtool_flash *) ;
   int (*reset)(struct net_device *, u32 *) ;
   u32 (*get_rxfh_key_size)(struct net_device *) ;
   u32 (*get_rxfh_indir_size)(struct net_device *) ;
   int (*get_rxfh)(struct net_device *, u32 *, u8 *, u8 *) ;
   int (*set_rxfh)(struct net_device *, u32 const *, u8 const *, u8 const ) ;
   void (*get_channels)(struct net_device *, struct ethtool_channels *) ;
   int (*set_channels)(struct net_device *, struct ethtool_channels *) ;
   int (*get_dump_flag)(struct net_device *, struct ethtool_dump *) ;
   int (*get_dump_data)(struct net_device *, struct ethtool_dump *, void *) ;
   int (*set_dump)(struct net_device *, struct ethtool_dump *) ;
   int (*get_ts_info)(struct net_device *, struct ethtool_ts_info *) ;
   int (*get_module_info)(struct net_device *, struct ethtool_modinfo *) ;
   int (*get_module_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *) ;
   int (*get_eee)(struct net_device *, struct ethtool_eee *) ;
   int (*set_eee)(struct net_device *, struct ethtool_eee *) ;
   int (*get_tunable)(struct net_device *, struct ethtool_tunable const *, void *) ;
   int (*set_tunable)(struct net_device *, struct ethtool_tunable const *, void const *) ;
};

#line 235  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flow.h"
struct prot_inuse;

#line 236  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flow.h"
struct netns_core {
   struct ctl_table_header *sysctl_hdr ;
   int sysctl_somaxconn ;
   struct prot_inuse *inuse ;
};

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct u64_stats_sync {
   
};

#line 146  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/u64_stats_sync.h"
struct ipstats_mib {
   u64 mibs[36U] ;
   struct u64_stats_sync syncp ;
};

#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct icmp_mib {
   unsigned long mibs[28U] ;
};

#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct icmpmsg_mib {
   atomic_long_t mibs[512U] ;
};

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct icmpv6_mib {
   unsigned long mibs[6U] ;
};

#line 83  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct icmpv6msg_mib {
   atomic_long_t mibs[512U] ;
};

#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct tcp_mib {
   unsigned long mibs[16U] ;
};

#line 100  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct udp_mib {
   unsigned long mibs[9U] ;
};

#line 106  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct linux_mib {
   unsigned long mibs[115U] ;
};

#line 112  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct linux_xfrm_mib {
   unsigned long mibs[29U] ;
};

#line 118 
struct proc_dir_entry;

#line 118  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct netns_mib {
   struct tcp_mib *tcp_statistics ;
   struct ipstats_mib *ip_statistics ;
   struct linux_mib *net_statistics ;
   struct udp_mib *udp_statistics ;
   struct udp_mib *udplite_statistics ;
   struct icmp_mib *icmp_statistics ;
   struct icmpmsg_mib *icmpmsg_statistics ;
   struct proc_dir_entry *proc_net_devsnmp6 ;
   struct udp_mib *udp_stats_in6 ;
   struct udp_mib *udplite_stats_in6 ;
   struct ipstats_mib *ipv6_statistics ;
   struct icmpv6_mib *icmpv6_statistics ;
   struct icmpv6msg_mib *icmpv6msg_statistics ;
   struct linux_xfrm_mib *xfrm_statistics ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/mib.h"
struct netns_unix {
   int sysctl_max_dgram_qlen ;
   struct ctl_table_header *ctl ;
};

#line 12  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/unix.h"
struct netns_packet {
   struct mutex sklist_lock ;
   struct hlist_head sklist ;
};

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/packet.h"
struct netns_frags {
   struct percpu_counter mem ;
   int timeout ;
   int high_thresh ;
   int low_thresh ;
};

#line 184  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inet_frag.h"
struct ipv4_devconf;

#line 185 
struct fib_rules_ops;

#line 186 
struct fib_table;

#line 187  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inet_frag.h"
struct local_ports {
   seqlock_t lock ;
   int range[2U] ;
   bool warned ;
};

#line 24  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv4.h"
struct ping_group_range {
   seqlock_t lock ;
   kgid_t range[2U] ;
};

#line 29 
struct inet_peer_base;

#line 29 
struct xt_table;

#line 29  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv4.h"
struct netns_ipv4 {
   struct ctl_table_header *forw_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *ipv4_hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *xfrm4_hdr ;
   struct ipv4_devconf *devconf_all ;
   struct ipv4_devconf *devconf_dflt ;
   struct fib_rules_ops *rules_ops ;
   bool fib_has_custom_rules ;
   struct fib_table *fib_local ;
   struct fib_table *fib_main ;
   struct fib_table *fib_default ;
   int fib_num_tclassid_users ;
   struct hlist_head *fib_table_hash ;
   bool fib_offload_disabled ;
   struct sock *fibnl ;
   struct sock **icmp_sk ;
   struct sock *mc_autojoin_sk ;
   struct inet_peer_base *peers ;
   struct sock **tcp_sk ;
   struct netns_frags frags ;
   struct xt_table *iptable_filter ;
   struct xt_table *iptable_mangle ;
   struct xt_table *iptable_raw ;
   struct xt_table *arptable_filter ;
   struct xt_table *iptable_security ;
   struct xt_table *nat_table ;
   int sysctl_icmp_echo_ignore_all ;
   int sysctl_icmp_echo_ignore_broadcasts ;
   int sysctl_icmp_ignore_bogus_error_responses ;
   int sysctl_icmp_ratelimit ;
   int sysctl_icmp_ratemask ;
   int sysctl_icmp_errors_use_inbound_ifaddr ;
   struct local_ports ip_local_ports ;
   int sysctl_tcp_ecn ;
   int sysctl_tcp_ecn_fallback ;
   int sysctl_ip_no_pmtu_disc ;
   int sysctl_ip_fwd_use_pmtu ;
   int sysctl_ip_nonlocal_bind ;
   int sysctl_fwmark_reflect ;
   int sysctl_tcp_fwmark_accept ;
   int sysctl_tcp_mtu_probing ;
   int sysctl_tcp_base_mss ;
   int sysctl_tcp_probe_threshold ;
   u32 sysctl_tcp_probe_interval ;
   struct ping_group_range ping_group_range ;
   atomic_t dev_addr_genid ;
   unsigned long *sysctl_local_reserved_ports ;
   struct list_head mr_tables ;
   struct fib_rules_ops *mr_rules_ops ;
   atomic_t rt_genid ;
};

#line 113 
struct neighbour;

#line 113  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv4.h"
struct dst_ops {
   unsigned short family ;
   unsigned int gc_thresh ;
   int (*gc)(struct dst_ops *) ;
   struct dst_entry *(*check)(struct dst_entry *, __u32 ) ;
   unsigned int (*default_advmss)(struct dst_entry const *) ;
   unsigned int (*mtu)(struct dst_entry const *) ;
   u32 *(*cow_metrics)(struct dst_entry *, unsigned long ) ;
   void (*destroy)(struct dst_entry *) ;
   void (*ifdown)(struct dst_entry *, struct net_device *, int ) ;
   struct dst_entry *(*negative_advice)(struct dst_entry *) ;
   void (*link_failure)(struct sk_buff *) ;
   void (*update_pmtu)(struct dst_entry *, struct sock *, struct sk_buff *, u32 ) ;
   void (*redirect)(struct dst_entry *, struct sock *, struct sk_buff *) ;
   int (*local_out)(struct sk_buff *) ;
   struct neighbour *(*neigh_lookup)(struct dst_entry const *, struct sk_buff *, void const *) ;
   struct kmem_cache *kmem_cachep ;
   struct percpu_counter pcpuc_entries ;
};

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dst_ops.h"
struct netns_sysctl_ipv6 {
   struct ctl_table_header *hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *icmp_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *xfrm6_hdr ;
   int bindv6only ;
   int flush_delay ;
   int ip6_rt_max_size ;
   int ip6_rt_gc_min_interval ;
   int ip6_rt_gc_timeout ;
   int ip6_rt_gc_interval ;
   int ip6_rt_gc_elasticity ;
   int ip6_rt_mtu_expires ;
   int ip6_rt_min_advmss ;
   int flowlabel_consistency ;
   int auto_flowlabels ;
   int icmpv6_time ;
   int anycast_src_echo_reply ;
   int fwmark_reflect ;
   int idgen_retries ;
   int idgen_delay ;
   int flowlabel_state_ranges ;
};

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv6.h"
struct ipv6_devconf;

#line 39 
struct rt6_info;

#line 39 
struct rt6_statistics;

#line 39 
struct fib6_table;

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv6.h"
struct netns_ipv6 {
   struct netns_sysctl_ipv6 sysctl ;
   struct ipv6_devconf *devconf_all ;
   struct ipv6_devconf *devconf_dflt ;
   struct inet_peer_base *peers ;
   struct netns_frags frags ;
   struct xt_table *ip6table_filter ;
   struct xt_table *ip6table_mangle ;
   struct xt_table *ip6table_raw ;
   struct xt_table *ip6table_security ;
   struct xt_table *ip6table_nat ;
   struct rt6_info *ip6_null_entry ;
   struct rt6_statistics *rt6_stats ;
   struct timer_list ip6_fib_timer ;
   struct hlist_head *fib_table_hash ;
   struct fib6_table *fib6_main_tbl ;
   struct dst_ops ip6_dst_ops ;
   unsigned int ip6_rt_gc_expire ;
   unsigned long ip6_rt_last_gc ;
   struct rt6_info *ip6_prohibit_entry ;
   struct rt6_info *ip6_blk_hole_entry ;
   struct fib6_table *fib6_local_tbl ;
   struct fib_rules_ops *fib6_rules_ops ;
   struct sock **icmp_sk ;
   struct sock *ndisc_sk ;
   struct sock *tcp_sk ;
   struct sock *igmp_sk ;
   struct sock *mc_autojoin_sk ;
   struct list_head mr6_tables ;
   struct fib_rules_ops *mr6_rules_ops ;
   atomic_t dev_addr_genid ;
   atomic_t fib6_sernum ;
};

#line 85  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv6.h"
struct netns_nf_frag {
   struct netns_sysctl_ipv6 sysctl ;
   struct netns_frags frags ;
};

#line 91  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv6.h"
struct netns_sysctl_lowpan {
   struct ctl_table_header *frags_hdr ;
};

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ieee802154_6lowpan.h"
struct netns_ieee802154_lowpan {
   struct netns_sysctl_lowpan sysctl ;
   struct netns_frags frags ;
};

#line 20 
struct sctp_mib;

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ieee802154_6lowpan.h"
struct netns_sctp {
   struct sctp_mib *sctp_statistics ;
   struct proc_dir_entry *proc_net_sctp ;
   struct ctl_table_header *sysctl_header ;
   struct sock *ctl_sock ;
   struct list_head local_addr_list ;
   struct list_head addr_waitq ;
   struct timer_list addr_wq_timer ;
   struct list_head auto_asconf_splist ;
   spinlock_t addr_wq_lock ;
   spinlock_t local_addr_lock ;
   unsigned int rto_initial ;
   unsigned int rto_min ;
   unsigned int rto_max ;
   int rto_alpha ;
   int rto_beta ;
   int max_burst ;
   int cookie_preserve_enable ;
   char *sctp_hmac_alg ;
   unsigned int valid_cookie_life ;
   unsigned int sack_timeout ;
   unsigned int hb_interval ;
   int max_retrans_association ;
   int max_retrans_path ;
   int max_retrans_init ;
   int pf_retrans ;
   int sndbuf_policy ;
   int rcvbuf_policy ;
   int default_auto_asconf ;
   int addip_enable ;
   int addip_noauth ;
   int prsctp_enable ;
   int auth_enable ;
   int scope_policy ;
   int rwnd_upd_shift ;
   unsigned long max_autoclose ;
};

#line 134  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/sctp.h"
struct netns_dccp {
   struct sock *v4_ctl_sk ;
   struct sock *v6_ctl_sk ;
};

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/netfilter.h"
struct nf_logger;

#line 80  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/netfilter.h"
struct netns_nf {
   struct proc_dir_entry *proc_netfilter ;
   struct nf_logger const *nf_loggers[13U] ;
   struct ctl_table_header *nf_log_dir_header ;
};

#line 17  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/netfilter.h"
struct ebt_table;

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/netfilter.h"
struct netns_xt {
   struct list_head tables[13U] ;
   bool notrack_deprecated_warning ;
   bool clusterip_deprecated_warning ;
   struct ebt_table *broute_table ;
   struct ebt_table *frame_filter ;
   struct ebt_table *frame_nat ;
};

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/x_tables.h"
struct hlist_nulls_node;

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/x_tables.h"
struct hlist_nulls_head {
   struct hlist_nulls_node *first ;
};

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/x_tables.h"
struct hlist_nulls_node {
   struct hlist_nulls_node *next ;
   struct hlist_nulls_node **pprev ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netfilter/nf_conntrack_tcp.h"
struct nf_proto_net {
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
   struct ctl_table_header *ctl_compat_header ;
   struct ctl_table *ctl_compat_table ;
   unsigned int users ;
};

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct nf_generic_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};

#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct nf_tcp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[14U] ;
   unsigned int tcp_loose ;
   unsigned int tcp_be_liberal ;
   unsigned int tcp_max_retrans ;
};

#line 44  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct nf_udp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[2U] ;
};

#line 49  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct nf_icmp_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct nf_ip_net {
   struct nf_generic_net generic ;
   struct nf_tcp_net tcp ;
   struct nf_udp_net udp ;
   struct nf_icmp_net icmp ;
   struct nf_icmp_net icmpv6 ;
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
};

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct ct_pcpu {
   spinlock_t lock ;
   struct hlist_nulls_head unconfirmed ;
   struct hlist_nulls_head dying ;
};

#line 72 
struct ip_conntrack_stat;

#line 72 
struct nf_ct_event_notifier;

#line 72 
struct nf_exp_event_notifier;

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct netns_ct {
   atomic_t count ;
   unsigned int expect_count ;
   struct delayed_work ecache_dwork ;
   bool ecache_dwork_pending ;
   struct ctl_table_header *sysctl_header ;
   struct ctl_table_header *acct_sysctl_header ;
   struct ctl_table_header *tstamp_sysctl_header ;
   struct ctl_table_header *event_sysctl_header ;
   struct ctl_table_header *helper_sysctl_header ;
   char *slabname ;
   unsigned int sysctl_log_invalid ;
   int sysctl_events ;
   int sysctl_acct ;
   int sysctl_auto_assign_helper ;
   bool auto_assign_helper_warned ;
   int sysctl_tstamp ;
   int sysctl_checksum ;
   unsigned int htable_size ;
   seqcount_t generation ;
   struct kmem_cache *nf_conntrack_cachep ;
   struct hlist_nulls_head *hash ;
   struct hlist_head *expect_hash ;
   struct ct_pcpu *pcpu_lists ;
   struct ip_conntrack_stat *stat ;
   struct nf_ct_event_notifier *nf_conntrack_event_cb ;
   struct nf_exp_event_notifier *nf_expect_event_cb ;
   struct nf_ip_net nf_ct_proto ;
   unsigned int labels_used ;
   u8 label_words ;
   struct hlist_head *nat_bysource ;
   unsigned int nat_htable_size ;
};

#line 114 
struct nft_af_info;

#line 115  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct netns_nftables {
   struct list_head af_info ;
   struct list_head commit_list ;
   struct nft_af_info *ipv4 ;
   struct nft_af_info *ipv6 ;
   struct nft_af_info *inet ;
   struct nft_af_info *arp ;
   struct nft_af_info *bridge ;
   struct nft_af_info *netdev ;
   unsigned int base_seq ;
   u8 gencursor ;
};

#line 465  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/interrupt.h"
struct tasklet_struct {
   struct tasklet_struct *next ;
   unsigned long state ;
   atomic_t count ;
   void (*func)(unsigned long ) ;
   unsigned long data ;
};

#line 672  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/interrupt.h"
struct flow_cache_percpu {
   struct hlist_head *hash_table ;
   int hash_count ;
   u32 hash_rnd ;
   int hash_rnd_recalc ;
   struct tasklet_struct flush_tasklet ;
};

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flowcache.h"
struct flow_cache {
   u32 hash_shift ;
   struct flow_cache_percpu *percpu ;
   struct notifier_block hotcpu_notifier ;
   int low_watermark ;
   int high_watermark ;
   struct timer_list rnd_timer ;
};

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flowcache.h"
struct xfrm_policy_hash {
   struct hlist_head *table ;
   unsigned int hmask ;
   u8 dbits4 ;
   u8 sbits4 ;
   u8 dbits6 ;
   u8 sbits6 ;
};

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/xfrm.h"
struct xfrm_policy_hthresh {
   struct work_struct work ;
   seqlock_t lock ;
   u8 lbits4 ;
   u8 rbits4 ;
   u8 lbits6 ;
   u8 rbits6 ;
};

#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/xfrm.h"
struct netns_xfrm {
   struct list_head state_all ;
   struct hlist_head *state_bydst ;
   struct hlist_head *state_bysrc ;
   struct hlist_head *state_byspi ;
   unsigned int state_hmask ;
   unsigned int state_num ;
   struct work_struct state_hash_work ;
   struct hlist_head state_gc_list ;
   struct work_struct state_gc_work ;
   struct list_head policy_all ;
   struct hlist_head *policy_byidx ;
   unsigned int policy_idx_hmask ;
   struct hlist_head policy_inexact[3U] ;
   struct xfrm_policy_hash policy_bydst[3U] ;
   unsigned int policy_count[6U] ;
   struct work_struct policy_hash_work ;
   struct xfrm_policy_hthresh policy_hthresh ;
   struct sock *nlsk ;
   struct sock *nlsk_stash ;
   u32 sysctl_aevent_etime ;
   u32 sysctl_aevent_rseqth ;
   int sysctl_larval_drop ;
   u32 sysctl_acq_expires ;
   struct ctl_table_header *sysctl_hdr ;
   struct dst_ops xfrm4_dst_ops ;
   struct dst_ops xfrm6_dst_ops ;
   spinlock_t xfrm_state_lock ;
   rwlock_t xfrm_policy_lock ;
   struct mutex xfrm_cfg_mutex ;
   struct flow_cache flow_cache_global ;
   atomic_t flow_cache_genid ;
   struct list_head flow_cache_gc_list ;
   spinlock_t flow_cache_gc_lock ;
   struct work_struct flow_cache_gc_work ;
   struct work_struct flow_cache_flush_work ;
   struct mutex flow_flush_sem ;
};

#line 88 
struct mpls_route;

#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/xfrm.h"
struct netns_mpls {
   size_t platform_labels ;
   struct mpls_route **platform_label ;
   struct ctl_table_header *ctl ;
};

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/mpls.h"
struct proc_ns_operations;

#line 17  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/mpls.h"
struct ns_common {
   atomic_long_t stashed ;
   struct proc_ns_operations const *ops ;
   unsigned int inum ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ns_common.h"
struct net_generic;

#line 12 
struct netns_ipvs;

#line 13  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ns_common.h"
struct net {
   atomic_t passive ;
   atomic_t count ;
   spinlock_t rules_mod_lock ;
   atomic64_t cookie_gen ;
   struct list_head list ;
   struct list_head cleanup_list ;
   struct list_head exit_list ;
   struct user_namespace *user_ns ;
   spinlock_t nsid_lock ;
   struct idr netns_ids ;
   struct ns_common ns ;
   struct proc_dir_entry *proc_net ;
   struct proc_dir_entry *proc_net_stat ;
   struct ctl_table_set sysctls ;
   struct sock *rtnl ;
   struct sock *genl_sock ;
   struct list_head dev_base_head ;
   struct hlist_head *dev_name_head ;
   struct hlist_head *dev_index_head ;
   unsigned int dev_base_seq ;
   int ifindex ;
   unsigned int dev_unreg_count ;
   struct list_head rules_ops ;
   struct net_device *loopback_dev ;
   struct netns_core core ;
   struct netns_mib mib ;
   struct netns_packet packet ;
   struct netns_unix unx ;
   struct netns_ipv4 ipv4 ;
   struct netns_ipv6 ipv6 ;
   struct netns_ieee802154_lowpan ieee802154_lowpan ;
   struct netns_sctp sctp ;
   struct netns_dccp dccp ;
   struct netns_nf nf ;
   struct netns_xt xt ;
   struct netns_ct ct ;
   struct netns_nftables nft ;
   struct netns_nf_frag nf_frag ;
   struct sock *nfnl ;
   struct sock *nfnl_stash ;
   struct sk_buff_head wext_nlevents ;
   struct net_generic *gen ;
   struct netns_xfrm xfrm ;
   struct netns_ipvs *ipvs ;
   struct netns_mpls mpls ;
   struct sock *diag_nlsk ;
   atomic_t fnhe_genid ;
};

#line 241  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/net_namespace.h"
struct __anonstruct_possible_net_t_333 {
   struct net *net ;
};

#line 241  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/net_namespace.h"
typedef struct __anonstruct_possible_net_t_333 possible_net_t;

#line 376 
enum fwnode_type {
    FWNODE_INVALID = 0,
    FWNODE_OF = 1,
    FWNODE_ACPI = 2,
    FWNODE_PDATA = 3
};

#line 383  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/net_namespace.h"
struct fwnode_handle {
   enum fwnode_type type ;
   struct fwnode_handle *secondary ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/of.h"
typedef u32 phandle;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/of.h"
struct property {
   char *name ;
   int length ;
   void *value ;
   struct property *next ;
   unsigned long _flags ;
   unsigned int unique_id ;
   struct bin_attribute attr ;
};

#line 44  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/of.h"
struct device_node {
   char const *name ;
   char const *type ;
   phandle phandle ;
   char const *full_name ;
   struct fwnode_handle fwnode ;
   struct property *properties ;
   struct property *deadprops ;
   struct device_node *parent ;
   struct device_node *child ;
   struct device_node *sibling ;
   struct kobject kobj ;
   unsigned long _flags ;
   void *data ;
};

#line 338  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mii.h"
enum ldv_28416 {
    PHY_INTERFACE_MODE_NA = 0,
    PHY_INTERFACE_MODE_MII = 1,
    PHY_INTERFACE_MODE_GMII = 2,
    PHY_INTERFACE_MODE_SGMII = 3,
    PHY_INTERFACE_MODE_TBI = 4,
    PHY_INTERFACE_MODE_REVMII = 5,
    PHY_INTERFACE_MODE_RMII = 6,
    PHY_INTERFACE_MODE_RGMII = 7,
    PHY_INTERFACE_MODE_RGMII_ID = 8,
    PHY_INTERFACE_MODE_RGMII_RXID = 9,
    PHY_INTERFACE_MODE_RGMII_TXID = 10,
    PHY_INTERFACE_MODE_RTBI = 11,
    PHY_INTERFACE_MODE_SMII = 12,
    PHY_INTERFACE_MODE_XGMII = 13,
    PHY_INTERFACE_MODE_MOCA = 14,
    PHY_INTERFACE_MODE_QSGMII = 15,
    PHY_INTERFACE_MODE_MAX = 16
};

#line 80  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
typedef enum ldv_28416 phy_interface_t;

#line 126 
enum ldv_28469 {
    MDIOBUS_ALLOCATED = 1,
    MDIOBUS_REGISTERED = 2,
    MDIOBUS_UNREGISTERED = 3,
    MDIOBUS_RELEASED = 4
};

#line 133 
struct phy_device;

#line 133  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
struct mii_bus {
   char const *name ;
   char id[17U] ;
   void *priv ;
   int (*read)(struct mii_bus *, int , int ) ;
   int (*write)(struct mii_bus *, int , int , u16 ) ;
   int (*reset)(struct mii_bus *) ;
   struct mutex mdio_lock ;
   struct device *parent ;
   enum ldv_28469 state ;
   struct device dev ;
   struct phy_device *phy_map[32U] ;
   u32 phy_mask ;
   u32 phy_ignore_ta_mask ;
   int *irq ;
};

#line 214 
enum phy_state {
    PHY_DOWN = 0,
    PHY_STARTING = 1,
    PHY_READY = 2,
    PHY_PENDING = 3,
    PHY_UP = 4,
    PHY_AN = 5,
    PHY_RUNNING = 6,
    PHY_NOLINK = 7,
    PHY_FORCING = 8,
    PHY_CHANGELINK = 9,
    PHY_HALTED = 10,
    PHY_RESUMING = 11
};

#line 229  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
struct phy_c45_device_ids {
   u32 devices_in_package ;
   u32 device_ids[8U] ;
};

#line 323 
struct phy_driver;

#line 323  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
struct phy_device {
   struct phy_driver *drv ;
   struct mii_bus *bus ;
   struct device dev ;
   u32 phy_id ;
   struct phy_c45_device_ids c45_ids ;
   bool is_c45 ;
   bool is_internal ;
   bool has_fixups ;
   bool suspended ;
   enum phy_state state ;
   u32 dev_flags ;
   phy_interface_t interface ;
   int addr ;
   int speed ;
   int duplex ;
   int pause ;
   int asym_pause ;
   int link ;
   u32 interrupts ;
   u32 supported ;
   u32 advertising ;
   u32 lp_advertising ;
   int autoneg ;
   int link_timeout ;
   int irq ;
   void *priv ;
   struct work_struct phy_queue ;
   struct delayed_work state_queue ;
   atomic_t irq_disable ;
   struct mutex lock ;
   struct net_device *attached_dev ;
   void (*adjust_link)(struct net_device *) ;
};

#line 429  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
struct phy_driver {
   u32 phy_id ;
   char *name ;
   unsigned int phy_id_mask ;
   u32 features ;
   u32 flags ;
   void const *driver_data ;
   int (*soft_reset)(struct phy_device *) ;
   int (*config_init)(struct phy_device *) ;
   int (*probe)(struct phy_device *) ;
   int (*suspend)(struct phy_device *) ;
   int (*resume)(struct phy_device *) ;
   int (*config_aneg)(struct phy_device *) ;
   int (*aneg_done)(struct phy_device *) ;
   int (*read_status)(struct phy_device *) ;
   int (*ack_interrupt)(struct phy_device *) ;
   int (*config_intr)(struct phy_device *) ;
   int (*did_interrupt)(struct phy_device *) ;
   void (*remove)(struct phy_device *) ;
   int (*match_phy_device)(struct phy_device *) ;
   int (*ts_info)(struct phy_device *, struct ethtool_ts_info *) ;
   int (*hwtstamp)(struct phy_device *, struct ifreq *) ;
   bool (*rxtstamp)(struct phy_device *, struct sk_buff *, int ) ;
   void (*txtstamp)(struct phy_device *, struct sk_buff *, int ) ;
   int (*set_wol)(struct phy_device *, struct ethtool_wolinfo *) ;
   void (*get_wol)(struct phy_device *, struct ethtool_wolinfo *) ;
   void (*link_change_notify)(struct phy_device *) ;
   int (*read_mmd_indirect)(struct phy_device *, int , int , int ) ;
   void (*write_mmd_indirect)(struct phy_device *, int , int , int , u32 ) ;
   int (*module_info)(struct phy_device *, struct ethtool_modinfo *) ;
   int (*module_eeprom)(struct phy_device *, struct ethtool_eeprom *, u8 *) ;
   struct device_driver driver ;
};

#line 803  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
struct fixed_phy_status {
   int link ;
   int speed ;
   int duplex ;
   int pause ;
   int asym_pause ;
};

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy_fixed.h"
enum dsa_tag_protocol {
    DSA_TAG_PROTO_NONE = 0,
    DSA_TAG_PROTO_DSA = 1,
    DSA_TAG_PROTO_TRAILER = 2,
    DSA_TAG_PROTO_EDSA = 3,
    DSA_TAG_PROTO_BRCM = 4
};

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy_fixed.h"
struct dsa_chip_data {
   struct device *host_dev ;
   int sw_addr ;
   int eeprom_len ;
   struct device_node *of_node ;
   char *port_names[12U] ;
   struct device_node *port_dn[12U] ;
   s8 *rtable ;
};

#line 68  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dsa.h"
struct dsa_platform_data {
   struct device *netdev ;
   struct net_device *of_netdev ;
   int nr_chips ;
   struct dsa_chip_data *chip ;
};

#line 84 
struct packet_type;

#line 85 
struct dsa_switch;

#line 85  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dsa.h"
struct dsa_switch_tree {
   struct dsa_platform_data *pd ;
   struct net_device *master_netdev ;
   int (*rcv)(struct sk_buff *, struct net_device *, struct packet_type *, struct net_device *) ;
   enum dsa_tag_protocol tag_protocol ;
   s8 cpu_switch ;
   s8 cpu_port ;
   int link_poll_needed ;
   struct work_struct link_poll_work ;
   struct timer_list link_poll_timer ;
   struct dsa_switch *ds[4U] ;
};

#line 123 
struct dsa_switch_driver;

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dsa.h"
struct dsa_switch {
   struct dsa_switch_tree *dst ;
   int index ;
   enum dsa_tag_protocol tag_protocol ;
   struct dsa_chip_data *pd ;
   struct dsa_switch_driver *drv ;
   struct device *master_dev ;
   char hwmon_name[24U] ;
   struct device *hwmon_dev ;
   u32 dsa_port_mask ;
   u32 phys_port_mask ;
   u32 phys_mii_mask ;
   struct mii_bus *slave_mii_bus ;
   struct net_device *ports[12U] ;
};

#line 194  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dsa.h"
struct dsa_switch_driver {
   struct list_head list ;
   enum dsa_tag_protocol tag_protocol ;
   int priv_size ;
   char *(*probe)(struct device *, int ) ;
   int (*setup)(struct dsa_switch *) ;
   int (*set_addr)(struct dsa_switch *, u8 *) ;
   u32 (*get_phy_flags)(struct dsa_switch *, int ) ;
   int (*phy_read)(struct dsa_switch *, int , int ) ;
   int (*phy_write)(struct dsa_switch *, int , int , u16 ) ;
   void (*poll_link)(struct dsa_switch *) ;
   void (*adjust_link)(struct dsa_switch *, int , struct phy_device *) ;
   void (*fixed_link_update)(struct dsa_switch *, int , struct fixed_phy_status *) ;
   void (*get_strings)(struct dsa_switch *, int , uint8_t *) ;
   void (*get_ethtool_stats)(struct dsa_switch *, int , uint64_t *) ;
   int (*get_sset_count)(struct dsa_switch *) ;
   void (*get_wol)(struct dsa_switch *, int , struct ethtool_wolinfo *) ;
   int (*set_wol)(struct dsa_switch *, int , struct ethtool_wolinfo *) ;
   int (*suspend)(struct dsa_switch *) ;
   int (*resume)(struct dsa_switch *) ;
   int (*port_enable)(struct dsa_switch *, int , struct phy_device *) ;
   void (*port_disable)(struct dsa_switch *, int , struct phy_device *) ;
   int (*set_eee)(struct dsa_switch *, int , struct phy_device *, struct ethtool_eee *) ;
   int (*get_eee)(struct dsa_switch *, int , struct ethtool_eee *) ;
   int (*get_temp)(struct dsa_switch *, int *) ;
   int (*get_temp_limit)(struct dsa_switch *, int *) ;
   int (*set_temp_limit)(struct dsa_switch *, int ) ;
   int (*get_temp_alarm)(struct dsa_switch *, bool *) ;
   int (*get_eeprom_len)(struct dsa_switch *) ;
   int (*get_eeprom)(struct dsa_switch *, struct ethtool_eeprom *, u8 *) ;
   int (*set_eeprom)(struct dsa_switch *, struct ethtool_eeprom *, u8 *) ;
   int (*get_regs_len)(struct dsa_switch *, int ) ;
   void (*get_regs)(struct dsa_switch *, int , struct ethtool_regs *, void *) ;
   int (*port_join_bridge)(struct dsa_switch *, int , u32 ) ;
   int (*port_leave_bridge)(struct dsa_switch *, int , u32 ) ;
   int (*port_stp_update)(struct dsa_switch *, int , u8 ) ;
   int (*fdb_add)(struct dsa_switch *, int , unsigned char const *, u16 ) ;
   int (*fdb_del)(struct dsa_switch *, int , unsigned char const *, u16 ) ;
   int (*fdb_getnext)(struct dsa_switch *, int , unsigned char *, bool *) ;
};

#line 320  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dsa.h"
struct ieee_ets {
   __u8 willing ;
   __u8 ets_cap ;
   __u8 cbs ;
   __u8 tc_tx_bw[8U] ;
   __u8 tc_rx_bw[8U] ;
   __u8 tc_tsa[8U] ;
   __u8 prio_tc[8U] ;
   __u8 tc_reco_bw[8U] ;
   __u8 tc_reco_tsa[8U] ;
   __u8 reco_prio_tc[8U] ;
};

#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct ieee_maxrate {
   __u64 tc_maxrate[8U] ;
};

#line 87  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct ieee_qcn {
   __u8 rpg_enable[8U] ;
   __u32 rppp_max_rps[8U] ;
   __u32 rpg_time_reset[8U] ;
   __u32 rpg_byte_reset[8U] ;
   __u32 rpg_threshold[8U] ;
   __u32 rpg_max_rate[8U] ;
   __u32 rpg_ai_rate[8U] ;
   __u32 rpg_hai_rate[8U] ;
   __u32 rpg_gd[8U] ;
   __u32 rpg_min_dec_fac[8U] ;
   __u32 rpg_min_rate[8U] ;
   __u32 cndd_state_machine[8U] ;
};

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct ieee_qcn_stats {
   __u64 rppp_rp_centiseconds[8U] ;
   __u32 rppp_created_rps[8U] ;
};

#line 144  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct ieee_pfc {
   __u8 pfc_cap ;
   __u8 pfc_en ;
   __u8 mbc ;
   __u16 delay ;
   __u64 requests[8U] ;
   __u64 indications[8U] ;
};

#line 164  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct cee_pg {
   __u8 willing ;
   __u8 error ;
   __u8 pg_en ;
   __u8 tcs_supported ;
   __u8 pg_bw[8U] ;
   __u8 prio_pg[8U] ;
};

#line 187  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct cee_pfc {
   __u8 willing ;
   __u8 error ;
   __u8 pfc_en ;
   __u8 tcs_supported ;
};

#line 202  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct dcb_app {
   __u8 selector ;
   __u8 priority ;
   __u16 protocol ;
};

#line 236  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct dcb_peer_app_info {
   __u8 willing ;
   __u8 error ;
};

#line 40  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dcbnl.h"
struct dcbnl_rtnl_ops {
   int (*ieee_getets)(struct net_device *, struct ieee_ets *) ;
   int (*ieee_setets)(struct net_device *, struct ieee_ets *) ;
   int (*ieee_getmaxrate)(struct net_device *, struct ieee_maxrate *) ;
   int (*ieee_setmaxrate)(struct net_device *, struct ieee_maxrate *) ;
   int (*ieee_getqcn)(struct net_device *, struct ieee_qcn *) ;
   int (*ieee_setqcn)(struct net_device *, struct ieee_qcn *) ;
   int (*ieee_getqcnstats)(struct net_device *, struct ieee_qcn_stats *) ;
   int (*ieee_getpfc)(struct net_device *, struct ieee_pfc *) ;
   int (*ieee_setpfc)(struct net_device *, struct ieee_pfc *) ;
   int (*ieee_getapp)(struct net_device *, struct dcb_app *) ;
   int (*ieee_setapp)(struct net_device *, struct dcb_app *) ;
   int (*ieee_delapp)(struct net_device *, struct dcb_app *) ;
   int (*ieee_peer_getets)(struct net_device *, struct ieee_ets *) ;
   int (*ieee_peer_getpfc)(struct net_device *, struct ieee_pfc *) ;
   u8 (*getstate)(struct net_device *) ;
   u8 (*setstate)(struct net_device *, u8 ) ;
   void (*getpermhwaddr)(struct net_device *, u8 *) ;
   void (*setpgtccfgtx)(struct net_device *, int , u8 , u8 , u8 , u8 ) ;
   void (*setpgbwgcfgtx)(struct net_device *, int , u8 ) ;
   void (*setpgtccfgrx)(struct net_device *, int , u8 , u8 , u8 , u8 ) ;
   void (*setpgbwgcfgrx)(struct net_device *, int , u8 ) ;
   void (*getpgtccfgtx)(struct net_device *, int , u8 *, u8 *, u8 *, u8 *) ;
   void (*getpgbwgcfgtx)(struct net_device *, int , u8 *) ;
   void (*getpgtccfgrx)(struct net_device *, int , u8 *, u8 *, u8 *, u8 *) ;
   void (*getpgbwgcfgrx)(struct net_device *, int , u8 *) ;
   void (*setpfccfg)(struct net_device *, int , u8 ) ;
   void (*getpfccfg)(struct net_device *, int , u8 *) ;
   u8 (*setall)(struct net_device *) ;
   u8 (*getcap)(struct net_device *, int , u8 *) ;
   int (*getnumtcs)(struct net_device *, int , u8 *) ;
   int (*setnumtcs)(struct net_device *, int , u8 ) ;
   u8 (*getpfcstate)(struct net_device *) ;
   void (*setpfcstate)(struct net_device *, u8 ) ;
   void (*getbcncfg)(struct net_device *, int , u32 *) ;
   void (*setbcncfg)(struct net_device *, int , u32 ) ;
   void (*getbcnrp)(struct net_device *, int , u8 *) ;
   void (*setbcnrp)(struct net_device *, int , u8 ) ;
   int (*setapp)(struct net_device *, u8 , u16 , u8 ) ;
   int (*getapp)(struct net_device *, u8 , u16 ) ;
   u8 (*getfeatcfg)(struct net_device *, int , u8 *) ;
   u8 (*setfeatcfg)(struct net_device *, int , u8 ) ;
   u8 (*getdcbx)(struct net_device *) ;
   u8 (*setdcbx)(struct net_device *, u8 ) ;
   int (*peer_getappinfo)(struct net_device *, struct dcb_peer_app_info *, u16 *) ;
   int (*peer_getapptable)(struct net_device *, struct dcb_app *) ;
   int (*cee_peer_getpg)(struct net_device *, struct cee_pg *) ;
   int (*cee_peer_getpfc)(struct net_device *, struct cee_pfc *) ;
};

#line 105  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dcbnl.h"
struct taskstats {
   __u16 version ;
   __u32 ac_exitcode ;
   __u8 ac_flag ;
   __u8 ac_nice ;
   __u64 cpu_count ;
   __u64 cpu_delay_total ;
   __u64 blkio_count ;
   __u64 blkio_delay_total ;
   __u64 swapin_count ;
   __u64 swapin_delay_total ;
   __u64 cpu_run_real_total ;
   __u64 cpu_run_virtual_total ;
   char ac_comm[32U] ;
   __u8 ac_sched ;
   __u8 ac_pad[3U] ;
   __u32 ac_uid ;
   __u32 ac_gid ;
   __u32 ac_pid ;
   __u32 ac_ppid ;
   __u32 ac_btime ;
   __u64 ac_etime ;
   __u64 ac_utime ;
   __u64 ac_stime ;
   __u64 ac_minflt ;
   __u64 ac_majflt ;
   __u64 coremem ;
   __u64 virtmem ;
   __u64 hiwater_rss ;
   __u64 hiwater_vm ;
   __u64 read_char ;
   __u64 write_char ;
   __u64 read_syscalls ;
   __u64 write_syscalls ;
   __u64 read_bytes ;
   __u64 write_bytes ;
   __u64 cancelled_write_bytes ;
   __u64 nvcsw ;
   __u64 nivcsw ;
   __u64 ac_utimescaled ;
   __u64 ac_stimescaled ;
   __u64 cpu_scaled_run_real_total ;
   __u64 freepages_count ;
   __u64 freepages_delay_total ;
};

#line 515  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cgroup.h"
struct netprio_map {
   struct callback_head rcu ;
   u32 priomap_len ;
   u32 priomap[] ;
};

#line 1628  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/security.h"
struct mnt_namespace;

#line 1629 
struct ipc_namespace;

#line 1630  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/security.h"
struct nsproxy {
   atomic_t count ;
   struct uts_namespace *uts_ns ;
   struct ipc_namespace *ipc_ns ;
   struct mnt_namespace *mnt_ns ;
   struct pid_namespace *pid_ns_for_children ;
   struct net *net_ns ;
};

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/netlink.h"
struct nlmsghdr {
   __u32 nlmsg_len ;
   __u16 nlmsg_type ;
   __u16 nlmsg_flags ;
   __u32 nlmsg_seq ;
   __u32 nlmsg_pid ;
};

#line 147  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/netlink.h"
struct nlattr {
   __u16 nla_len ;
   __u16 nla_type ;
};

#line 106  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netlink.h"
struct netlink_callback {
   struct sk_buff *skb ;
   struct nlmsghdr const *nlh ;
   int (*dump)(struct sk_buff *, struct netlink_callback *) ;
   int (*done)(struct netlink_callback *) ;
   void *data ;
   struct module *module ;
   u16 family ;
   u16 min_dump_alloc ;
   unsigned int prev_seq ;
   unsigned int seq ;
   long args[6U] ;
};

#line 182  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netlink.h"
struct ndmsg {
   __u8 ndm_family ;
   __u8 ndm_pad1 ;
   __u16 ndm_pad2 ;
   __s32 ndm_ifindex ;
   __u16 ndm_state ;
   __u8 ndm_flags ;
   __u8 ndm_type ;
};

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if_link.h"
struct rtnl_link_stats64 {
   __u64 rx_packets ;
   __u64 tx_packets ;
   __u64 rx_bytes ;
   __u64 tx_bytes ;
   __u64 rx_errors ;
   __u64 tx_errors ;
   __u64 rx_dropped ;
   __u64 tx_dropped ;
   __u64 multicast ;
   __u64 collisions ;
   __u64 rx_length_errors ;
   __u64 rx_over_errors ;
   __u64 rx_crc_errors ;
   __u64 rx_frame_errors ;
   __u64 rx_fifo_errors ;
   __u64 rx_missed_errors ;
   __u64 tx_aborted_errors ;
   __u64 tx_carrier_errors ;
   __u64 tx_fifo_errors ;
   __u64 tx_heartbeat_errors ;
   __u64 tx_window_errors ;
   __u64 rx_compressed ;
   __u64 tx_compressed ;
};

#line 643  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if_link.h"
struct ifla_vf_stats {
   __u64 rx_packets ;
   __u64 tx_packets ;
   __u64 rx_bytes ;
   __u64 tx_bytes ;
   __u64 broadcast ;
   __u64 multicast ;
};

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/if_link.h"
struct ifla_vf_info {
   __u32 vf ;
   __u8 mac[32U] ;
   __u32 vlan ;
   __u32 qos ;
   __u32 spoofchk ;
   __u32 linkstate ;
   __u32 min_tx_rate ;
   __u32 max_tx_rate ;
   __u32 rss_query_en ;
};

#line 118  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if_bonding.h"
struct netpoll_info;

#line 119 
struct wireless_dev;

#line 120 
struct wpan_dev;

#line 121 
struct mpls_dev;

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
enum netdev_tx {
    __NETDEV_TX_MIN = -2147483648,
    NETDEV_TX_OK = 0,
    NETDEV_TX_BUSY = 16,
    NETDEV_TX_LOCKED = 32
};

#line 110  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
typedef enum netdev_tx netdev_tx_t;

#line 129  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct net_device_stats {
   unsigned long rx_packets ;
   unsigned long tx_packets ;
   unsigned long rx_bytes ;
   unsigned long tx_bytes ;
   unsigned long rx_errors ;
   unsigned long tx_errors ;
   unsigned long rx_dropped ;
   unsigned long tx_dropped ;
   unsigned long multicast ;
   unsigned long collisions ;
   unsigned long rx_length_errors ;
   unsigned long rx_over_errors ;
   unsigned long rx_crc_errors ;
   unsigned long rx_frame_errors ;
   unsigned long rx_fifo_errors ;
   unsigned long rx_missed_errors ;
   unsigned long tx_aborted_errors ;
   unsigned long tx_carrier_errors ;
   unsigned long tx_fifo_errors ;
   unsigned long tx_heartbeat_errors ;
   unsigned long tx_window_errors ;
   unsigned long rx_compressed ;
   unsigned long tx_compressed ;
};

#line 190 
struct neigh_parms;

#line 211  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_hw_addr_list {
   struct list_head list ;
   int count ;
};

#line 216  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct hh_cache {
   u16 hh_len ;
   u16 __pad ;
   seqlock_t hh_lock ;
   unsigned long hh_data[16U] ;
};

#line 245  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct header_ops {
   int (*create)(struct sk_buff *, struct net_device *, unsigned short , void const *, void const *, unsigned int ) ;
   int (*parse)(struct sk_buff const *, unsigned char *) ;
   int (*cache)(struct neighbour const *, struct hh_cache *, __be16 ) ;
   void (*cache_update)(struct hh_cache *, struct net_device const *, unsigned char const *) ;
};

#line 295  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct napi_struct {
   struct list_head poll_list ;
   unsigned long state ;
   int weight ;
   unsigned int gro_count ;
   int (*poll)(struct napi_struct *, int ) ;
   spinlock_t poll_lock ;
   int poll_owner ;
   struct net_device *dev ;
   struct sk_buff *gro_list ;
   struct sk_buff *skb ;
   struct hrtimer timer ;
   struct list_head dev_list ;
   struct hlist_node napi_hash_node ;
   unsigned int napi_id ;
};

#line 340 
enum rx_handler_result {
    RX_HANDLER_CONSUMED = 0,
    RX_HANDLER_ANOTHER = 1,
    RX_HANDLER_EXACT = 2,
    RX_HANDLER_PASS = 3
};

#line 388  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
typedef enum rx_handler_result rx_handler_result_t;

#line 389  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
typedef rx_handler_result_t rx_handler_func_t(struct sk_buff **);

#line 537 
struct Qdisc;

#line 537  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_queue {
   struct net_device *dev ;
   struct Qdisc *qdisc ;
   struct Qdisc *qdisc_sleeping ;
   struct kobject kobj ;
   int numa_node ;
   spinlock_t _xmit_lock ;
   int xmit_lock_owner ;
   unsigned long trans_start ;
   unsigned long trans_timeout ;
   unsigned long state ;
   struct dql dql ;
   unsigned long tx_maxrate ;
};

#line 607  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct rps_map {
   unsigned int len ;
   struct callback_head rcu ;
   u16 cpus[0U] ;
};

#line 619  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct rps_dev_flow {
   u16 cpu ;
   u16 filter ;
   unsigned int last_qtail ;
};

#line 631  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct rps_dev_flow_table {
   unsigned int mask ;
   struct callback_head rcu ;
   struct rps_dev_flow flows[0U] ;
};

#line 683  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_rx_queue {
   struct rps_map *rps_map ;
   struct rps_dev_flow_table *rps_flow_table ;
   struct kobject kobj ;
   struct net_device *dev ;
};

#line 706  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct xps_map {
   unsigned int len ;
   unsigned int alloc_len ;
   struct callback_head rcu ;
   u16 queues[0U] ;
};

#line 719  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct xps_dev_maps {
   struct callback_head rcu ;
   struct xps_map *cpu_map[0U] ;
};

#line 730  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_tc_txq {
   u16 count ;
   u16 offset ;
};

#line 741  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_fcoe_hbainfo {
   char manufacturer[64U] ;
   char serial_number[64U] ;
   char hardware_version[64U] ;
   char driver_version[64U] ;
   char optionrom_version[64U] ;
   char firmware_version[64U] ;
   char model[256U] ;
   char model_description[256U] ;
};

#line 757  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_phys_item_id {
   unsigned char id[32U] ;
   unsigned char id_len ;
};

#line 770  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct net_device_ops {
   int (*ndo_init)(struct net_device *) ;
   void (*ndo_uninit)(struct net_device *) ;
   int (*ndo_open)(struct net_device *) ;
   int (*ndo_stop)(struct net_device *) ;
   netdev_tx_t (*ndo_start_xmit)(struct sk_buff *, struct net_device *) ;
   u16 (*ndo_select_queue)(struct net_device *, struct sk_buff *, void *, u16 (*)(struct net_device *, struct sk_buff *)) ;
   void (*ndo_change_rx_flags)(struct net_device *, int ) ;
   void (*ndo_set_rx_mode)(struct net_device *) ;
   int (*ndo_set_mac_address)(struct net_device *, void *) ;
   int (*ndo_validate_addr)(struct net_device *) ;
   int (*ndo_do_ioctl)(struct net_device *, struct ifreq *, int ) ;
   int (*ndo_set_config)(struct net_device *, struct ifmap *) ;
   int (*ndo_change_mtu)(struct net_device *, int ) ;
   int (*ndo_neigh_setup)(struct net_device *, struct neigh_parms *) ;
   void (*ndo_tx_timeout)(struct net_device *) ;
   struct rtnl_link_stats64 *(*ndo_get_stats64)(struct net_device *, struct rtnl_link_stats64 *) ;
   struct net_device_stats *(*ndo_get_stats)(struct net_device *) ;
   int (*ndo_vlan_rx_add_vid)(struct net_device *, __be16 , u16 ) ;
   int (*ndo_vlan_rx_kill_vid)(struct net_device *, __be16 , u16 ) ;
   void (*ndo_poll_controller)(struct net_device *) ;
   int (*ndo_netpoll_setup)(struct net_device *, struct netpoll_info *) ;
   void (*ndo_netpoll_cleanup)(struct net_device *) ;
   int (*ndo_busy_poll)(struct napi_struct *) ;
   int (*ndo_set_vf_mac)(struct net_device *, int , u8 *) ;
   int (*ndo_set_vf_vlan)(struct net_device *, int , u16 , u8 ) ;
   int (*ndo_set_vf_rate)(struct net_device *, int , int , int ) ;
   int (*ndo_set_vf_spoofchk)(struct net_device *, int , bool ) ;
   int (*ndo_get_vf_config)(struct net_device *, int , struct ifla_vf_info *) ;
   int (*ndo_set_vf_link_state)(struct net_device *, int , int ) ;
   int (*ndo_get_vf_stats)(struct net_device *, int , struct ifla_vf_stats *) ;
   int (*ndo_set_vf_port)(struct net_device *, int , struct nlattr **) ;
   int (*ndo_get_vf_port)(struct net_device *, int , struct sk_buff *) ;
   int (*ndo_set_vf_rss_query_en)(struct net_device *, int , bool ) ;
   int (*ndo_setup_tc)(struct net_device *, u8 ) ;
   int (*ndo_fcoe_enable)(struct net_device *) ;
   int (*ndo_fcoe_disable)(struct net_device *) ;
   int (*ndo_fcoe_ddp_setup)(struct net_device *, u16 , struct scatterlist *, unsigned int ) ;
   int (*ndo_fcoe_ddp_done)(struct net_device *, u16 ) ;
   int (*ndo_fcoe_ddp_target)(struct net_device *, u16 , struct scatterlist *, unsigned int ) ;
   int (*ndo_fcoe_get_hbainfo)(struct net_device *, struct netdev_fcoe_hbainfo *) ;
   int (*ndo_fcoe_get_wwn)(struct net_device *, u64 *, int ) ;
   int (*ndo_rx_flow_steer)(struct net_device *, struct sk_buff const *, u16 , u32 ) ;
   int (*ndo_add_slave)(struct net_device *, struct net_device *) ;
   int (*ndo_del_slave)(struct net_device *, struct net_device *) ;
   netdev_features_t (*ndo_fix_features)(struct net_device *, netdev_features_t ) ;
   int (*ndo_set_features)(struct net_device *, netdev_features_t ) ;
   int (*ndo_neigh_construct)(struct neighbour *) ;
   void (*ndo_neigh_destroy)(struct neighbour *) ;
   int (*ndo_fdb_add)(struct ndmsg *, struct nlattr **, struct net_device *, unsigned char const *, u16 , u16 ) ;
   int (*ndo_fdb_del)(struct ndmsg *, struct nlattr **, struct net_device *, unsigned char const *, u16 ) ;
   int (*ndo_fdb_dump)(struct sk_buff *, struct netlink_callback *, struct net_device *, struct net_device *, int ) ;
   int (*ndo_bridge_setlink)(struct net_device *, struct nlmsghdr *, u16 ) ;
   int (*ndo_bridge_getlink)(struct sk_buff *, u32 , u32 , struct net_device *, u32 , int ) ;
   int (*ndo_bridge_dellink)(struct net_device *, struct nlmsghdr *, u16 ) ;
   int (*ndo_change_carrier)(struct net_device *, bool ) ;
   int (*ndo_get_phys_port_id)(struct net_device *, struct netdev_phys_item_id *) ;
   int (*ndo_get_phys_port_name)(struct net_device *, char *, size_t ) ;
   void (*ndo_add_vxlan_port)(struct net_device *, sa_family_t , __be16 ) ;
   void (*ndo_del_vxlan_port)(struct net_device *, sa_family_t , __be16 ) ;
   void *(*ndo_dfwd_add_station)(struct net_device *, struct net_device *) ;
   void (*ndo_dfwd_del_station)(struct net_device *, void *) ;
   netdev_tx_t (*ndo_dfwd_start_xmit)(struct sk_buff *, struct net_device *, void *) ;
   int (*ndo_get_lock_subclass)(struct net_device *) ;
   netdev_features_t (*ndo_features_check)(struct sk_buff *, struct net_device *, netdev_features_t ) ;
   int (*ndo_set_tx_maxrate)(struct net_device *, int , u32 ) ;
   int (*ndo_get_iflink)(struct net_device const *) ;
};

#line 1243 
enum ldv_30181 {
    NETREG_UNINITIALIZED = 0,
    NETREG_REGISTERED = 1,
    NETREG_UNREGISTERING = 2,
    NETREG_UNREGISTERED = 3,
    NETREG_RELEASED = 4,
    NETREG_DUMMY = 5
};

#line 1252 
enum ldv_30182 {
    RTNL_LINK_INITIALIZED = 0,
    RTNL_LINK_INITIALIZING = 1
};

#line 1257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct __anonstruct_adj_list_343 {
   struct list_head upper ;
   struct list_head lower ;
};

#line 1257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct __anonstruct_all_adj_list_344 {
   struct list_head upper ;
   struct list_head lower ;
};

#line 1257 
struct iw_handler_def;

#line 1257 
struct iw_public_data;

#line 1257 
struct switchdev_ops;

#line 1257 
struct vlan_info;

#line 1257 
struct tipc_bearer;

#line 1257 
struct in_device;

#line 1257 
struct dn_dev;

#line 1257 
struct inet6_dev;

#line 1257 
struct tcf_proto;

#line 1257 
struct cpu_rmap;

#line 1257 
struct pcpu_lstats;

#line 1257 
struct pcpu_sw_netstats;

#line 1257 
struct pcpu_dstats;

#line 1257 
struct pcpu_vstats;

#line 1257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
union __anonunion_345 {
   void *ml_priv ;
   struct pcpu_lstats *lstats ;
   struct pcpu_sw_netstats *tstats ;
   struct pcpu_dstats *dstats ;
   struct pcpu_vstats *vstats ;
};

#line 1257 
struct garp_port;

#line 1257 
struct mrp_port;

#line 1257 
struct rtnl_link_ops;

#line 1257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct net_device {
   char name[16U] ;
   struct hlist_node name_hlist ;
   char *ifalias ;
   unsigned long mem_end ;
   unsigned long mem_start ;
   unsigned long base_addr ;
   int irq ;
   atomic_t carrier_changes ;
   unsigned long state ;
   struct list_head dev_list ;
   struct list_head napi_list ;
   struct list_head unreg_list ;
   struct list_head close_list ;
   struct list_head ptype_all ;
   struct list_head ptype_specific ;
   struct __anonstruct_adj_list_343 adj_list ;
   struct __anonstruct_all_adj_list_344 all_adj_list ;
   netdev_features_t features ;
   netdev_features_t hw_features ;
   netdev_features_t wanted_features ;
   netdev_features_t vlan_features ;
   netdev_features_t hw_enc_features ;
   netdev_features_t mpls_features ;
   int ifindex ;
   int group ;
   struct net_device_stats stats ;
   atomic_long_t rx_dropped ;
   atomic_long_t tx_dropped ;
   struct iw_handler_def const *wireless_handlers ;
   struct iw_public_data *wireless_data ;
   struct net_device_ops const *netdev_ops ;
   struct ethtool_ops const *ethtool_ops ;
   struct switchdev_ops const *switchdev_ops ;
   struct header_ops const *header_ops ;
   unsigned int flags ;
   unsigned int priv_flags ;
   unsigned short gflags ;
   unsigned short padded ;
   unsigned char operstate ;
   unsigned char link_mode ;
   unsigned char if_port ;
   unsigned char dma ;
   unsigned int mtu ;
   unsigned short type ;
   unsigned short hard_header_len ;
   unsigned short needed_headroom ;
   unsigned short needed_tailroom ;
   unsigned char perm_addr[32U] ;
   unsigned char addr_assign_type ;
   unsigned char addr_len ;
   unsigned short neigh_priv_len ;
   unsigned short dev_id ;
   unsigned short dev_port ;
   spinlock_t addr_list_lock ;
   unsigned char name_assign_type ;
   bool uc_promisc ;
   struct netdev_hw_addr_list uc ;
   struct netdev_hw_addr_list mc ;
   struct netdev_hw_addr_list dev_addrs ;
   struct kset *queues_kset ;
   unsigned int promiscuity ;
   unsigned int allmulti ;
   struct vlan_info *vlan_info ;
   struct dsa_switch_tree *dsa_ptr ;
   struct tipc_bearer *tipc_ptr ;
   void *atalk_ptr ;
   struct in_device *ip_ptr ;
   struct dn_dev *dn_ptr ;
   struct inet6_dev *ip6_ptr ;
   void *ax25_ptr ;
   struct wireless_dev *ieee80211_ptr ;
   struct wpan_dev *ieee802154_ptr ;
   struct mpls_dev *mpls_ptr ;
   unsigned long last_rx ;
   unsigned char *dev_addr ;
   struct netdev_rx_queue *_rx ;
   unsigned int num_rx_queues ;
   unsigned int real_num_rx_queues ;
   unsigned long gro_flush_timeout ;
   rx_handler_func_t *rx_handler ;
   void *rx_handler_data ;
   struct tcf_proto *ingress_cl_list ;
   struct netdev_queue *ingress_queue ;
   struct list_head nf_hooks_ingress ;
   unsigned char broadcast[32U] ;
   struct cpu_rmap *rx_cpu_rmap ;
   struct hlist_node index_hlist ;
   struct netdev_queue *_tx ;
   unsigned int num_tx_queues ;
   unsigned int real_num_tx_queues ;
   struct Qdisc *qdisc ;
   unsigned long tx_queue_len ;
   spinlock_t tx_global_lock ;
   int watchdog_timeo ;
   struct xps_dev_maps *xps_maps ;
   unsigned long trans_start ;
   struct timer_list watchdog_timer ;
   int *pcpu_refcnt ;
   struct list_head todo_list ;
   struct list_head link_watch_list ;
   enum ldv_30181 __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) reg_state : 8 ;
   bool dismantle ;
   enum ldv_30182 __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))) rtnl_link_state : 16 ;
   void (*destructor)(struct net_device *) ;
   struct netpoll_info *npinfo ;
   possible_net_t nd_net ;
   union __anonunion_345 __anonCompField_net_device_94 ;
   struct garp_port *garp_port ;
   struct mrp_port *mrp_port ;
   struct device dev ;
   struct attribute_group const *sysfs_groups[4U] ;
   struct attribute_group const *sysfs_rx_queue_group ;
   struct rtnl_link_ops const *rtnl_link_ops ;
   unsigned int gso_max_size ;
   u16 gso_max_segs ;
   u16 gso_min_segs ;
   struct dcbnl_rtnl_ops const *dcbnl_ops ;
   u8 num_tc ;
   struct netdev_tc_txq tc_to_txq[16U] ;
   u8 prio_tc_map[16U] ;
   unsigned int fcoe_ddp_xid ;
   struct netprio_map *priomap ;
   struct phy_device *phydev ;
   struct lock_class_key *qdisc_tx_busylock ;
};

#line 1978  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct packet_type {
   __be16 type ;
   struct net_device *dev ;
   int (*func)(struct sk_buff *, struct net_device *, struct packet_type *, struct net_device *) ;
   bool (*id_match)(struct packet_type *, struct sock *) ;
   void *af_packet_priv ;
   struct list_head list ;
};

#line 2025  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct pcpu_sw_netstats {
   u64 rx_packets ;
   u64 rx_bytes ;
   u64 tx_packets ;
   u64 tx_bytes ;
   struct u64_stats_sync syncp ;
};

#line 470  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/debugfs.h"
enum nl80211_iftype {
    NL80211_IFTYPE_UNSPECIFIED = 0,
    NL80211_IFTYPE_ADHOC = 1,
    NL80211_IFTYPE_STATION = 2,
    NL80211_IFTYPE_AP = 3,
    NL80211_IFTYPE_AP_VLAN = 4,
    NL80211_IFTYPE_WDS = 5,
    NL80211_IFTYPE_MONITOR = 6,
    NL80211_IFTYPE_MESH_POINT = 7,
    NL80211_IFTYPE_P2P_CLIENT = 8,
    NL80211_IFTYPE_P2P_GO = 9,
    NL80211_IFTYPE_P2P_DEVICE = 10,
    NL80211_IFTYPE_OCB = 11,
    NUM_NL80211_IFTYPES = 12,
    NL80211_IFTYPE_MAX = 11
};

#line 2431  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/nl80211.h"
enum nl80211_reg_initiator {
    NL80211_REGDOM_SET_BY_CORE = 0,
    NL80211_REGDOM_SET_BY_USER = 1,
    NL80211_REGDOM_SET_BY_DRIVER = 2,
    NL80211_REGDOM_SET_BY_COUNTRY_IE = 3
};

#line 2484 
enum nl80211_dfs_regions {
    NL80211_DFS_UNSET = 0,
    NL80211_DFS_FCC = 1,
    NL80211_DFS_ETSI = 2,
    NL80211_DFS_JP = 3
};

#line 2491 
enum nl80211_user_reg_hint_type {
    NL80211_USER_REG_HINT_USER = 0,
    NL80211_USER_REG_HINT_CELL_BASE = 1,
    NL80211_USER_REG_HINT_INDOOR = 2
};

#line 2600 
enum nl80211_channel_type {
    NL80211_CHAN_NO_HT = 0,
    NL80211_CHAN_HT20 = 1,
    NL80211_CHAN_HT40MINUS = 2,
    NL80211_CHAN_HT40PLUS = 3
};

#line 2607 
enum nl80211_chan_width {
    NL80211_CHAN_WIDTH_20_NOHT = 0,
    NL80211_CHAN_WIDTH_20 = 1,
    NL80211_CHAN_WIDTH_40 = 2,
    NL80211_CHAN_WIDTH_80 = 3,
    NL80211_CHAN_WIDTH_80P80 = 4,
    NL80211_CHAN_WIDTH_160 = 5,
    NL80211_CHAN_WIDTH_5 = 6,
    NL80211_CHAN_WIDTH_10 = 7
};

#line 2618 
enum nl80211_bss_scan_width {
    NL80211_BSS_CHAN_WIDTH_20 = 0,
    NL80211_BSS_CHAN_WIDTH_10 = 1,
    NL80211_BSS_CHAN_WIDTH_5 = 2
};

#line 2650 
enum nl80211_auth_type {
    NL80211_AUTHTYPE_OPEN_SYSTEM = 0,
    NL80211_AUTHTYPE_SHARED_KEY = 1,
    NL80211_AUTHTYPE_FT = 2,
    NL80211_AUTHTYPE_NETWORK_EAP = 3,
    NL80211_AUTHTYPE_SAE = 4,
    __NL80211_AUTHTYPE_NUM = 5,
    NL80211_AUTHTYPE_MAX = 4,
    NL80211_AUTHTYPE_AUTOMATIC = 5
};

#line 2668 
enum nl80211_mfp {
    NL80211_MFP_NO = 0,
    NL80211_MFP_REQUIRED = 1
};

#line 3596 
enum nl80211_tx_power_setting {
    NL80211_TX_POWER_AUTOMATIC = 0,
    NL80211_TX_POWER_LIMITED = 1,
    NL80211_TX_POWER_FIXED = 2
};

#line 3734  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/nl80211.h"
struct nl80211_wowlan_tcp_data_seq {
   __u32 start ;
   __u32 offset ;
   __u32 len ;
};

#line 3871  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/nl80211.h"
struct nl80211_wowlan_tcp_data_token {
   __u32 offset ;
   __u32 len ;
   __u8 token_stream[] ;
};

#line 3883  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/nl80211.h"
struct nl80211_wowlan_tcp_data_token_feature {
   __u32 min_len ;
   __u32 max_len ;
   __u32 bufsize ;
};

#line 4131 
enum nl80211_dfs_state {
    NL80211_DFS_USABLE = 0,
    NL80211_DFS_UNAVAILABLE = 1,
    NL80211_DFS_AVAILABLE = 2
};

#line 4153  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/nl80211.h"
struct nl80211_vendor_cmd_info {
   __u32 vendor_id ;
   __u32 subcmd ;
};

#line 4581 
enum environment_cap {
    ENVIRON_ANY = 0,
    ENVIRON_INDOOR = 1,
    ENVIRON_OUTDOOR = 2
};

#line 4587  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/nl80211.h"
struct regulatory_request {
   struct callback_head callback_head ;
   int wiphy_idx ;
   enum nl80211_reg_initiator initiator ;
   enum nl80211_user_reg_hint_type user_reg_hint_type ;
   char alpha2[2U] ;
   enum nl80211_dfs_regions dfs_region ;
   bool intersect ;
   bool processed ;
   enum environment_cap country_ie_env ;
   struct list_head list ;
};

#line 99  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/regulatory.h"
struct ieee80211_freq_range {
   u32 start_freq_khz ;
   u32 end_freq_khz ;
   u32 max_bandwidth_khz ;
};

#line 185  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/regulatory.h"
struct ieee80211_power_rule {
   u32 max_antenna_gain ;
   u32 max_eirp ;
};

#line 190  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/regulatory.h"
struct ieee80211_reg_rule {
   struct ieee80211_freq_range freq_range ;
   struct ieee80211_power_rule power_rule ;
   u32 flags ;
   u32 dfs_cac_ms ;
};

#line 197  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/regulatory.h"
struct ieee80211_regdomain {
   struct callback_head callback_head ;
   u32 n_reg_rules ;
   char alpha2[3U] ;
   enum nl80211_dfs_regions dfs_region ;
   struct ieee80211_reg_rule reg_rules[] ;
};

#line 205 
struct wiphy;

#line 206 
enum ieee80211_band {
    IEEE80211_BAND_2GHZ = 0,
    IEEE80211_BAND_5GHZ = 1,
    IEEE80211_BAND_60GHZ = 2,
    IEEE80211_NUM_BANDS = 3
};

#line 228  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/regulatory.h"
struct ieee80211_channel {
   enum ieee80211_band band ;
   u16 center_freq ;
   u16 hw_value ;
   u32 flags ;
   int max_antenna_gain ;
   int max_power ;
   int max_reg_power ;
   bool beacon_found ;
   u32 orig_flags ;
   int orig_mag ;
   int orig_mpwr ;
   enum nl80211_dfs_state dfs_state ;
   unsigned long dfs_state_entered ;
   unsigned int dfs_cac_ms ;
};

#line 207  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct ieee80211_rate {
   u32 flags ;
   u16 bitrate ;
   u16 hw_value ;
   u16 hw_value_short ;
};

#line 269  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct ieee80211_sta_ht_cap {
   u16 cap ;
   bool ht_supported ;
   u8 ampdu_factor ;
   u8 ampdu_density ;
   struct ieee80211_mcs_info mcs ;
};

#line 289  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct ieee80211_sta_vht_cap {
   bool vht_supported ;
   u32 cap ;
   struct ieee80211_vht_mcs_info vht_mcs ;
};

#line 305  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct ieee80211_supported_band {
   struct ieee80211_channel *channels ;
   struct ieee80211_rate *bitrates ;
   enum ieee80211_band band ;
   int n_channels ;
   int n_bitrates ;
   struct ieee80211_sta_ht_cap ht_cap ;
   struct ieee80211_sta_vht_cap vht_cap ;
};

#line 387  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct cfg80211_chan_def {
   struct ieee80211_channel *chan ;
   enum nl80211_chan_width width ;
   u32 center_freq1 ;
   u32 center_freq2 ;
};

#line 608  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct cfg80211_crypto_settings {
   u32 wpa_versions ;
   u32 cipher_group ;
   int n_ciphers_pairwise ;
   u32 ciphers_pairwise[5U] ;
   int n_akm_suites ;
   u32 akm_suites[2U] ;
   bool control_port ;
   __be16 control_port_ethertype ;
   bool control_port_no_encrypt ;
};

#line 671  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct mac_address {
   u8 addr[6U] ;
};

#line 1395  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct cfg80211_ssid {
   u8 ssid[32U] ;
   u8 ssid_len ;
};

#line 1428  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct cfg80211_scan_request {
   struct cfg80211_ssid *ssids ;
   int n_ssids ;
   u32 n_channels ;
   enum nl80211_bss_scan_width scan_width ;
   u8 const *ie ;
   size_t ie_len ;
   u32 flags ;
   u32 rates[3U] ;
   struct wireless_dev *wdev ;
   u8 mac_addr[6U] ;
   u8 mac_addr_mask[6U] ;
   struct wiphy *wiphy ;
   unsigned long scan_start ;
   bool aborted ;
   bool notified ;
   bool no_cck ;
   struct ieee80211_channel *channels[0U] ;
};

#line 1491  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct cfg80211_match_set {
   struct cfg80211_ssid ssid ;
   s32 rssi_thold ;
};

#line 1499  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct cfg80211_sched_scan_request {
   struct cfg80211_ssid *ssids ;
   int n_ssids ;
   u32 n_channels ;
   enum nl80211_bss_scan_width scan_width ;
   u32 interval ;
   u8 const *ie ;
   size_t ie_len ;
   u32 flags ;
   struct cfg80211_match_set *match_sets ;
   int n_match_sets ;
   s32 min_rssi_thold ;
   u32 delay ;
   u8 mac_addr[6U] ;
   u8 mac_addr_mask[6U] ;
   struct wiphy *wiphy ;
   struct net_device *dev ;
   unsigned long scan_start ;
   struct callback_head callback_head ;
   u32 owner_nlportid ;
   struct ieee80211_channel *channels[0U] ;
};

#line 1561 
enum cfg80211_signal_type {
    CFG80211_SIGNAL_TYPE_NONE = 0,
    CFG80211_SIGNAL_TYPE_MBM = 1,
    CFG80211_SIGNAL_TYPE_UNSPEC = 2
};

#line 1766  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct cfg80211_ibss_params {
   u8 const *ssid ;
   u8 const *bssid ;
   struct cfg80211_chan_def chandef ;
   u8 const *ie ;
   u8 ssid_len ;
   u8 ie_len ;
   u16 beacon_interval ;
   u32 basic_rates ;
   bool channel_fixed ;
   bool privacy ;
   bool control_port ;
   bool userspace_handles_dfs ;
   int mcast_rate[3U] ;
   struct ieee80211_ht_cap ht_capa ;
   struct ieee80211_ht_cap ht_capa_mask ;
};

#line 1814  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct cfg80211_connect_params {
   struct ieee80211_channel *channel ;
   struct ieee80211_channel *channel_hint ;
   u8 const *bssid ;
   u8 const *bssid_hint ;
   u8 const *ssid ;
   size_t ssid_len ;
   enum nl80211_auth_type auth_type ;
   u8 const *ie ;
   size_t ie_len ;
   bool privacy ;
   enum nl80211_mfp mfp ;
   struct cfg80211_crypto_settings crypto ;
   u8 const *key ;
   u8 key_len ;
   u8 key_idx ;
   u32 flags ;
   int bg_scan_period ;
   struct ieee80211_ht_cap ht_capa ;
   struct ieee80211_ht_cap ht_capa_mask ;
   struct ieee80211_vht_cap vht_capa ;
   struct ieee80211_vht_cap vht_capa_mask ;
};

#line 1916  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct cfg80211_pkt_pattern {
   u8 const *mask ;
   u8 const *pattern ;
   int pattern_len ;
   int pkt_offset ;
};

#line 1933  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct cfg80211_wowlan_tcp {
   struct socket *sock ;
   __be32 src ;
   __be32 dst ;
   u16 src_port ;
   u16 dst_port ;
   u8 dst_mac[6U] ;
   int payload_len ;
   u8 const *payload ;
   struct nl80211_wowlan_tcp_data_seq payload_seq ;
   u32 data_interval ;
   u32 wake_len ;
   u8 const *wake_data ;
   u8 const *wake_mask ;
   u32 tokens_size ;
   struct nl80211_wowlan_tcp_data_token payload_tok ;
};

#line 1968  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct cfg80211_wowlan {
   bool any ;
   bool disconnect ;
   bool magic_pkt ;
   bool gtk_rekey_failure ;
   bool eap_identity_req ;
   bool four_way_handshake ;
   bool rfkill_release ;
   struct cfg80211_pkt_pattern *patterns ;
   struct cfg80211_wowlan_tcp *tcp ;
   int n_patterns ;
   struct cfg80211_sched_scan_request *nd_config ;
};

#line 2736  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct ieee80211_iface_limit {
   u16 max ;
   u16 types ;
};

#line 2797  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct ieee80211_iface_combination {
   struct ieee80211_iface_limit const *limits ;
   u32 num_different_channels ;
   u16 max_interfaces ;
   u8 n_limits ;
   bool beacon_int_infra_match ;
   u8 radar_detect_widths ;
   u8 radar_detect_regions ;
};

#line 2869  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct ieee80211_txrx_stypes {
   u16 tx ;
   u16 rx ;
};

#line 2885  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct wiphy_wowlan_tcp_support {
   struct nl80211_wowlan_tcp_data_token_feature const *tok ;
   u32 data_payload_max ;
   u32 data_interval_max ;
   u32 wake_payload_max ;
   bool seq ;
};

#line 2910  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct wiphy_wowlan_support {
   u32 flags ;
   int n_patterns ;
   int pattern_max_len ;
   int pattern_min_len ;
   int max_pkt_offset ;
   int max_nd_match_sets ;
   struct wiphy_wowlan_tcp_support const *tcp ;
};

#line 2935  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct wiphy_coalesce_support {
   int n_rules ;
   int max_delay ;
   int n_patterns ;
   int pattern_max_len ;
   int pattern_min_len ;
   int max_pkt_offset ;
};

#line 2960  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct wiphy_vendor_command {
   struct nl80211_vendor_cmd_info info ;
   u32 flags ;
   int (*doit)(struct wiphy *, struct wireless_dev *, void const *, int ) ;
};

#line 2981  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct wiphy {
   u8 perm_addr[6U] ;
   u8 addr_mask[6U] ;
   struct mac_address *addresses ;
   struct ieee80211_txrx_stypes const *mgmt_stypes ;
   struct ieee80211_iface_combination const *iface_combinations ;
   int n_iface_combinations ;
   u16 software_iftypes ;
   u16 n_addresses ;
   u16 interface_modes ;
   u16 max_acl_mac_addrs ;
   u32 flags ;
   u32 regulatory_flags ;
   u32 features ;
   u8 ext_features[1U] ;
   u32 ap_sme_capa ;
   enum cfg80211_signal_type signal_type ;
   int bss_priv_size ;
   u8 max_scan_ssids ;
   u8 max_sched_scan_ssids ;
   u8 max_match_sets ;
   u16 max_scan_ie_len ;
   u16 max_sched_scan_ie_len ;
   int n_cipher_suites ;
   u32 const *cipher_suites ;
   u8 retry_short ;
   u8 retry_long ;
   u32 frag_threshold ;
   u32 rts_threshold ;
   u8 coverage_class ;
   char fw_version[32U] ;
   u32 hw_version ;
   struct wiphy_wowlan_support const *wowlan ;
   struct cfg80211_wowlan *wowlan_config ;
   u16 max_remain_on_channel_duration ;
   u8 max_num_pmkids ;
   u32 available_antennas_tx ;
   u32 available_antennas_rx ;
   u32 probe_resp_offload ;
   u8 const *extended_capabilities ;
   u8 const *extended_capabilities_mask ;
   u8 extended_capabilities_len ;
   void const *privid ;
   struct ieee80211_supported_band *bands[3U] ;
   void (*reg_notifier)(struct wiphy *, struct regulatory_request *) ;
   struct ieee80211_regdomain const *regd ;
   struct device dev ;
   bool registered ;
   struct dentry *debugfsdir ;
   struct ieee80211_ht_cap const *ht_capa_mod_mask ;
   struct ieee80211_vht_cap const *vht_capa_mod_mask ;
   possible_net_t _net ;
   struct iw_handler_def const *wext ;
   struct wiphy_coalesce_support const *coalesce ;
   struct wiphy_vendor_command const *vendor_commands ;
   struct nl80211_vendor_cmd_info const *vendor_events ;
   int n_vendor_commands ;
   int n_vendor_events ;
   u16 max_ap_assoc_sta ;
   u8 max_num_csa_counters ;
   u8 max_adj_channel_rssi_comp ;
   char priv[0U] ;
};

#line 3369 
struct cfg80211_conn;

#line 3370 
struct cfg80211_internal_bss;

#line 3371 
struct cfg80211_cached_keys;

#line 3372  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct __anonstruct_wext_351 {
   struct cfg80211_ibss_params ibss ;
   struct cfg80211_connect_params connect ;
   struct cfg80211_cached_keys *keys ;
   u8 const *ie ;
   size_t ie_len ;
   u8 bssid[6U] ;
   u8 prev_bssid[6U] ;
   u8 ssid[32U] ;
   s8 default_key ;
   s8 default_mgmt_key ;
   bool prev_bssid_valid ;
};

#line 3372  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct wireless_dev {
   struct wiphy *wiphy ;
   enum nl80211_iftype iftype ;
   struct list_head list ;
   struct net_device *netdev ;
   u32 identifier ;
   struct list_head mgmt_registrations ;
   spinlock_t mgmt_registrations_lock ;
   struct mutex mtx ;
   bool use_4addr ;
   bool p2p_started ;
   u8 address[6U] ;
   u8 ssid[32U] ;
   u8 ssid_len ;
   u8 mesh_id_len ;
   u8 mesh_id_up_len ;
   struct cfg80211_conn *conn ;
   struct cfg80211_cached_keys *connect_keys ;
   struct list_head event_list ;
   spinlock_t event_lock ;
   struct cfg80211_internal_bss *current_bss ;
   struct cfg80211_chan_def preset_chandef ;
   struct cfg80211_chan_def chandef ;
   bool ibss_fixed ;
   bool ibss_dfs_possible ;
   bool ps ;
   int ps_timeout ;
   int beacon_interval ;
   u32 ap_unexpected_nlportid ;
   bool cac_started ;
   unsigned long cac_start_time ;
   unsigned int cac_time_ms ;
   u32 owner_nlportid ;
   struct __anonstruct_wext_351 wext ;
};

#line 187  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct ieee80211_chanctx_conf {
   struct cfg80211_chan_def def ;
   struct cfg80211_chan_def min_def ;
   u8 rx_chains_static ;
   u8 rx_chains_dynamic ;
   bool radar_enabled ;
   u8 drv_priv[0U] ;
};

#line 229 
struct ieee80211_vif;

#line 407 
struct ieee80211_sta;

#line 436  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct ieee80211_bss_conf {
   u8 const *bssid ;
   bool assoc ;
   bool ibss_joined ;
   bool ibss_creator ;
   u16 aid ;
   bool use_cts_prot ;
   bool use_short_preamble ;
   bool use_short_slot ;
   bool enable_beacon ;
   u8 dtim_period ;
   u16 beacon_int ;
   u16 assoc_capability ;
   u64 sync_tsf ;
   u32 sync_device_ts ;
   u8 sync_dtim_count ;
   u32 basic_rates ;
   struct ieee80211_rate *beacon_rate ;
   int mcast_rate[3U] ;
   u16 ht_operation_mode ;
   s32 cqm_rssi_thold ;
   u32 cqm_rssi_hyst ;
   struct cfg80211_chan_def chandef ;
   __be32 arp_addr_list[4U] ;
   int arp_addr_cnt ;
   bool qos ;
   bool idle ;
   bool ps ;
   u8 ssid[32U] ;
   size_t ssid_len ;
   bool hidden_ssid ;
   int txpower ;
   enum nl80211_tx_power_setting txpower_type ;
   struct ieee80211_p2p_noa_attr p2p_noa_attr ;
};

#line 819 
struct ieee80211_key_conf;

#line 896  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct ieee80211_scan_ies {
   u8 const *ies[3U] ;
   size_t len[3U] ;
   u8 const *common_ies ;
   size_t common_ie_len ;
};

#line 1174 
enum ieee80211_smps_mode {
    IEEE80211_SMPS_AUTOMATIC = 0,
    IEEE80211_SMPS_OFF = 1,
    IEEE80211_SMPS_STATIC = 2,
    IEEE80211_SMPS_DYNAMIC = 3,
    IEEE80211_SMPS_NUM_MODES = 4
};

#line 1182  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct ieee80211_conf {
   u32 flags ;
   int power_level ;
   int dynamic_ps_timeout ;
   int max_sleep_period ;
   u16 listen_interval ;
   u8 ps_dtim_period ;
   u8 long_frame_max_tx_count ;
   u8 short_frame_max_tx_count ;
   struct cfg80211_chan_def chandef ;
   bool radar_enabled ;
   enum ieee80211_smps_mode smps_mode ;
};

#line 1285  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct ieee80211_channel_switch {
   u64 timestamp ;
   u32 device_timestamp ;
   bool block_tx ;
   struct cfg80211_chan_def chandef ;
   u8 count ;
};

#line 1316 
struct ieee80211_txq;

#line 1316  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct ieee80211_vif {
   enum nl80211_iftype type ;
   struct ieee80211_bss_conf bss_conf ;
   u8 addr[6U] ;
   bool p2p ;
   bool csa_active ;
   u8 cab_queue ;
   u8 hw_queue[4U] ;
   struct ieee80211_txq *txq ;
   struct ieee80211_chanctx_conf *chanctx_conf ;
   u32 driver_flags ;
   struct dentry *debugfs_dir ;
   u8 drv_priv[0U] ;
};

#line 1432  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct ieee80211_key_conf {
   atomic64_t tx_pn ;
   u32 cipher ;
   u8 icv_len ;
   u8 iv_len ;
   u8 hw_key_idx ;
   u8 flags ;
   s8 keyidx ;
   u8 keylen ;
   u8 key[0U] ;
};

#line 1547  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct ieee80211_cipher_scheme {
   u32 cipher ;
   u16 iftype ;
   u8 hdr_len ;
   u8 pn_len ;
   u8 pn_off ;
   u8 key_idx_off ;
   u8 key_idx_mask ;
   u8 key_idx_shift ;
   u8 mic_len ;
};

#line 1577 
enum set_key_cmd {
    SET_KEY = 0,
    DISABLE_KEY = 1
};

#line 1590 
enum ieee80211_sta_rx_bandwidth {
    IEEE80211_STA_RX_BW_20 = 0,
    IEEE80211_STA_RX_BW_40 = 1,
    IEEE80211_STA_RX_BW_80 = 2,
    IEEE80211_STA_RX_BW_160 = 3
};

#line 1597  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct __anonstruct_rate_367 {
   s8 idx ;
   u8 count ;
   u8 count_cts ;
   u8 count_rts ;
   u16 flags ;
};

#line 1597  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct ieee80211_sta_rates {
   struct callback_head callback_head ;
   struct __anonstruct_rate_367 rate[4U] ;
};

#line 1645  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct ieee80211_sta {
   u32 supp_rates[3U] ;
   u8 addr[6U] ;
   u16 aid ;
   struct ieee80211_sta_ht_cap ht_cap ;
   struct ieee80211_sta_vht_cap vht_cap ;
   bool wme ;
   u8 uapsd_queues ;
   u8 max_sp ;
   u8 rx_nss ;
   enum ieee80211_sta_rx_bandwidth bandwidth ;
   enum ieee80211_smps_mode smps_mode ;
   struct ieee80211_sta_rates *rates ;
   bool tdls ;
   bool tdls_initiator ;
   bool mfp ;
   struct ieee80211_txq *txq[16U] ;
   u8 drv_priv[0U] ;
};

#line 1726  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct ieee80211_txq {
   struct ieee80211_vif *vif ;
   struct ieee80211_sta *sta ;
   u8 tid ;
   u8 ac ;
   u8 drv_priv[0U] ;
};

#line 1781  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct ieee80211_hw {
   struct ieee80211_conf conf ;
   struct wiphy *wiphy ;
   char const *rate_control_algorithm ;
   void *priv ;
   unsigned long flags[1U] ;
   unsigned int extra_tx_headroom ;
   unsigned int extra_beacon_tailroom ;
   int vif_data_size ;
   int sta_data_size ;
   int chanctx_data_size ;
   int txq_data_size ;
   u16 queues ;
   u16 max_listen_interval ;
   s8 max_signal ;
   u8 max_rates ;
   u8 max_report_rates ;
   u8 max_rate_tries ;
   u8 max_rx_aggregation_subframes ;
   u8 max_tx_aggregation_subframes ;
   u8 offchannel_tx_hw_queue ;
   u8 radiotap_mcs_details ;
   u16 radiotap_vht_details ;
   netdev_features_t netdev_features ;
   u8 uapsd_queues ;
   u8 uapsd_max_sp_len ;
   u8 n_cipher_schemes ;
   struct ieee80211_cipher_scheme const *cipher_schemes ;
   int txq_ac_max_pending ;
};

#line 5586  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct conf_sg_settings {
   u32 params[67U] ;
   u8 state ;
};

#line 356  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/conf.h"
struct conf_rx_settings {
   u32 rx_msdu_life_time ;
   u32 packet_detection_threshold ;
   u16 ps_poll_timeout ;
   u16 upsd_timeout ;
   u16 rts_threshold ;
   u16 rx_cca_threshold ;
   u16 irq_blk_threshold ;
   u16 irq_pkt_threshold ;
   u16 irq_timeout ;
   u8 queue_type ;
};

#line 435  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/conf.h"
struct conf_tx_rate_class {
   u32 enabled_rates ;
   u8 short_retry_limit ;
   u8 long_retry_limit ;
   u8 aflags ;
};

#line 542  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/conf.h"
struct conf_tx_ac_category {
   u8 ac ;
   u8 cw_min ;
   u16 cw_max ;
   u8 aifsn ;
   u16 tx_op_limit ;
};

#line 609  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/conf.h"
struct conf_tx_tid {
   u8 queue_id ;
   u8 channel_type ;
   u8 tsid ;
   u8 ps_scheme ;
   u8 ack_policy ;
   u32 apsd_conf[2U] ;
};

#line 624  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/conf.h"
struct conf_tx_settings {
   u8 tx_energy_detection ;
   struct conf_tx_rate_class sta_rc_conf ;
   u8 ac_conf_count ;
   struct conf_tx_ac_category ac_conf[4U] ;
   u8 max_tx_retries ;
   u16 ap_aging_period ;
   u8 tid_conf_count ;
   struct conf_tx_tid tid_conf[8U] ;
   u16 frag_threshold ;
   u16 tx_compl_timeout ;
   u16 tx_compl_threshold ;
   u32 basic_rate ;
   u32 basic_rate_5 ;
   u8 tmpl_short_retry_limit ;
   u8 tmpl_long_retry_limit ;
   u32 tx_watchdog_timeout ;
   u8 slow_link_thold ;
   u8 fast_link_thold ;
};

#line 730  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/conf.h"
struct conf_bcn_filt_rule {
   u8 ie ;
   u8 rule ;
   u8 oui[3U] ;
   u8 type ;
   u8 version[2U] ;
};

#line 787  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/conf.h"
struct conf_sig_weights {
   u8 rssi_bcn_avg_weight ;
   u8 rssi_pkt_avg_weight ;
   u8 snr_bcn_avg_weight ;
   u8 snr_pkt_avg_weight ;
};

#line 830  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/conf.h"
struct conf_conn_settings {
   u8 wake_up_event ;
   u8 listen_interval ;
   u8 suspend_wake_up_event ;
   u8 suspend_listen_interval ;
   u8 bcn_filt_mode ;
   u8 bcn_filt_ie_count ;
   struct conf_bcn_filt_rule bcn_filt_ie[32U] ;
   u32 synch_fail_thold ;
   u32 bss_lose_timeout ;
   u32 beacon_rx_timeout ;
   u32 broadcast_timeout ;
   u8 rx_broadcast_in_ps ;
   u8 ps_poll_threshold ;
   struct conf_sig_weights sig_weights ;
   u8 bet_enable ;
   u8 bet_max_consecutive ;
   u8 psm_entry_retries ;
   u8 psm_exit_retries ;
   u8 psm_entry_nullfunc_retries ;
   u16 dynamic_ps_timeout ;
   u8 forced_ps ;
   u32 keep_alive_interval ;
   u8 max_listen_interval ;
   u8 sta_sleep_auth ;
   u8 suspend_rx_ba_activity ;
};

#line 1020  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/conf.h"
struct conf_itrim_settings {
   u8 enable ;
   u32 timeout ;
};

#line 1039  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/conf.h"
struct conf_pm_config_settings {
   u32 host_clk_settling_time ;
   u8 host_fast_wakeup_support ;
};

#line 1055  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/conf.h"
struct conf_roam_trigger_settings {
   u16 trigger_pacing ;
   u8 avg_weight_rssi_beacon ;
   u8 avg_weight_rssi_data ;
   u8 avg_weight_snr_beacon ;
   u8 avg_weight_snr_data ;
};

#line 1092  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/conf.h"
struct conf_scan_settings {
   u32 min_dwell_time_active ;
   u32 max_dwell_time_active ;
   u32 min_dwell_time_active_long ;
   u32 max_dwell_time_active_long ;
   u32 dwell_time_passive ;
   u32 dwell_time_dfs ;
   u16 num_probe_reqs ;
   u32 split_scan_timeout ;
};

#line 1152  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/conf.h"
struct conf_sched_scan_settings {
   u32 base_dwell_time ;
   u32 max_dwell_time_delta ;
   u32 dwell_time_delta_per_probe ;
   u32 dwell_time_delta_per_probe_5 ;
   u32 dwell_time_passive ;
   u32 dwell_time_dfs ;
   u8 num_probe_reqs ;
   s8 rssi_threshold ;
   s8 snr_threshold ;
};

#line 1190  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/conf.h"
struct conf_ht_setting {
   u8 rx_ba_win_size ;
   u8 tx_ba_win_size ;
   u16 inactivity_timeout ;
   u8 tx_ba_tid_bitmap ;
};

#line 1199  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/conf.h"
struct conf_memory_settings {
   u8 num_stations ;
   u8 ssid_profiles ;
   u8 rx_block_num ;
   u8 tx_min_block_num ;
   u8 dynamic_memory ;
   u8 min_req_tx_blocks ;
   u8 min_req_rx_blocks ;
   u8 tx_min ;
};

#line 1239  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/conf.h"
struct conf_fm_coex {
   u8 enable ;
   u8 swallow_period ;
   u8 n_divider_fref_set_1 ;
   u8 n_divider_fref_set_2 ;
   u16 m_divider_fref_set_1 ;
   u16 m_divider_fref_set_2 ;
   u32 coex_pll_stabilization_time ;
   u16 ldo_stabilization_time ;
   u8 fm_disturbed_band_margin ;
   u8 swallow_clk_diff ;
};

#line 1252  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/conf.h"
struct conf_rx_streaming_settings {
   u32 duration ;
   u8 queues ;
   u8 interval ;
   u8 always ;
};

#line 1281  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/conf.h"
struct conf_fwlog {
   u8 mode ;
   u8 mem_blocks ;
   u8 severity ;
   u8 timestamp ;
   u8 output ;
   u8 threshold ;
};

#line 1308  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/conf.h"
struct conf_rate_policy_settings {
   u16 rate_retry_score ;
   u16 per_add ;
   u16 per_th1 ;
   u16 per_th2 ;
   u16 max_per ;
   u8 inverse_curiosity_factor ;
   u8 tx_fail_low_th ;
   u8 tx_fail_high_th ;
   u8 per_alpha_shift ;
   u8 per_add_shift ;
   u8 per_beta1_shift ;
   u8 per_beta2_shift ;
   u8 rate_check_up ;
   u8 rate_check_down ;
   u8 rate_retry_policy[13U] ;
};

#line 1327  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/conf.h"
struct conf_hangover_settings {
   u32 recover_time ;
   u8 hangover_period ;
   u8 dynamic_mode ;
   u8 early_termination_mode ;
   u8 max_period ;
   u8 min_period ;
   u8 increase_delta ;
   u8 decrease_delta ;
   u8 quiet_time ;
   u8 increase_time ;
   u8 window_size ;
};

#line 1341  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/conf.h"
struct conf_recovery_settings {
   u8 bug_on_recovery ;
   u8 no_recovery ;
};

#line 1365  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/conf.h"
struct wlcore_conf {
   struct conf_sg_settings sg ;
   struct conf_rx_settings rx ;
   struct conf_tx_settings tx ;
   struct conf_conn_settings conn ;
   struct conf_itrim_settings itrim ;
   struct conf_pm_config_settings pm_config ;
   struct conf_roam_trigger_settings roam_trigger ;
   struct conf_scan_settings scan ;
   struct conf_sched_scan_settings sched_scan ;
   struct conf_ht_setting ht ;
   struct conf_memory_settings mem ;
   struct conf_fm_coex fm_coex ;
   struct conf_rx_streaming_settings rx_streaming ;
   struct conf_fwlog fwlog ;
   struct conf_rate_policy_settings rate ;
   struct conf_hangover_settings hangover ;
   struct conf_recovery_settings recovery ;
};

#line 232  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/ini.h"
enum wlcore_state {
    WLCORE_STATE_OFF = 0,
    WLCORE_STATE_RESTARTING = 1,
    WLCORE_STATE_ON = 2
};

#line 238 
enum wl12xx_fw_type {
    WL12XX_FW_TYPE_NONE = 0,
    WL12XX_FW_TYPE_NORMAL = 1,
    WL12XX_FW_TYPE_MULTI = 2,
    WL12XX_FW_TYPE_PLT = 3
};

#line 245 
struct wl1271;

#line 255  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/ini.h"
struct wl1271_chip {
   u32 id ;
   char fw_ver_str[32U] ;
   unsigned int fw_ver[5U] ;
   char phy_fw_ver_str[32U] ;
};

#line 126  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/wlcore_i.h"
struct __anonstruct_counters_373 {
   u8 *tx_released_pkts ;
   u8 *tx_lnk_free_pkts ;
   u8 tx_voice_released_blks ;
   u8 tx_last_rate ;
};

#line 126  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/wlcore_i.h"
struct wl_fw_status {
   u32 intr ;
   u8 fw_rx_counter ;
   u8 drv_rx_counter ;
   u8 tx_results_counter ;
   __le32 *rx_pkt_descs ;
   u32 fw_localtime ;
   u32 link_ps_bitmap ;
   u32 link_fast_bitmap ;
   u32 total_released_blks ;
   u32 tx_total ;
   struct __anonstruct_counters_373 counters ;
   u32 log_start_addr ;
   void *priv ;
};

#line 181  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/wlcore_i.h"
struct wl1271_scan {
   struct cfg80211_scan_request *req ;
   unsigned long scanned_ch[1U] ;
   bool failed ;
   u8 state ;
   u8 ssid[33U] ;
   size_t ssid_len ;
};

#line 191  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/wlcore_i.h"
struct wl1271_if_operations {
   int (*read)(struct device *, int , void *, size_t , bool ) ;
   int (*write)(struct device *, int , void *, size_t , bool ) ;
   void (*reset)(struct device *) ;
   void (*init)(struct device *) ;
   int (*power)(struct device *, bool ) ;
   void (*set_block_size)(struct device *, unsigned int ) ;
};

#line 211  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/wlcore_i.h"
struct wl1271_ap_key {
   u8 id ;
   u8 key_type ;
   u8 key_size ;
   u8 key[32U] ;
   u8 hlid ;
   u32 tx_seq_32 ;
   u16 tx_seq_16 ;
};

#line 260 
struct wl12xx_vif;

#line 261  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/wlcore_i.h"
struct wl1271_link {
   struct sk_buff_head tx_queue[4U] ;
   u8 allocated_pkts ;
   u8 prev_freed_pkts ;
   u8 addr[6U] ;
   u8 ba_bitmap ;
   struct wl12xx_vif *wlvif ;
   u64 total_freed_pkts ;
};

#line 292 
enum plt_mode {
    PLT_OFF = 0,
    PLT_ON = 1,
    PLT_FEM_DETECT = 2,
    PLT_CHIP_AWAKE = 3
};

#line 339  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/wlcore_i.h"
struct __anonstruct_sta_375 {
   u8 hlid ;
   u8 basic_rate_idx ;
   u8 ap_rate_idx ;
   u8 p2p_rate_idx ;
   u8 klv_template_id ;
   bool qos ;
   enum nl80211_channel_type role_chan_type ;
};

#line 339  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/wlcore_i.h"
struct __anonstruct_ap_376 {
   u8 global_hlid ;
   u8 bcast_hlid ;
   unsigned long sta_hlid_map[1U] ;
   struct wl1271_ap_key *recorded_keys[14U] ;
   u8 mgmt_rate_idx ;
   u8 bcast_rate_idx ;
   u8 ucast_rate_idx[4U] ;
};

#line 339  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/wlcore_i.h"
union __anonunion_374 {
   struct __anonstruct_sta_375 sta ;
   struct __anonstruct_ap_376 ap ;
};

#line 339  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/wlcore_i.h"
struct __anonstruct_377 {
   u8 persistent[0U] ;
};

#line 339  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/wlcore_i.h"
struct wl12xx_vif {
   struct wl1271 *wl ;
   struct list_head list ;
   unsigned long flags ;
   u8 bss_type ;
   u8 p2p ;
   u8 role_id ;
   u8 dev_role_id ;
   u8 dev_hlid ;
   union __anonunion_374 __anonCompField_wl12xx_vif_100 ;
   int last_tx_hlid ;
   int tx_queue_count[4U] ;
   unsigned long links_map[1U] ;
   u8 ssid[33U] ;
   u8 ssid_len ;
   enum ieee80211_band band ;
   int channel ;
   enum nl80211_channel_type channel_type ;
   u32 bitrate_masks[2U] ;
   u32 basic_rate_set ;
   u32 basic_rate ;
   u32 rate_set ;
   struct sk_buff *probereq ;
   u32 beacon_int ;
   u32 default_key ;
   u16 aid ;
   u8 psm_entry_retry ;
   int power_level ;
   int rssi_thold ;
   int last_rssi_event ;
   u8 encryption_type ;
   __be32 ip_addr ;
   bool ba_support ;
   bool ba_allowed ;
   bool wmm_enabled ;
   bool radar_enabled ;
   struct work_struct rx_streaming_enable_work ;
   struct work_struct rx_streaming_disable_work ;
   struct timer_list rx_streaming_timer ;
   struct delayed_work channel_switch_work ;
   struct delayed_work connection_loss_work ;
   int inconn_count ;
   int hw_queue_base ;
   bool ap_pending_auth_reply ;
   unsigned long pending_auth_reply_time ;
   struct delayed_work pending_auth_complete_work ;
   enum ieee80211_sta_rx_bandwidth rc_update_bw ;
   struct work_struct rc_update_work ;
   u64 total_freed_pkts ;
   struct __anonstruct_377 __anonCompField_wl12xx_vif_101 ;
};

#line 546 
enum wlcore_wait_event {
    WLCORE_EVENT_ROLE_STOP_COMPLETE = 0,
    WLCORE_EVENT_PEER_REMOVE_COMPLETE = 1,
    WLCORE_EVENT_DFS_CONFIG_COMPLETE = 2
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/boot.h"
struct wl1271_static_data {
   u8 mac_address[6U] ;
   u8 padding[2U] ;
   u8 fw_version[20U] ;
   u32 hw_version ;
   u8 tx_power_table[8U][4U] ;
   u8 priv[0U] ;
};

#line 48  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/boot.h"
struct wlcore_ops {
   int (*setup)(struct wl1271 *) ;
   int (*identify_chip)(struct wl1271 *) ;
   int (*identify_fw)(struct wl1271 *) ;
   int (*boot)(struct wl1271 *) ;
   int (*plt_init)(struct wl1271 *) ;
   int (*trigger_cmd)(struct wl1271 *, int , void *, size_t ) ;
   int (*ack_event)(struct wl1271 *) ;
   int (*wait_for_event)(struct wl1271 *, enum wlcore_wait_event , bool *) ;
   int (*process_mailbox_events)(struct wl1271 *) ;
   u32 (*calc_tx_blocks)(struct wl1271 *, u32 , u32 ) ;
   void (*set_tx_desc_blocks)(struct wl1271 *, struct wl1271_tx_hw_descr *, u32 , u32 ) ;
   void (*set_tx_desc_data_len)(struct wl1271 *, struct wl1271_tx_hw_descr *, struct sk_buff *) ;
   int (*get_rx_buf_align)(struct wl1271 *, u32 ) ;
   int (*prepare_read)(struct wl1271 *, u32 , u32 ) ;
   u32 (*get_rx_packet_len)(struct wl1271 *, void *, u32 ) ;
   int (*tx_delayed_compl)(struct wl1271 *) ;
   void (*tx_immediate_compl)(struct wl1271 *) ;
   int (*hw_init)(struct wl1271 *) ;
   int (*init_vif)(struct wl1271 *, struct wl12xx_vif *) ;
   void (*convert_fw_status)(struct wl1271 *, void *, struct wl_fw_status *) ;
   u32 (*sta_get_ap_rate_mask)(struct wl1271 *, struct wl12xx_vif *) ;
   int (*get_pg_ver)(struct wl1271 *, s8 *) ;
   int (*get_mac)(struct wl1271 *) ;
   void (*set_tx_desc_csum)(struct wl1271 *, struct wl1271_tx_hw_descr *, struct sk_buff *) ;
   void (*set_rx_csum)(struct wl1271 *, struct wl1271_rx_descriptor *, struct sk_buff *) ;
   u32 (*ap_get_mimo_wide_rate_mask)(struct wl1271 *, struct wl12xx_vif *) ;
   int (*debugfs_init)(struct wl1271 *, struct dentry *) ;
   int (*handle_static_data)(struct wl1271 *, struct wl1271_static_data *) ;
   int (*scan_start)(struct wl1271 *, struct wl12xx_vif *, struct cfg80211_scan_request *) ;
   int (*scan_stop)(struct wl1271 *, struct wl12xx_vif *) ;
   int (*sched_scan_start)(struct wl1271 *, struct wl12xx_vif *, struct cfg80211_sched_scan_request *, struct ieee80211_scan_ies *) ;
   void (*sched_scan_stop)(struct wl1271 *, struct wl12xx_vif *) ;
   int (*get_spare_blocks)(struct wl1271 *, bool ) ;
   int (*set_key)(struct wl1271 *, enum set_key_cmd , struct ieee80211_vif *, struct ieee80211_sta *, struct ieee80211_key_conf *) ;
   int (*channel_switch)(struct wl1271 *, struct wl12xx_vif *, struct ieee80211_channel_switch *) ;
   u32 (*pre_pkt_send)(struct wl1271 *, u32 , u32 ) ;
   void (*sta_rc_update)(struct wl1271 *, struct wl12xx_vif *) ;
   int (*set_peer_cap)(struct wl1271 *, struct ieee80211_sta_ht_cap *, bool , u32 , u8 ) ;
   u32 (*convert_hwaddr)(struct wl1271 *, u32 ) ;
   bool (*lnk_high_prio)(struct wl1271 *, u8 , struct wl1271_link *) ;
   bool (*lnk_low_prio)(struct wl1271 *, u8 , struct wl1271_link *) ;
   int (*interrupt_notify)(struct wl1271 *, bool ) ;
   int (*rx_ba_filter)(struct wl1271 *, bool ) ;
   int (*ap_sleep)(struct wl1271 *) ;
   int (*smart_config_start)(struct wl1271 *, u32 ) ;
   int (*smart_config_stop)(struct wl1271 *) ;
   int (*smart_config_set_group_key)(struct wl1271 *, u16 , u8 , u8 *) ;
   int (*set_cac)(struct wl1271 *, struct wl12xx_vif *, bool ) ;
   int (*dfs_master_restart)(struct wl1271 *, struct wl12xx_vif *) ;
};

#line 140  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/wlcore.h"
struct wlcore_partition {
   u32 size ;
   u32 start ;
};

#line 146  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/wlcore.h"
struct wlcore_partition_set {
   struct wlcore_partition mem ;
   struct wlcore_partition reg ;
   struct wlcore_partition mem2 ;
   struct wlcore_partition mem3 ;
};

#line 170  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/wlcore.h"
struct wl1271_stats {
   void *fw_stats ;
   unsigned long fw_stats_update ;
   size_t fw_stats_len ;
   unsigned int retry_count ;
   unsigned int excessive_retries ;
};

#line 185 
struct wl1271_acx_mem_map;

#line 185  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/wlcore.h"
struct wl1271 {
   bool initialized ;
   struct ieee80211_hw *hw ;
   bool mac80211_registered ;
   struct device *dev ;
   struct platform_device *pdev ;
   void *if_priv ;
   struct wl1271_if_operations *if_ops ;
   int irq ;
   int irq_flags ;
   spinlock_t wl_lock ;
   enum wlcore_state state ;
   enum wl12xx_fw_type fw_type ;
   bool plt ;
   enum plt_mode plt_mode ;
   u8 fem_manuf ;
   u8 last_vif_count ;
   struct mutex mutex ;
   unsigned long flags ;
   struct wlcore_partition_set curr_part ;
   struct wl1271_chip chip ;
   int cmd_box_addr ;
   u8 *fw ;
   size_t fw_len ;
   void *nvs ;
   size_t nvs_len ;
   s8 hw_pg_ver ;
   u32 fuse_oui_addr ;
   u32 fuse_nic_addr ;
   struct mac_address addresses[3U] ;
   int channel ;
   u8 system_hlid ;
   unsigned long links_map[1U] ;
   unsigned long roles_map[1U] ;
   unsigned long roc_map[1U] ;
   unsigned long rate_policies_map[1U] ;
   unsigned long klv_templates_map[1U] ;
   u8 session_ids[16U] ;
   struct list_head wlvif_list ;
   u8 sta_count ;
   u8 ap_count ;
   struct wl1271_acx_mem_map *target_mem_map ;
   u32 tx_blocks_freed ;
   u32 tx_blocks_available ;
   u32 tx_allocated_blocks ;
   u32 tx_results_count ;
   u32 tx_pkts_freed[4U] ;
   u32 tx_allocated_pkts[4U] ;
   u32 tx_packets_count ;
   s64 time_offset ;
   int tx_queue_count[4U] ;
   unsigned long queue_stop_reasons[12U] ;
   struct sk_buff_head deferred_rx_queue ;
   struct sk_buff_head deferred_tx_queue ;
   struct work_struct tx_work ;
   struct workqueue_struct *freezable_wq ;
   unsigned long tx_frames_map[1U] ;
   struct sk_buff *tx_frames[32U] ;
   int tx_frames_cnt ;
   u32 rx_counter ;
   u8 *aggr_buf ;
   u32 aggr_buf_size ;
   struct sk_buff *dummy_packet ;
   struct work_struct netstack_work ;
   u8 *fwlog ;
   ssize_t fwlog_size ;
   u32 fwlog_end ;
   u32 fw_mem_block_size ;
   wait_queue_head_t fwlog_waitq ;
   struct work_struct recovery_work ;
   bool watchdog_recovery ;
   u32 reg_ch_conf_last[2U] ;
   u32 reg_ch_conf_pending[2U] ;
   void *mbox ;
   u32 event_mask ;
   u32 ap_event_mask ;
   u32 mbox_size ;
   u32 mbox_ptr[2U] ;
   struct wl12xx_vif *scan_wlvif ;
   struct wl1271_scan scan ;
   struct delayed_work scan_complete_work ;
   struct ieee80211_vif *roc_vif ;
   struct delayed_work roc_complete_work ;
   struct wl12xx_vif *sched_vif ;
   enum ieee80211_band band ;
   struct completion *elp_compl ;
   struct delayed_work elp_work ;
   int power_level ;
   struct wl1271_stats stats ;
   __le32 *buffer_32 ;
   u32 buffer_cmd ;
   u32 buffer_busyword[1U] ;
   void *raw_fw_status ;
   struct wl_fw_status *fw_status ;
   struct wl1271_tx_hw_res_if *tx_res_if ;
   struct wlcore_conf conf ;
   bool sg_enabled ;
   bool enable_11a ;
   int recovery_count ;
   s8 noise ;
   struct ieee80211_supported_band bands[2U] ;
   bool wow_enabled ;
   bool irq_wake_enabled ;
   struct wl1271_link links[16U] ;
   int active_link_count ;
   unsigned long fw_fast_lnk_map ;
   unsigned long ap_fw_ps_map ;
   unsigned long ap_ps_map ;
   unsigned int quirks ;
   int ba_rx_session_count ;
   int ba_rx_session_count_max ;
   int active_sta_count ;
   bool ofdm_only_ap ;
   struct wl12xx_vif *last_wlvif ;
   struct delayed_work tx_watchdog_work ;
   struct wlcore_ops *ops ;
   struct wlcore_partition_set const *ptable ;
   int const *rtable ;
   char const *plt_fw_name ;
   char const *sr_fw_name ;
   char const *mr_fw_name ;
   u8 scan_templ_id_2_4 ;
   u8 scan_templ_id_5 ;
   u8 sched_scan_templ_id_2_4 ;
   u8 sched_scan_templ_id_5 ;
   u8 max_channels_5 ;
   void *priv ;
   u32 num_tx_desc ;
   u32 num_rx_desc ;
   u8 num_links ;
   u8 max_ap_stations ;
   u8 const **band_rate_to_idx ;
   u8 hw_tx_rate_tbl_size ;
   u8 hw_min_ht_rate ;
   struct ieee80211_sta_ht_cap ht_cap[2U] ;
   enum nl80211_dfs_regions dfs_region ;
   size_t fw_status_len ;
   size_t fw_status_priv_len ;
   unsigned long rx_filter_enabled[1U] ;
   size_t static_data_priv_len ;
   enum nl80211_channel_type channel_type ;
   struct mutex flush_mutex ;
   int sleep_auth ;
   int num_mac_addr ;
   unsigned int min_sr_fw_ver[5U] ;
   unsigned int min_mr_fw_ver[5U] ;
   struct completion nvs_loading_complete ;
   struct ieee80211_iface_combination const *iface_combinations ;
   u8 n_iface_combinations ;
};

#line 547 
struct acx_header;

#line 195  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/cmd.h"
struct wl1271_cmd_header {
   __le16 id ;
   __le16 status ;
   u8 data[0U] ;
};

#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/debug.h"
struct acx_header {
   struct wl1271_cmd_header cmd ;
   __le16 id ;
   __le16 len ;
};

#line 486  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/acx.h"
struct wl1271_acx_mem_map {
   struct acx_header header ;
   __le32 code_start ;
   __le32 code_end ;
   __le32 wep_defkey_start ;
   __le32 wep_defkey_end ;
   __le32 sta_table_start ;
   __le32 sta_table_end ;
   __le32 packet_template_start ;
   __le32 packet_template_end ;
   __le32 tx_result ;
   __le32 tx_result_queue_start ;
   __le32 queue_memory_start ;
   __le32 queue_memory_end ;
   __le32 packet_memory_pool_start ;
   __le32 packet_memory_pool_end ;
   __le32 debug_buffer1_start ;
   __le32 debug_buffer1_end ;
   __le32 debug_buffer2_start ;
   __le32 debug_buffer2_end ;
   __le32 num_tx_mem_blocks ;
   __le32 num_rx_mem_blocks ;
   u8 *tx_cbuf ;
   u8 *rx_cbuf ;
   __le32 rx_ctrl ;
   __le32 tx_ctrl ;
};

#line 1134  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/acx.h"
struct wl1271_acx_host_config_bitmap {
   struct acx_header header ;
   __le32 host_cfg_bitmap ;
};

#line 234  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/printk.h"
struct _ddebug {
   char const *modname ;
   char const *function ;
   char const *filename ;
   char const *format ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))) lineno : 18 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) flags : 8 ;
};

#line 574  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/wlcore.h"
struct wl12xx_event_mailbox {
   __le32 events_vector ;
   __le32 events_mask ;
   __le32 reserved_1 ;
   __le32 reserved_2 ;
   u8 number_of_scan_results ;
   u8 scan_tag ;
   u8 completed_scan_status ;
   u8 reserved_3 ;
   u8 soft_gemini_sense_info ;
   u8 soft_gemini_protective_info ;
   s8 rssi_snr_trigger_metric[8U] ;
   u8 change_auto_mode_timeout ;
   u8 scheduled_scan_status ;
   u8 reserved4 ;
   u8 roc_channel ;
   __le16 hlid_removed_bitmap ;
   __le16 sta_aging_status ;
   __le16 sta_tx_retry_exceeded ;
   u8 discovery_tag ;
   u8 number_of_preq_results ;
   u8 number_of_prsp_results ;
   u8 reserved_5 ;
   u8 role_id ;
   u8 rx_ba_allowed ;
   u8 reserved_6[2U] ;
   u8 channel_switch_role_id ;
   u8 channel_switch_status ;
   u8 reserved_7[2U] ;
   u8 ps_poll_delivery_failure_role_ids ;
   u8 stopped_role_ids ;
   u8 started_role_ids ;
   u8 reserved_8[9U] ;
};

#line 14  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
struct kernel_symbol {
   unsigned long value ;
   char const *name ;
};

#line 131  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/init.h"
typedef void (*ctor_fn_t)(void);

#line 555  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/percpu.h"
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};

#line 59  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jump_label.h"
struct jump_entry;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/jump_label.h"
typedef u64 jump_label_t;

#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/jump_label.h"
struct jump_entry {
   jump_label_t code ;
   jump_label_t target ;
   jump_label_t key ;
};

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/elf.h"
typedef __u64 Elf64_Addr;

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/elf.h"
typedef __u16 Elf64_Half;

#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/elf.h"
typedef __u32 Elf64_Word;

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/elf.h"
typedef __u64 Elf64_Xword;

#line 190  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};

#line 198  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/elf.h"
typedef struct elf64_sym Elf64_Sym;

#line 223  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kernel_param;

#line 228  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kernel_param_ops {
   unsigned int flags ;
   int (*set)(char const *, struct kernel_param const *) ;
   int (*get)(char *, struct kernel_param const *) ;
   void (*free)(void *) ;
};

#line 62  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/moduleparam.h"
struct kparam_string;

#line 62 
struct kparam_array;

#line 62  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/moduleparam.h"
union __anonunion_936 {
   void *arg ;
   struct kparam_string const *str ;
   struct kparam_array const *arr ;
};

#line 62  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/moduleparam.h"
struct kernel_param {
   char const *name ;
   struct module *mod ;
   struct kernel_param_ops const *ops ;
   u16 const perm ;
   s8 level ;
   u8 flags ;
   union __anonunion_936 __anonCompField_kernel_param_49 ;
};

#line 83  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};

#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops const *ops ;
   void *elem ;
};

#line 469  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/moduleparam.h"
struct latch_tree_node {
   struct rb_node node[2U] ;
};

#line 211  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rbtree_latch.h"
struct mod_arch_specific {
   
};

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/module.h"
struct module_param_attrs;

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
   struct completion *kobj_completion ;
};

#line 48  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute *, struct module_kobject *, char *) ;
   ssize_t (*store)(struct module_attribute *, struct module_kobject *, char const *, size_t ) ;
   void (*setup)(struct module *, char const *) ;
   int (*test)(struct module *) ;
   void (*free)(struct module *) ;
};

#line 74 
struct exception_table_entry;

#line 290 
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2,
    MODULE_STATE_UNFORMED = 3
};

#line 297  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/module.h"
struct mod_tree_node {
   struct module *mod ;
   struct latch_tree_node node ;
};

#line 304 
struct module_sect_attrs;

#line 304 
struct module_notes_attrs;

#line 304 
struct tracepoint;

#line 304 
struct trace_event_call;

#line 304 
struct trace_enum_map;

#line 304  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const *version ;
   char const *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol const *syms ;
   unsigned long const *crcs ;
   unsigned int num_syms ;
   struct mutex param_lock ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol const *gpl_syms ;
   unsigned long const *gpl_crcs ;
   struct kernel_symbol const *unused_syms ;
   unsigned long const *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol const *unused_gpl_syms ;
   unsigned long const *unused_gpl_crcs ;
   bool sig_ok ;
   bool async_probe_requested ;
   struct kernel_symbol const *gpl_future_syms ;
   unsigned long const *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   struct mod_tree_node mtn_core ;
   struct mod_tree_node mtn_init ;
   unsigned int init_ro_size ;
   unsigned int core_ro_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
   unsigned int core_num_syms ;
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   struct tracepoint * const *tracepoints_ptrs ;
   struct jump_entry *jump_entries ;
   unsigned int num_jump_entries ;
   unsigned int num_trace_bprintk_fmt ;
   char const **trace_bprintk_fmt_start ;
   struct trace_event_call **trace_events ;
   unsigned int num_trace_events ;
   struct trace_enum_map **trace_enums ;
   unsigned int num_trace_enums ;
   unsigned int num_ftrace_callsites ;
   unsigned long *ftrace_callsites ;
   bool klp_alive ;
   struct list_head source_list ;
   struct list_head target_list ;
   void (*exit)(void) ;
   atomic_t refcnt ;
   ctor_fn_t (**ctors)(void) ;
   unsigned int num_ctors ;
};

#line 173  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/platform_device.h"
struct platform_driver {
   int (*probe)(struct platform_device *) ;
   int (*remove)(struct platform_device *) ;
   void (*shutdown)(struct platform_device *) ;
   int (*suspend)(struct platform_device *, pm_message_t ) ;
   int (*resume)(struct platform_device *) ;
   struct device_driver driver ;
   struct platform_device_id const *id_table ;
   bool prevent_deferred_probe ;
};

#line 62  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uaccess.h"
struct exception_table_entry {
   int insn ;
   int fixup ;
};

#line 202  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/wlcore_i.h"
struct wlcore_platdev_data {
   struct wl1271_if_operations *if_ops ;
   bool ref_clock_xtal ;
   u32 ref_clock_freq ;
   u32 tcxo_clock_freq ;
   bool pwr_in_suspend ;
};

#line 1134  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/acx.h"
struct wl127x_tx_mem {
   u8 extra_blocks ;
   u8 total_mem_blocks ;
};

#line 77  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/tx.h"
struct wl128x_tx_mem {
   u8 total_mem_blocks ;
   u8 extra_bytes ;
};

#line 91  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/tx.h"
struct wl18xx_tx_mem {
   u8 total_mem_blocks ;
   u8 ctrl ;
};

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/tx.h"
union __anonunion_1158 {
   struct wl127x_tx_mem wl127x_mem ;
   struct wl128x_tx_mem wl128x_mem ;
   struct wl18xx_tx_mem wl18xx_mem ;
};

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/tx.h"
union __anonunion_1159 {
   u8 wl12xx_reserved ;
   u8 wl18xx_checksum_data ;
};

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/tx.h"
struct wl1271_tx_hw_descr {
   __le16 length ;
   union __anonunion_1158 __anonCompField_wl1271_tx_hw_descr_104 ;
   __le32 start_time ;
   __le16 life_time ;
   __le16 tx_attr ;
   u8 id ;
   u8 tid ;
   u8 hlid ;
   union __anonunion_1159 __anonCompField_wl1271_tx_hw_descr_105 ;
};

#line 160  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/tx.h"
struct wl1271_tx_hw_res_descr {
   u8 id ;
   u8 status ;
   __le16 medium_usage ;
   __le32 fw_handling_time ;
   __le32 medium_delay ;
   u8 tx_security_sequence_number_lsb ;
   u8 ack_failures ;
   u8 rate_class_index ;
   u8 spare ;
};

#line 184  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/tx.h"
struct wl1271_tx_hw_res_if {
   __le32 tx_result_fw_counter ;
   __le32 tx_result_host_counter ;
   struct wl1271_tx_hw_res_descr tx_results_queue[16U] ;
};

#line 304  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/tx.h"
struct wl1271_rx_descriptor {
   __le16 length ;
   u8 status ;
   u8 flags ;
   u8 rate ;
   u8 channel ;
   s8 rssi ;
   u8 snr ;
   __le32 timestamp ;
   u8 packet_class ;
   u8 hlid ;
   u8 pad_len ;
   u8 reserved ;
};

#line 151  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/rx.h"
struct wl12xx_conf_rf {
   u8 tx_per_channel_power_compensation_2[7U] ;
   u8 tx_per_channel_power_compensation_5[18U] ;
};

#line 44  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/conf.h"
struct wl12xx_priv_conf {
   struct wl12xx_conf_rf rf ;
   struct conf_memory_settings mem_wl127x ;
};

#line 49  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/conf.h"
struct wl127x_rx_mem_pool_addr {
   u32 addr ;
   u32 addr_extra ;
};

#line 75  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/wl12xx.h"
struct wl12xx_priv {
   struct wl12xx_priv_conf conf ;
   int ref_clock ;
   int tcxo_clock ;
   struct wl127x_rx_mem_pool_addr *rx_mem_addr ;
};

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/wl12xx.h"
struct wl12xx_clock {
   u32 freq ;
   bool xtal ;
   u8 hw_idx ;
};

#line 112  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/wl12xx.h"
struct wl12xx_fw_packet_counters {
   u8 tx_released_pkts[4U] ;
   u8 tx_lnk_free_pkts[12U] ;
   u8 tx_voice_released_blks ;
   u8 tx_last_rate ;
   u8 padding[2U] ;
};

#line 128  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/wl12xx.h"
struct wl12xx_fw_status {
   __le32 intr ;
   u8 fw_rx_counter ;
   u8 drv_rx_counter ;
   u8 reserved ;
   u8 tx_results_counter ;
   __le32 rx_pkt_descs[8U] ;
   __le32 fw_localtime ;
   __le32 link_ps_bitmap ;
   __le32 link_fast_bitmap ;
   __le32 total_released_blks ;
   __le32 tx_total ;
   struct wl12xx_fw_packet_counters counters ;
   __le32 log_start_addr ;
};

#line 1391  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/conf.h"
struct wl1271_ini_general_params {
   u8 ref_clock ;
   u8 settling_time ;
   u8 clk_valid_on_wakeup ;
   u8 dc2dc_mode ;
   u8 dual_mode_select ;
   u8 tx_bip_fem_auto_detect ;
   u8 tx_bip_fem_manufacturer ;
   u8 general_settings ;
   u8 sr_state ;
   u8 srf1[16U] ;
   u8 srf2[16U] ;
   u8 srf3[16U] ;
};

#line 46  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/ini.h"
struct wl128x_ini_general_params {
   u8 ref_clock ;
   u8 settling_time ;
   u8 clk_valid_on_wakeup ;
   u8 tcxo_ref_clock ;
   u8 tcxo_settling_time ;
   u8 tcxo_valid_on_wakeup ;
   u8 tcxo_ldo_voltage ;
   u8 xtal_itrim_val ;
   u8 platform_conf ;
   u8 dual_mode_select ;
   u8 tx_bip_fem_auto_detect ;
   u8 tx_bip_fem_manufacturer ;
   u8 general_settings[4U] ;
   u8 sr_state ;
   u8 srf1[16U] ;
   u8 srf2[16U] ;
   u8 srf3[16U] ;
};

#line 68  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/ini.h"
struct wl1271_ini_band_params_2 {
   u8 rx_trace_insertion_loss ;
   u8 tx_trace_loss ;
   u8 rx_rssi_process_compens[15U] ;
};

#line 76  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/ini.h"
struct wl128x_ini_band_params_2 {
   u8 rx_trace_insertion_loss ;
   u8 tx_trace_loss[14U] ;
   u8 rx_rssi_process_compens[15U] ;
};

#line 84  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/ini.h"
struct wl1271_ini_fem_params_2 {
   __le16 tx_bip_ref_pd_voltage ;
   u8 tx_bip_ref_power ;
   u8 tx_bip_ref_offset ;
   u8 tx_per_rate_pwr_limits_normal[6U] ;
   u8 tx_per_rate_pwr_limits_degraded[6U] ;
   u8 tx_per_rate_pwr_limits_extreme[6U] ;
   u8 tx_per_chan_pwr_limits_11b[14U] ;
   u8 tx_per_chan_pwr_limits_ofdm[14U] ;
   u8 tx_pd_vs_rate_offsets[6U] ;
   u8 tx_ibias[6U] ;
   u8 rx_fem_insertion_loss ;
   u8 degraded_low_to_normal_thr ;
   u8 normal_to_degraded_high_thr ;
};

#line 102  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/ini.h"
struct wl128x_ini_fem_params_2 {
   __le16 tx_bip_ref_pd_voltage ;
   u8 tx_bip_ref_power ;
   u8 tx_bip_ref_offset ;
   u8 tx_per_rate_pwr_limits_normal[7U] ;
   u8 tx_per_rate_pwr_limits_degraded[7U] ;
   u8 tx_per_rate_pwr_limits_extreme[7U] ;
   u8 tx_per_chan_pwr_limits_11b[14U] ;
   u8 tx_per_chan_pwr_limits_ofdm[14U] ;
   u8 tx_pd_vs_rate_offsets[7U] ;
   u8 tx_ibias[8U] ;
   u8 tx_pd_vs_chan_offsets[14U] ;
   u8 tx_pd_vs_temperature[2U] ;
   u8 rx_fem_insertion_loss ;
   u8 degraded_low_to_normal_thr ;
   u8 normal_to_degraded_high_thr ;
};

#line 124  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/ini.h"
struct wl1271_ini_band_params_5 {
   u8 rx_trace_insertion_loss[7U] ;
   u8 tx_trace_loss[7U] ;
   u8 rx_rssi_process_compens[15U] ;
};

#line 133  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/ini.h"
struct wl128x_ini_band_params_5 {
   u8 rx_trace_insertion_loss[7U] ;
   u8 tx_trace_loss[35U] ;
   u8 rx_rssi_process_compens[15U] ;
};

#line 139  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/ini.h"
struct wl1271_ini_fem_params_5 {
   __le16 tx_bip_ref_pd_voltage[7U] ;
   u8 tx_bip_ref_power[7U] ;
   u8 tx_bip_ref_offset[7U] ;
   u8 tx_per_rate_pwr_limits_normal[6U] ;
   u8 tx_per_rate_pwr_limits_degraded[6U] ;
   u8 tx_per_rate_pwr_limits_extreme[6U] ;
   u8 tx_per_chan_pwr_limits_ofdm[35U] ;
   u8 tx_pd_vs_rate_offsets[6U] ;
   u8 tx_ibias[6U] ;
   u8 rx_fem_insertion_loss[7U] ;
   u8 degraded_low_to_normal_thr ;
   u8 normal_to_degraded_high_thr ;
};

#line 154  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/ini.h"
struct wl128x_ini_fem_params_5 {
   __le16 tx_bip_ref_pd_voltage[7U] ;
   u8 tx_bip_ref_power[7U] ;
   u8 tx_bip_ref_offset[7U] ;
   u8 tx_per_rate_pwr_limits_normal[7U] ;
   u8 tx_per_rate_pwr_limits_degraded[7U] ;
   u8 tx_per_rate_pwr_limits_extreme[7U] ;
   u8 tx_per_chan_pwr_limits_ofdm[35U] ;
   u8 tx_pd_vs_rate_offsets[7U] ;
   u8 tx_ibias[7U] ;
   u8 tx_pd_vs_chan_offsets[35U] ;
   u8 tx_pd_vs_temperature[14U] ;
   u8 rx_fem_insertion_loss[7U] ;
   u8 degraded_low_to_normal_thr ;
   u8 normal_to_degraded_high_thr ;
};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/ini.h"
struct __anonstruct_dyn_radio_params_2_1529 {
   struct wl1271_ini_fem_params_2 params ;
   u8 padding ;
};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/ini.h"
struct __anonstruct_dyn_radio_params_5_1530 {
   struct wl1271_ini_fem_params_5 params ;
   u8 padding ;
};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/ini.h"
struct wl1271_nvs_file {
   u8 nvs[468U] ;
   struct wl1271_ini_general_params general_params ;
   u8 padding1 ;
   struct wl1271_ini_band_params_2 stat_radio_params_2 ;
   u8 padding2 ;
   struct __anonstruct_dyn_radio_params_2_1529 dyn_radio_params_2[2U] ;
   struct wl1271_ini_band_params_5 stat_radio_params_5 ;
   u8 padding3 ;
   struct __anonstruct_dyn_radio_params_5_1530 dyn_radio_params_5[2U] ;
};

#line 211  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/ini.h"
struct __anonstruct_dyn_radio_params_2_1531 {
   struct wl128x_ini_fem_params_2 params ;
   u8 padding ;
};

#line 211  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/ini.h"
struct __anonstruct_dyn_radio_params_5_1532 {
   struct wl128x_ini_fem_params_5 params ;
   u8 padding ;
};

#line 211  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/ini.h"
struct wl128x_nvs_file {
   u8 nvs[468U] ;
   struct wl128x_ini_general_params general_params ;
   u8 fem_vendor_and_options ;
   struct wl128x_ini_band_params_2 stat_radio_params_2 ;
   u8 padding2 ;
   struct __anonstruct_dyn_radio_params_2_1531 dyn_radio_params_2[2U] ;
   struct wl128x_ini_band_params_5 stat_radio_params_5 ;
   u8 padding3 ;
   struct __anonstruct_dyn_radio_params_5_1532 dyn_radio_params_5[2U] ;
};

#line 519  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/cmd.h"
struct wl1271_cmd_test_header {
   u8 id ;
   u8 padding[3U] ;
};

#line 162  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/wl12xx.h"
struct wl1271_general_parms_cmd {
   struct wl1271_cmd_header header ;
   struct wl1271_cmd_test_header test ;
   struct wl1271_ini_general_params general_params ;
   u8 sr_debug_table[16U] ;
   u8 sr_sen_n_p ;
   u8 sr_sen_n_p_gain ;
   u8 sr_sen_nrn ;
   u8 sr_sen_prn ;
   u8 padding[3U] ;
};

#line 45  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/cmd.h"
struct wl128x_general_parms_cmd {
   struct wl1271_cmd_header header ;
   struct wl1271_cmd_test_header test ;
   struct wl128x_ini_general_params general_params ;
   u8 sr_debug_table[16U] ;
   u8 sr_sen_n_p ;
   u8 sr_sen_n_p_gain ;
   u8 sr_sen_nrn ;
   u8 sr_sen_prn ;
   u8 padding[3U] ;
};

#line 60  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/cmd.h"
struct wl1271_radio_parms_cmd {
   struct wl1271_cmd_header header ;
   struct wl1271_cmd_test_header test ;
   struct wl1271_ini_band_params_2 static_params_2 ;
   struct wl1271_ini_band_params_5 static_params_5 ;
   struct wl1271_ini_fem_params_2 dyn_params_2 ;
   u8 padding2 ;
   struct wl1271_ini_fem_params_5 dyn_params_5 ;
   u8 padding3[2U] ;
};

#line 76  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/cmd.h"
struct wl128x_radio_parms_cmd {
   struct wl1271_cmd_header header ;
   struct wl1271_cmd_test_header test ;
   struct wl128x_ini_band_params_2 static_params_2 ;
   struct wl128x_ini_band_params_5 static_params_5 ;
   u8 fem_vendor_and_options ;
   struct wl128x_ini_fem_params_2 dyn_params_2 ;
   u8 padding2 ;
   struct wl128x_ini_fem_params_5 dyn_params_5 ;
};

#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/cmd.h"
struct wl1271_ext_radio_parms_cmd {
   struct wl1271_cmd_header header ;
   struct wl1271_cmd_test_header test ;
   u8 tx_per_channel_power_compensation_2[7U] ;
   u8 tx_per_channel_power_compensation_5[18U] ;
   u8 padding[3U] ;
};

#line 105  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/cmd.h"
struct wl12xx_cmd_channel_switch {
   struct wl1271_cmd_header header ;
   u8 role_id ;
   u8 channel ;
   u8 switch_time ;
   u8 stop_tx ;
   u8 post_switch_tx_disable ;
   u8 padding[3U] ;
};

#line 48  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/acx.h"
struct wl12xx_acx_tx_statistics {
   __le32 internal_desc_overflow ;
};

#line 52  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/acx.h"
struct wl12xx_acx_rx_statistics {
   __le32 out_of_mem ;
   __le32 hdr_overflow ;
   __le32 hw_stuck ;
   __le32 dropped ;
   __le32 fcs_err ;
   __le32 xfr_hint_trig ;
   __le32 path_reset ;
   __le32 reset_counter ;
};

#line 63  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/acx.h"
struct wl12xx_acx_dma_statistics {
   __le32 rx_requested ;
   __le32 rx_errors ;
   __le32 tx_requested ;
   __le32 tx_errors ;
};

#line 70  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/acx.h"
struct wl12xx_acx_isr_statistics {
   __le32 cmd_cmplt ;
   __le32 fiqs ;
   __le32 rx_headers ;
   __le32 rx_completes ;
   __le32 rx_mem_overflow ;
   __le32 rx_rdys ;
   __le32 irqs ;
   __le32 tx_procs ;
   __le32 decrypt_done ;
   __le32 dma0_done ;
   __le32 dma1_done ;
   __le32 tx_exch_complete ;
   __le32 commands ;
   __le32 rx_procs ;
   __le32 hw_pm_mode_changes ;
   __le32 host_acknowledges ;
   __le32 pci_pm ;
   __le32 wakeups ;
   __le32 low_rssi ;
};

#line 129  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/acx.h"
struct wl12xx_acx_wep_statistics {
   __le32 addr_key_count ;
   __le32 default_key_count ;
   __le32 reserved ;
   __le32 key_not_found ;
   __le32 decrypt_fail ;
   __le32 packets ;
   __le32 interrupt ;
};

#line 151  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/acx.h"
struct wl12xx_acx_pwr_statistics {
   __le32 ps_enter ;
   __le32 elp_enter ;
   __le32 missing_bcns ;
   __le32 wake_on_host ;
   __le32 wake_on_timer_exp ;
   __le32 tx_with_ps ;
   __le32 tx_without_ps ;
   __le32 rcvd_beacons ;
   __le32 power_save_off ;
   __le16 enable_ps ;
   __le16 disable_ps ;
   __le32 fix_tsf_ps ;
   __le32 cont_miss_bcns_spread[10U] ;
   __le32 rcvd_awake_beacons ;
};

#line 211  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/acx.h"
struct wl12xx_acx_mic_statistics {
   __le32 rx_pkts ;
   __le32 calc_failure ;
};

#line 216  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/acx.h"
struct wl12xx_acx_aes_statistics {
   __le32 encrypt_fail ;
   __le32 decrypt_fail ;
   __le32 encrypt_packets ;
   __le32 decrypt_packets ;
   __le32 encrypt_interrupt ;
   __le32 decrypt_interrupt ;
};

#line 225  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/acx.h"
struct wl12xx_acx_event_statistics {
   __le32 heart_beat ;
   __le32 calibration ;
   __le32 rx_mismatch ;
   __le32 rx_mem_empty ;
   __le32 rx_pool ;
   __le32 oom_late ;
   __le32 phy_transmit_error ;
   __le32 tx_stuck ;
};

#line 236  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/acx.h"
struct wl12xx_acx_ps_statistics {
   __le32 pspoll_timeouts ;
   __le32 upsd_timeouts ;
   __le32 upsd_max_sptime ;
   __le32 upsd_max_apturn ;
   __le32 pspoll_max_apturn ;
   __le32 pspoll_utilization ;
   __le32 upsd_utilization ;
};

#line 246  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/acx.h"
struct wl12xx_acx_rxpipe_statistics {
   __le32 rx_prep_beacon_drop ;
   __le32 descr_host_int_trig_rx_data ;
   __le32 beacon_buffer_thres_host_int_trig_rx_data ;
   __le32 missed_beacon_host_int_trig_rx_data ;
   __le32 tx_xfr_host_int_trig_rx_data ;
};

#line 254  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/acx.h"
struct wl12xx_acx_statistics {
   struct acx_header header ;
   struct wl12xx_acx_tx_statistics tx ;
   struct wl12xx_acx_rx_statistics rx ;
   struct wl12xx_acx_dma_statistics dma ;
   struct wl12xx_acx_isr_statistics isr ;
   struct wl12xx_acx_wep_statistics wep ;
   struct wl12xx_acx_pwr_statistics pwr ;
   struct wl12xx_acx_aes_statistics aes ;
   struct wl12xx_acx_mic_statistics mic ;
   struct wl12xx_acx_event_statistics event ;
   struct wl12xx_acx_ps_statistics ps ;
   struct wl12xx_acx_rxpipe_statistics rxpipe ;
};

#line 52  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/scan.h"
struct wl1271_cmd_trigger_scan_to {
   struct wl1271_cmd_header header ;
   __le32 timeout ;
};

#line 85  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/scan.h"
struct conn_scan_ch_params {
   __le16 min_duration ;
   __le16 max_duration ;
   __le16 passive_duration ;
   u8 channel ;
   u8 tx_power_att ;
   u8 flags ;
   u8 padding[3U] ;
};

#line 141  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/scan.h"
struct wlcore_scan_channels {
   u8 passive[3U] ;
   u8 active[3U] ;
   u8 dfs ;
   u8 passive_active ;
   struct conn_scan_ch_params channels_2[14U] ;
   struct conn_scan_ch_params channels_5[42U] ;
   struct conn_scan_ch_params channels_4[4U] ;
};

#line 169  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/scan.h"
struct basic_scan_params {
   __le16 scan_options ;
   u8 role_id ;
   u8 n_ch ;
   u8 n_probe_reqs ;
   u8 tid_trigger ;
   u8 ssid_len ;
   u8 use_ssid_list ;
   __le32 tx_rate ;
   u8 ssid[32U] ;
   u8 band ;
   u8 scan_tag ;
   u8 padding2[2U] ;
};

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/scan.h"
struct basic_scan_channel_params {
   __le32 min_duration ;
   __le32 max_duration ;
   __le32 bssid_lsb ;
   __le16 bssid_msb ;
   u8 early_termination ;
   u8 tx_power_att ;
   u8 channel ;
   u8 dfs_candidate ;
   u8 activity_detected ;
   u8 pad ;
};

#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/scan.h"
struct wl1271_cmd_scan {
   struct wl1271_cmd_header header ;
   struct basic_scan_params params ;
   struct basic_scan_channel_params channels[24U] ;
   u8 addr[6U] ;
   u8 padding[2U] ;
};

#line 80  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/scan.h"
struct wl1271_cmd_sched_scan_config {
   struct wl1271_cmd_header header ;
   __le32 intervals[16U] ;
   s8 rssi_threshold ;
   s8 snr_threshold ;
   u8 cycles ;
   u8 report_after ;
   u8 terminate ;
   u8 tag ;
   u8 bss_type ;
   u8 filter_type ;
   u8 ssid_len ;
   u8 ssid[32U] ;
   u8 n_probe_reqs ;
   u8 passive[3U] ;
   u8 active[3U] ;
   u8 dfs ;
   u8 n_pactive_ch ;
   u8 role_id ;
   u8 padding[1U] ;
   struct conn_scan_ch_params channels_2[14U] ;
   struct conn_scan_ch_params channels_5[23U] ;
   struct conn_scan_ch_params channels_4[4U] ;
};

#line 115  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/scan.h"
struct wl1271_cmd_sched_scan_start {
   struct wl1271_cmd_header header ;
   u8 tag ;
   u8 role_id ;
   u8 padding[2U] ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/scan.h"
struct wl1271_cmd_sched_scan_stop {
   struct wl1271_cmd_header header ;
   u8 tag ;
   u8 role_id ;
   u8 padding[2U] ;
};

#line 62  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memory.h"
struct ldv_list_element {
   void *data ;
   struct ldv_list_element *next ;
};

#line 26  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memlist.h"
typedef struct ldv_list_element *ldv_list_ptr;

#line 41  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.h"
struct device_private {
   void *driver_data ;
};

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef short s16;

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kthread.h"
struct kthread_work;

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kthread.h"
struct kthread_worker {
   spinlock_t lock ;
   struct list_head work_list ;
   struct task_struct *task ;
   struct kthread_work *current_work ;
};

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kthread.h"
struct kthread_work {
   struct list_head node ;
   void (*func)(struct kthread_work *) ;
   struct kthread_worker *worker ;
};

#line 380  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/scatterlist.h"
struct dma_chan;

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spi/spi.h"
struct spi_master;

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spi/spi.h"
struct spi_device {
   struct device dev ;
   struct spi_master *master ;
   u32 max_speed_hz ;
   u8 chip_select ;
   u8 bits_per_word ;
   u16 mode ;
   int irq ;
   void *controller_state ;
   void *controller_data ;
   char modalias[32U] ;
   int cs_gpio ;
};

#line 151 
struct spi_message;

#line 152 
struct spi_transfer;

#line 205  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spi/spi.h"
struct spi_master {
   struct device dev ;
   struct list_head list ;
   s16 bus_num ;
   u16 num_chipselect ;
   u16 dma_alignment ;
   u16 mode_bits ;
   u32 bits_per_word_mask ;
   u32 min_speed_hz ;
   u32 max_speed_hz ;
   u16 flags ;
   spinlock_t bus_lock_spinlock ;
   struct mutex bus_lock_mutex ;
   bool bus_lock_flag ;
   int (*setup)(struct spi_device *) ;
   int (*transfer)(struct spi_device *, struct spi_message *) ;
   void (*cleanup)(struct spi_device *) ;
   bool (*can_dma)(struct spi_master *, struct spi_device *, struct spi_transfer *) ;
   bool queued ;
   struct kthread_worker kworker ;
   struct task_struct *kworker_task ;
   struct kthread_work pump_messages ;
   spinlock_t queue_lock ;
   struct list_head queue ;
   struct spi_message *cur_msg ;
   bool idling ;
   bool busy ;
   bool running ;
   bool rt ;
   bool auto_runtime_pm ;
   bool cur_msg_prepared ;
   bool cur_msg_mapped ;
   struct completion xfer_completion ;
   size_t max_dma_len ;
   int (*prepare_transfer_hardware)(struct spi_master *) ;
   int (*transfer_one_message)(struct spi_master *, struct spi_message *) ;
   int (*unprepare_transfer_hardware)(struct spi_master *) ;
   int (*prepare_message)(struct spi_master *, struct spi_message *) ;
   int (*unprepare_message)(struct spi_master *, struct spi_message *) ;
   void (*set_cs)(struct spi_device *, bool ) ;
   int (*transfer_one)(struct spi_master *, struct spi_device *, struct spi_transfer *) ;
   void (*handle_err)(struct spi_master *, struct spi_message *) ;
   int *cs_gpios ;
   struct dma_chan *dma_tx ;
   struct dma_chan *dma_rx ;
   void *dummy_rx ;
   void *dummy_tx ;
};

#line 506  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spi/spi.h"
struct spi_transfer {
   void const *tx_buf ;
   void *rx_buf ;
   unsigned int len ;
   dma_addr_t tx_dma ;
   dma_addr_t rx_dma ;
   struct sg_table tx_sg ;
   struct sg_table rx_sg ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) cs_change : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) tx_nbits : 3 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) rx_nbits : 3 ;
   u8 bits_per_word ;
   u16 delay_usecs ;
   u32 speed_hz ;
   struct list_head transfer_list ;
};

#line 630  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spi/spi.h"
struct spi_message {
   struct list_head transfers ;
   struct spi_device *spi ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_dma_mapped : 1 ;
   void (*complete)(void *) ;
   void *context ;
   unsigned int frame_length ;
   unsigned int actual_length ;
   int status ;
   struct list_head queue ;
   void *state ;
};

#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/thread.h"
typedef unsigned long pthread_t;

#line 22  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/thread.h"
union pthread_attr_t {
   char __size[56U] ;
   long __align ;
};

#line 29  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/thread.h"
typedef union pthread_attr_t pthread_attr_t;

#line 678  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pagemap.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/poll.h"
struct poll_table_struct {
   void (*_qproc)(struct file *, wait_queue_head_t *, struct poll_table_struct *) ;
   unsigned long _key ;
};

#line 338  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/platform_device.h"
struct ldv_struct_character_driver_scenario_5 {
   struct file_operations *arg0 ;
   int signal_pending ;
};

#line 18  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
struct ldv_struct_platform_instance_17 {
   struct platform_driver *arg0 ;
   int signal_pending ;
};

#line 142  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/printk.h"
int printk(char const * , ...);


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/slab.h"
void *ldv_kzalloc(size_t size, gfp_t flags);


#line 143  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/slab.h"
void kfree(void const *);


#line 581 
static void *kzalloc(size_t size, gfp_t flags);


#line 48  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/cmd.h"
int wl1271_cmd_configure(struct wl1271 *, u16, void *, size_t);


#line 271  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/acx.h"
int wl1271_acx_host_if_cfg_bitmap(struct wl1271 *wl, u32 host_cfg_bitmap);


#line 29  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/acx.c"
int wl1271_acx_host_if_cfg_bitmap(struct wl1271 *wl, u32 host_cfg_bitmap)
{
  struct wl1271_acx_host_config_bitmap *bitmap_conf;
  int ret;
  
#line 34 
  bitmap_conf = (struct wl1271_acx_host_config_bitmap *)kzalloc(12UL,208U);
  
#line 35 
  if (bitmap_conf == (struct wl1271_acx_host_config_bitmap *)0) {
    
#line 36 
    ret = -12;
    
#line 37 
    goto out;
  }
  else ;
  
#line 40 
  bitmap_conf->host_cfg_bitmap = host_cfg_bitmap;
  
#line 42 
  ret = wl1271_cmd_configure(wl,(unsigned short)57,(void *)bitmap_conf,12UL);
  
#line 44 
  if (ret < 0) {
    
#line 45 
    printk("\001",ret);
    
#line 46 
    goto out;
  }
  else ;
  out: 
#line 49 
  ;
  
#line 50 
  kfree((void const *)bitmap_conf);
  
#line 52 
  return ret;
}


#line 485  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_acx.c.aux"
static void *kzalloc(size_t size, gfp_t flags)
{
  void *tmp;
  
#line 488 
  tmp = ldv_kzalloc(size,flags);
  
#line 488 
  return tmp;
}


#line 45  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dynamic_debug.h"
void __dynamic_pr_debug(struct _ddebug *, char const * , ...);


#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/event.h"
void wlcore_event_soft_gemini_sense(struct wl1271 *, u8);


#line 73 
void wlcore_event_sched_scan_completed(struct wl1271 *, u8);


#line 75 
void wlcore_event_ba_rx_constraint(struct wl1271 *, unsigned long, unsigned long);


#line 78 
void wlcore_event_channel_switch(struct wl1271 *, unsigned long, bool);


#line 81 
void wlcore_event_beacon_loss(struct wl1271 *, unsigned long);


#line 82 
void wlcore_event_dummy_packet(struct wl1271 *);


#line 83 
void wlcore_event_max_tx_failure(struct wl1271 *, unsigned long);


#line 84 
void wlcore_event_inactive_sta(struct wl1271 *, unsigned long);


#line 85 
void wlcore_event_roc_complete(struct wl1271 *);


#line 86 
void wlcore_event_rssi_trigger(struct wl1271 *, s8 *);


#line 106  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/event.h"
int wl12xx_wait_for_event(struct wl1271 *wl, enum wlcore_wait_event event, bool *timeout);


#line 108 
int wl12xx_process_mailbox_events(struct wl1271 *wl);


#line 106  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/cmd.h"
int wlcore_cmd_wait_for_event_or_timeout(struct wl1271 *, u32, bool *);


#line 42  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/scan.h"
void wlcore_scan_sched_scan_results(struct wl1271 *);


#line 135  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/scan.h"
void wl12xx_scan_completed(struct wl1271 *wl, struct wl12xx_vif *wlvif);


#line 60  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/debug.h"
extern u32 wl12xx_debug_level;


#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/event.c"
int wl12xx_wait_for_event(struct wl1271 *wl, enum wlcore_wait_event event, bool *timeout)
{
  int __retres;
  u32 local_event;
  int tmp;
  
#line 32 
  switch ((unsigned int)event) {
    case (unsigned int)0: 
#line 33 
    ;
    
#line 34 
    local_event = 32768U;
    
#line 35 
    goto ldv_51183;
    case (unsigned int)1: 
#line 37 
    ;
    
#line 38 
    local_event = 134217728U;
    
#line 39 
    goto ldv_51183;
    default: 
#line 41 
    ;
    
#line 43 
    __retres = 0;
    
#line 43 
    goto return_label;
  }
  ldv_51183: 
#line 45 
  ;
  
#line 45 
  tmp = wlcore_cmd_wait_for_event_or_timeout(wl,local_event,timeout);
  
#line 45 
  __retres = tmp;
  return_label: 
#line 45 
                return __retres;
}


#line 48  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/event.c"
int wl12xx_process_mailbox_events(struct wl1271 *wl)
{
  int __retres;
  u32 vector;
  
#line 50 
  struct wl12xx_event_mailbox *mbox = (struct wl12xx_event_mailbox *)wl->mbox;
  
#line 54 
  vector = mbox->events_vector;
  
#line 55 
  vector = ~ mbox->events_mask & vector;
  
#line 57 
  if ((long)((wl12xx_debug_level & 32U) != 0U) != 0L) {
    
#line 57 
    struct _ddebug descriptor = {.modname = "wl12xx", .function = "wl12xx_process_mailbox_events", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/event.c", .format = "wlcore", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))57U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 57 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 57 
                                                        __dynamic_pr_debug(& descriptor,"wlcore",vector); else ;
  }
  else ;
  
#line 59 
  if ((vector & 1024U) != 0U) {
    
#line 60 
    if ((long)((wl12xx_debug_level & 32U) != 0U) != 0L) {
      
#line 60 
      struct _ddebug descriptor_0 = {.modname = "wl12xx", .function = "wl12xx_process_mailbox_events", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/event.c", .format = "wlcore", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))61U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 60 
      if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) 
#line 60 
                                                            __dynamic_pr_debug(& descriptor_0,"wlcore",(int)mbox->scheduled_scan_status); else ;
    }
    else ;
    
#line 63 
    if (wl->scan_wlvif != (struct wl12xx_vif *)0) 
#line 64 
                                                  wl12xx_scan_completed(wl,wl->scan_wlvif); else ;
  }
  else ;
  
#line 67 
  if ((vector & 536870912U) != 0U) {
    
#line 68 
    if ((long)((wl12xx_debug_level & 32U) != 0U) != 0L) {
      
#line 68 
      struct _ddebug descriptor_1 = {.modname = "wl12xx", .function = "wl12xx_process_mailbox_events", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/event.c", .format = "wlcore", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))70U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 68 
      if ((long)(((int)descriptor_1.flags & 1) != 0) != 0L) 
#line 68 
                                                            __dynamic_pr_debug(& descriptor_1,"wlcore",(int)mbox->scheduled_scan_status); else ;
    }
    else ;
    
#line 72 
    wlcore_scan_sched_scan_results(wl);
  }
  else ;
  
#line 75 
  if ((vector & 268435456U) != 0U) 
#line 76 
                                   wlcore_event_sched_scan_completed(wl,(unsigned char)((int)mbox->scheduled_scan_status)); else ;
  
#line 78 
  if ((vector & 4194304U) != 0U) 
#line 79 
                                 wlcore_event_soft_gemini_sense(wl,(unsigned char)((int)mbox->soft_gemini_sense_info)); else ;
  
#line 82 
  if ((vector & 262144U) != 0U) 
#line 83 
                                wlcore_event_beacon_loss(wl,255UL); else ;
  
#line 85 
  if ((vector & 1U) != 0U) 
#line 86 
                           wlcore_event_rssi_trigger(wl,(s8 *)(& mbox->rssi_snr_trigger_metric)); else ;
  
#line 88 
  if ((vector & 1073741824U) != 0U) 
#line 89 
                                    wlcore_event_ba_rx_constraint(wl,1UL << (int)mbox->role_id,(unsigned long)mbox->rx_ba_allowed); else ;
  
#line 93 
  if ((vector & 131072U) != 0U) 
#line 94 
                                wlcore_event_channel_switch(wl,255UL,(_Bool)((unsigned int)mbox->channel_switch_status != 0U)); else ;
  
#line 97 
  if ((vector & 2097152U) != 0U) 
#line 98 
                                 wlcore_event_dummy_packet(wl); else ;
  
#line 104 
  if ((vector & 1048576U) != 0U) 
#line 105 
                                 wlcore_event_max_tx_failure(wl,(unsigned long)mbox->sta_tx_retry_exceeded); else ;
  
#line 108 
  if ((vector & 67108864U) != 0U) 
#line 109 
                                  wlcore_event_inactive_sta(wl,(unsigned long)mbox->sta_aging_status); else ;
  
#line 112 
  if (vector < (u32)0) 
#line 113 
                       wlcore_event_roc_complete(wl); else ;
  
#line 115 
  __retres = 0;
  
#line 115 
  return __retres;
}


#line 7  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/fvtp/.tmp_main.c"
void ldv_inline_asm(void);


#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/export.h"
extern struct module __this_module;


#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/bitops.h"
__inline static void set_bit(long nr, unsigned long volatile *addr)
{
  
#line 74 
  if (0 != 0) 
#line 76 
              ldv_inline_asm(); else 
#line 79 
                                     ldv_inline_asm();
  
#line 80 
  return;
}


#line 308  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/bitops.h"
__inline static int constant_test_bit(long nr, unsigned long const volatile *addr)
{
  int __retres;
  
#line 311 
  __retres = ((*(addr + (nr >> 6)) >> (nr & 63L)) & 1UL) != 0UL;
  
#line 311 
  return __retres;
}


#line 314  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/bitops.h"
__inline static int variable_test_bit(long nr, unsigned long const volatile *addr)
{
  int oldbit;
  
#line 317 
  ldv_inline_asm();
  
#line 323 
  return oldbit;
}


#line 71  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/bug.h"
void warn_slowpath_null(char const *, int const);


#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/string_64.h"
void *memcpy(void *, void const *, size_t);


#line 67 
int strcmp(char const *, char const *);


#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/err.h"
static long PTR_ERR(void const *ptr);


#line 41 
static bool IS_ERR(void const *ptr);


#line 37  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_mutex_lock_73(struct mutex *ldv_func_arg1);


#line 43 
void ldv_mutex_model_lock(struct mutex *, char *);


#line 45 
void ldv_mutex_model_unlock(struct mutex *, char *);


#line 27  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/err.h"
long ldv_is_err(void const *ptr);


#line 30 
long ldv_ptr_err(void const *ptr);


#line 24  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/slab.h"
void *ldv_kmalloc(size_t size, gfp_t flags);


#line 193  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mutex.h"
static void ldv_mutex_unlock_72(struct mutex *ldv_func_arg1);


#line 78  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jiffies.h"
extern unsigned long volatile jiffies;


#line 285 
unsigned int jiffies_to_usecs(unsigned long const);


#line 365 
unsigned long __usecs_to_jiffies(unsigned int const);


#line 367  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jiffies.h"
__inline static unsigned long _usecs_to_jiffies(unsigned int const u)
{
  unsigned long __retres;
  
#line 369 
  __retres = (unsigned long)(((long)u + 3999L) / 4000L);
  
#line 369 
  return __retres;
}


#line 408  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jiffies.h"
__inline static unsigned long usecs_to_jiffies(unsigned int const u)
{
  unsigned long __retres;
  
#line 410 
  if (0 != 0) {
    unsigned int tmp;
    unsigned long tmp_0;
    
#line 411 
    tmp = jiffies_to_usecs(4611686018427387902UL);
    
#line 411 
    ;
    
#line 411 
    if (tmp < u) {
      
#line 412 
      __retres = 4611686018427387902UL;
      
#line 412 
      goto return_label;
    }
    else ;
    
#line 413 
    tmp_0 = _usecs_to_jiffies(u);
    
#line 413 
    __retres = tmp_0;
    
#line 413 
    goto return_label;
  }
  else {
    unsigned long tmp_1;
    
#line 415 
    tmp_1 = __usecs_to_jiffies(u);
    
#line 415 
    __retres = tmp_1;
    
#line 415 
    goto return_label;
  }
  return_label: 
#line 410 
                return __retres;
}


#line 864  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
__inline static void *dev_get_drvdata(struct device const *dev)
{
  void *__retres;
  
#line 866 
  __retres = dev->driver_data;
  
#line 866 
  return __retres;
}


#line 996  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
__inline static void *dev_get_platdata(struct device const *dev)
{
  void *__retres;
  
#line 998 
  __retres = dev->platform_data;
  
#line 998 
  return __retres;
}


#line 197  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/platform_device.h"
static int ldv___platform_driver_register_74(struct platform_driver *ldv_func_arg1, struct module *ldv_func_arg2);


#line 202 
static void ldv_platform_driver_unregister_75(struct platform_driver *ldv_func_arg1);


#line 213  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/platform_device.h"
__inline static void *platform_get_drvdata(struct platform_device const *pdev)
{
  void *tmp;
  
#line 215 
  tmp = dev_get_drvdata(& pdev->dev);
  
#line 215 
  return tmp;
}


#line 418  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/slab.h"
static void *kmalloc(size_t size, gfp_t flags);


#line 10  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/delay.h"
void __const_udelay(unsigned long);


#line 29  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/boot.h"
int wlcore_boot_upload_firmware(struct wl1271 *);


#line 30 
int wlcore_boot_upload_nvs(struct wl1271 *);


#line 31 
int wlcore_boot_run_firmware(struct wl1271 *);


#line 505  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/wlcore.h"
int wlcore_probe(struct wl1271 *, struct platform_device *);


#line 506 
int wlcore_remove(struct platform_device *);


#line 507 
struct ieee80211_hw *wlcore_alloc_hw(size_t, u32, u32);


#line 509 
int wlcore_free_hw(struct wl1271 *);


#line 510 
int wlcore_set_key(struct wl1271 *, enum set_key_cmd, struct ieee80211_vif *, struct ieee80211_sta *, struct ieee80211_key_conf *);


#line 519  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/wlcore.h"
__inline static void wlcore_set_ht_cap(struct wl1271 *wl, enum ieee80211_band band, struct ieee80211_sta_ht_cap *ht_cap)
{
  
#line 522 
  memcpy((void *)(& wl->ht_cap[(unsigned int)band]),(void const *)ht_cap,22UL);
  
#line 523 
  return;
}


#line 529  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/wlcore.h"
__inline static void wlcore_set_min_fw_ver(struct wl1271 *wl, unsigned int chip, unsigned int iftype_sr, unsigned int major_sr, unsigned int subtype_sr, unsigned int minor_sr, unsigned int iftype_mr, unsigned int major_mr, unsigned int subtype_mr, unsigned int minor_mr)
{
  
#line 535 
  wl->min_sr_fw_ver[0] = chip;
  
#line 536 
  wl->min_sr_fw_ver[1] = iftype_sr;
  
#line 537 
  wl->min_sr_fw_ver[2] = major_sr;
  
#line 538 
  wl->min_sr_fw_ver[3] = subtype_sr;
  
#line 539 
  wl->min_sr_fw_ver[4] = minor_sr;
  
#line 541 
  wl->min_mr_fw_ver[0] = chip;
  
#line 542 
  wl->min_mr_fw_ver[1] = iftype_mr;
  
#line 543 
  wl->min_mr_fw_ver[2] = major_mr;
  
#line 544 
  wl->min_mr_fw_ver[3] = subtype_mr;
  
#line 545 
  wl->min_mr_fw_ver[4] = minor_mr;
  
#line 546 
  return;
}


#line 47  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/io.h"
void wlcore_disable_interrupts(struct wl1271 *);


#line 49 
void wlcore_enable_interrupts(struct wl1271 *);


#line 54 
int wlcore_translate_addr(struct wl1271 *, int);


#line 57  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/io.h"
__inline static int wlcore_raw_write(struct wl1271 *wl, int addr, void *buf, size_t len, bool fixed)
{
  int __retres;
  int ret;
  int tmp;
  
#line 63 
  tmp = constant_test_bit(14L,(unsigned long const volatile *)(& wl->flags));
  
#line 63 
  if (tmp != 0) {
    
#line 66 
    __retres = -5;
    
#line 66 
    goto return_label;
  }
  else {
    int tmp_2;
    {
      int tmp_1;
      int tmp_0;
      
#line 64 
      tmp_0 = constant_test_bit(3L,(unsigned long const volatile *)(& wl->flags));
      
#line 64 
      if (tmp_0 != 0) 
        
#line 64 
        if (addr != 131068) 
#line 64 
                            tmp_1 = 1; else 
#line 64 
                                            tmp_1 = 0;
      else 
#line 64 
           tmp_1 = 0;
      
#line 64 
      int __ret_warn_on = tmp_1;
      
#line 64 
      if ((long)(__ret_warn_on != 0) != 0L) 
#line 64 
                                            warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/../wlcore/io.h",65); else ;
      
#line 64 
      tmp_2 = (long)(__ret_warn_on != 0);
    }
    
#line 63 
    if ((long)tmp_2 != 0L) {
      
#line 66 
      __retres = -5;
      
#line 66 
      goto return_label;
    }
    else ;
  }
  
#line 68 
  ret = (*((wl->if_ops)->write))(wl->dev,addr,buf,len,(_Bool)((bool)((int)fixed) != 0));
  
#line 69 
  if (ret != 0 && wl->state != (unsigned int)WLCORE_STATE_OFF) 
#line 70 
                                                               set_bit(14L,(unsigned long volatile *)(& wl->flags)); else ;
  
#line 72 
  __retres = ret;
  return_label: 
#line 72 
                return __retres;
}


#line 75  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/io.h"
__inline static int wlcore_raw_read(struct wl1271 *wl, int addr, void *buf, size_t len, bool fixed)
{
  int __retres;
  int ret;
  int tmp;
  
#line 81 
  tmp = constant_test_bit(14L,(unsigned long const volatile *)(& wl->flags));
  
#line 81 
  if (tmp != 0) {
    
#line 84 
    __retres = -5;
    
#line 84 
    goto return_label;
  }
  else {
    int tmp_2;
    {
      int tmp_1;
      int tmp_0;
      
#line 82 
      tmp_0 = constant_test_bit(3L,(unsigned long const volatile *)(& wl->flags));
      
#line 82 
      if (tmp_0 != 0) 
        
#line 82 
        if (addr != 131068) 
#line 82 
                            tmp_1 = 1; else 
#line 82 
                                            tmp_1 = 0;
      else 
#line 82 
           tmp_1 = 0;
      
#line 82 
      int __ret_warn_on = tmp_1;
      
#line 82 
      if ((long)(__ret_warn_on != 0) != 0L) 
#line 82 
                                            warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/../wlcore/io.h",83); else ;
      
#line 82 
      tmp_2 = (long)(__ret_warn_on != 0);
    }
    
#line 81 
    if ((long)tmp_2 != 0L) {
      
#line 84 
      __retres = -5;
      
#line 84 
      goto return_label;
    }
    else ;
  }
  
#line 86 
  ret = (*((wl->if_ops)->read))(wl->dev,addr,buf,len,(_Bool)((bool)((int)fixed) != 0));
  
#line 87 
  if (ret != 0 && wl->state != (unsigned int)WLCORE_STATE_OFF) 
#line 88 
                                                               set_bit(14L,(unsigned long volatile *)(& wl->flags)); else ;
  
#line 90 
  __retres = ret;
  return_label: 
#line 90 
                return __retres;
}


#line 107  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/io.h"
__inline static int wlcore_raw_read32(struct wl1271 *wl, int addr, u32 *val)
{
  int __retres;
  int ret;
  
#line 112 
  ret = wlcore_raw_read(wl,addr,(void *)wl->buffer_32,4UL,(_Bool)0);
  
#line 114 
  if (ret < 0) {
    
#line 115 
    __retres = ret;
    
#line 115 
    goto return_label;
  }
  else ;
  
#line 117 
  if (val != (u32 *)0U) 
#line 118 
                        *val = *(wl->buffer_32); else ;
  
#line 120 
  __retres = 0;
  return_label: 
#line 120 
                return __retres;
}


#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/io.h"
__inline static int wlcore_raw_write32(struct wl1271 *wl, int addr, u32 val)
{
  int tmp;
  
#line 126 
  *(wl->buffer_32) = val;
  
#line 127 
  tmp = wlcore_raw_write(wl,addr,(void *)wl->buffer_32,4UL,(_Bool)0);
  
#line 127 
  return tmp;
}


#line 141  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/io.h"
__inline static int wlcore_write(struct wl1271 *wl, int addr, void *buf, size_t len, bool fixed)
{
  int physical;
  int tmp;
  
#line 146 
  physical = wlcore_translate_addr(wl,addr);
  
#line 148 
  tmp = wlcore_raw_write(wl,physical,buf,len,(_Bool)((bool)((int)fixed) != 0));
  
#line 148 
  return tmp;
}


#line 180  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/io.h"
__inline static int wlcore_read32(struct wl1271 *wl, int addr, u32 *val)
{
  int tmp_0;
  int tmp;
  
#line 183 
  ;
  
#line 183 
  tmp = wlcore_translate_addr(wl,addr);
  
#line 183 
  ;
  
#line 183 
  tmp_0 = wlcore_raw_read32(wl,tmp,val);
  
#line 183 
  return tmp_0;
}


#line 186  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/io.h"
__inline static int wlcore_write32(struct wl1271 *wl, int addr, u32 val)
{
  int tmp_0;
  int tmp;
  
#line 189 
  ;
  
#line 189 
  tmp = wlcore_translate_addr(wl,addr);
  
#line 189 
  ;
  
#line 189 
  tmp_0 = wlcore_raw_write32(wl,tmp,val);
  
#line 189 
  return tmp_0;
}


#line 192  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/io.h"
__inline static int wlcore_read_reg(struct wl1271 *wl, int reg, u32 *val)
{
  int tmp_0;
  int tmp;
  
#line 195 
  ;
  
#line 195 
  tmp = wlcore_translate_addr(wl,*(wl->rtable + reg));
  
#line 195 
  ;
  
#line 195 
  tmp_0 = wlcore_raw_read32(wl,tmp,val);
  
#line 195 
  return tmp_0;
}


#line 200  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/io.h"
__inline static int wlcore_write_reg(struct wl1271 *wl, int reg, u32 val)
{
  int tmp_0;
  int tmp;
  
#line 203 
  ;
  
#line 203 
  tmp = wlcore_translate_addr(wl,*(wl->rtable + reg));
  
#line 203 
  ;
  
#line 203 
  tmp_0 = wlcore_raw_write32(wl,tmp,val);
  
#line 203 
  return tmp_0;
}


#line 229 
int wlcore_set_partition(struct wl1271 *, struct wlcore_partition_set const *);


#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/cmd.h"
int wl1271_cmd_data_path(struct wl1271 *, bool);


#line 98 
int wl12xx_cmd_channel_switch(struct wl1271 *wl, struct wl12xx_vif *wlvif, struct ieee80211_channel_switch *ch_switch);


#line 1045  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/acx.h"
int wl1271_acx_sleep_auth(struct wl1271 *, u8);


#line 1089 
int wl12xx_acx_mem_cfg(struct wl1271 *);


#line 1090 
int wl1271_acx_init_mem_config(struct wl1271 *);


#line 1097 
int wl1271_acx_pm_config(struct wl1271 *);


#line 1106 
int wl1271_acx_set_ht_capabilities(struct wl1271 *, struct ieee80211_sta_ht_cap *, bool, u8);


#line 245  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/tx.h"
int wlcore_tx_complete(struct wl1271 *);


#line 259 
unsigned int wlcore_calc_packet_alignment(struct wl1271 *, unsigned int);


#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/cmd.h"
int wl1271_cmd_general_parms(struct wl1271 *wl);


#line 124 
int wl128x_cmd_general_parms(struct wl1271 *wl);


#line 125 
int wl1271_cmd_radio_parms(struct wl1271 *wl);


#line 126 
int wl128x_cmd_radio_parms(struct wl1271 *wl);


#line 127 
int wl1271_cmd_ext_radio_parms(struct wl1271 *wl);


#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/scan.h"
int wl12xx_scan_start(struct wl1271 *wl, struct wl12xx_vif *wlvif, struct cfg80211_scan_request *req);


#line 134 
int wl12xx_scan_stop(struct wl1271 *wl, struct wl12xx_vif *wlvif);


#line 136 
int wl12xx_sched_scan_start(struct wl1271 *wl, struct wl12xx_vif *wlvif, struct cfg80211_sched_scan_request *req, struct ieee80211_scan_ies *ies);


#line 139 
void wl12xx_scan_sched_scan_stop(struct wl1271 *wl, struct wl12xx_vif *wlvif);


#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.h"
int wl12xx_debugfs_add_files(struct wl1271 *wl, struct dentry *rootdir);


#line 43  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c"
static char *fref_param;

#line 44  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c"
static char *tcxo_param;

#line 46  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c"
static struct wlcore_conf wl12xx_conf = {.sg = {.params = {10U, 180U, 10U, 180U, 10U, 80U, 10U, 80U, 8U, 8U, 20U, 20U, 20U, 35U, 16U, 35U, 32U, 50U, 28U, 50U, 10U, 20U, 75U, 15U, 27U, 17U, 170U, 50U, 100U, 800U, 200U, 200U, 0U, 0U, 0U, 1U, 0U, 60U, 5000U, 1200U, 1000U, 1U, 3U, 6U, 10U, 10U, 2U, 5U, 30U, 3U, 10U, 2U, 0U, 25U, 25U, 0U, 0U}, .state = (unsigned char)1U}, .rx = {.rx_msdu_life_time = 512000U, .packet_detection_threshold = 0U, .ps_poll_timeout = (unsigned short)15U, .upsd_timeout = (unsigned short)15U, .rts_threshold = (unsigned short)2353U, .rx_cca_threshold = (unsigned short)0U, .irq_blk_threshold = (unsigned short)65535U, .irq_pkt_threshold = (unsigned short)0U, .irq_timeout = (unsigned short)600U, .queue_type = (unsigned char)0U}, .tx = {.tx_energy_detection = (unsigned char)0U, .sta_rc_conf = {.enabled_rates = 0U, .short_retry_limit = (unsigned char)10U, .long_retry_limit = (unsigned char)10U, .aflags = (unsigned char)0U}, .ac_conf_count = (unsigned char)4U, .ac_conf = {{.ac = (unsigned char)0U, .cw_min = (unsigned char)15U, .cw_max = (unsigned short)63U, .aifsn = (unsigned char)3U, .tx_op_limit = (unsigned short)0U}, {.ac = (unsigned char)1U, .cw_min = (unsigned char)15U, .cw_max = (unsigned short)63U, .aifsn = (unsigned char)7U, .tx_op_limit = (unsigned short)0U}, {.ac = (unsigned char)2U, .cw_min = (unsigned char)15U, .cw_max = (unsigned short)63U, .aifsn = (unsigned char)1U, .tx_op_limit = (unsigned short)3008U}, {.ac = (unsigned char)3U, .cw_min = (unsigned char)15U, .cw_max = (unsigned short)63U, .aifsn = (unsigned char)1U, .tx_op_limit = (unsigned short)1504U}}, .max_tx_retries = (unsigned char)100U, .ap_aging_period = (unsigned short)300U, .tid_conf_count = (unsigned char)4U, .tid_conf = {{.queue_id = (unsigned char)0U, .channel_type = (unsigned char)1U, .tsid = (unsigned char)0U, .ps_scheme = (unsigned char)0U, .ack_policy = (unsigned char)0U, .apsd_conf = {0U, 0U}}, {.queue_id = (unsigned char)1U, .channel_type = (unsigned char)1U, .tsid = (unsigned char)1U, .ps_scheme = (unsigned char)0U, .ack_policy = (unsigned char)0U, .apsd_conf = {0U, 0U}}, {.queue_id = (unsigned char)2U, .channel_type = (unsigned char)1U, .tsid = (unsigned char)2U, .ps_scheme = (unsigned char)0U, .ack_policy = (unsigned char)0U, .apsd_conf = {0U, 0U}}, {.queue_id = (unsigned char)3U, .channel_type = (unsigned char)1U, .tsid = (unsigned char)3U, .ps_scheme = (unsigned char)0U, .ack_policy = (unsigned char)0U, .apsd_conf = {0U, 0U}}}, .frag_threshold = (unsigned short)2352U, .tx_compl_timeout = (unsigned short)700U, .tx_compl_threshold = (unsigned short)4U, .basic_rate = 1U, .basic_rate_5 = 8U, .tmpl_short_retry_limit = (unsigned char)10U, .tmpl_long_retry_limit = (unsigned char)10U, .tx_watchdog_timeout = 5000U, .slow_link_thold = (unsigned char)3U, .fast_link_thold = (unsigned char)10U}, .conn = {.wake_up_event = (unsigned char)2U, .listen_interval = (unsigned char)1U, .suspend_wake_up_event = (unsigned char)4U, .suspend_listen_interval = (unsigned char)3U, .bcn_filt_mode = (unsigned char)1U, .bcn_filt_ie_count = (unsigned char)3U, .bcn_filt_ie = {{.ie = (unsigned char)37U, .rule = (unsigned char)2U, .oui = {(unsigned char)0, (unsigned char)0, (unsigned char)0}, .type = (unsigned char)0, .version = {(unsigned char)0, (unsigned char)0}}, {.ie = (unsigned char)61U, .rule = (unsigned char)1U, .oui = {(unsigned char)0, (unsigned char)0, (unsigned char)0}, .type = (unsigned char)0, .version = {(unsigned char)0, (unsigned char)0}}, {.ie = (unsigned char)42U, .rule = (unsigned char)1U, .oui = {(unsigned char)0, (unsigned char)0, (unsigned char)0}, .type = (unsigned char)0, .version = {(unsigned char)0, (unsigned char)0}}}, .synch_fail_thold = 12U, .bss_lose_timeout = 400U, .beacon_rx_timeout = 10000U, .broadcast_timeout = 20000U, .rx_broadcast_in_ps = (unsigned char)1U, .ps_poll_threshold = (unsigned char)10U, .sig_weights = {.rssi_bcn_avg_weight = (unsigned char)0, .rssi_pkt_avg_weight = (unsigned char)0, .snr_bcn_avg_weight = (unsigned char)0, .snr_pkt_avg_weight = (unsigned char)0}, .bet_enable = (unsigned char)1U, .bet_max_consecutive = (unsigned char)50U, .psm_entry_retries = (unsigned char)8U, .psm_exit_retries = (unsigned char)16U, .psm_entry_nullfunc_retries = (unsigned char)3U, .dynamic_ps_timeout = (unsigned short)1500U, .forced_ps = (unsigned char)0U, .keep_alive_interval = 55000U, .max_listen_interval = (unsigned char)20U, .sta_sleep_auth = (unsigned char)255U, .suspend_rx_ba_activity = (unsigned char)0U}, .itrim = {.enable = (unsigned char)0U, .timeout = 50000U}, .pm_config = {.host_clk_settling_time = 5000U, .host_fast_wakeup_support = (unsigned char)1U}, .roam_trigger = {.trigger_pacing = (unsigned short)1U, .avg_weight_rssi_beacon = (unsigned char)20U, .avg_weight_rssi_data = (unsigned char)10U, .avg_weight_snr_beacon = (unsigned char)20U, .avg_weight_snr_data = (unsigned char)10U}, .scan = {.min_dwell_time_active = 7500U, .max_dwell_time_active = 30000U, .min_dwell_time_active_long = 25000U, .max_dwell_time_active_long = 50000U, .dwell_time_passive = 100000U, .dwell_time_dfs = 150000U, .num_probe_reqs = (unsigned short)2U, .split_scan_timeout = 50000U}, .sched_scan = {.base_dwell_time = 7500U, .max_dwell_time_delta = 22500U, .dwell_time_delta_per_probe = 2000U, .dwell_time_delta_per_probe_5 = 350U, .dwell_time_passive = 100000U, .dwell_time_dfs = 150000U, .num_probe_reqs = (unsigned char)2U, .rssi_threshold = (signed char)(-90), .snr_threshold = (signed char)0}, .ht = {.rx_ba_win_size = (unsigned char)8U, .tx_ba_win_size = (unsigned char)64U, .inactivity_timeout = (unsigned short)10000U, .tx_ba_tid_bitmap = (unsigned char)63U}, .mem = {.num_stations = (unsigned char)1U, .ssid_profiles = (unsigned char)1U, .rx_block_num = (unsigned char)40U, .tx_min_block_num = (unsigned char)40U, .dynamic_memory = (unsigned char)1U, .min_req_tx_blocks = (unsigned char)45U, .min_req_rx_blocks = (unsigned char)22U, .tx_min = (unsigned char)27U}, .fm_coex = {.enable = (unsigned char)1U, .swallow_period = (unsigned char)5U, .n_divider_fref_set_1 = (unsigned char)255U, .n_divider_fref_set_2 = (unsigned char)12U, .m_divider_fref_set_1 = (unsigned short)65535U, .m_divider_fref_set_2 = (unsigned short)148U, .coex_pll_stabilization_time = 4294967295U, .ldo_stabilization_time = (unsigned short)65535U, .fm_disturbed_band_margin = (unsigned char)255U, .swallow_clk_diff = (unsigned char)255U}, .rx_streaming = {.duration = 150U, .queues = (unsigned char)1U, .interval = (unsigned char)20U, .always = (unsigned char)0U}, .fwlog = {.mode = (unsigned char)0U, .mem_blocks = (unsigned char)2U, .severity = (unsigned char)0U, .timestamp = (unsigned char)0U, .output = (unsigned char)1U, .threshold = (unsigned char)0U}, .rate = {.rate_retry_score = (unsigned short)32000U, .per_add = (unsigned short)8192U, .per_th1 = (unsigned short)2048U, .per_th2 = (unsigned short)4096U, .max_per = (unsigned short)8100U, .inverse_curiosity_factor = (unsigned char)5U, .tx_fail_low_th = (unsigned char)4U, .tx_fail_high_th = (unsigned char)10U, .per_alpha_shift = (unsigned char)4U, .per_add_shift = (unsigned char)13U, .per_beta1_shift = (unsigned char)10U, .per_beta2_shift = (unsigned char)8U, .rate_check_up = (unsigned char)2U, .rate_check_down = (unsigned char)12U, .rate_retry_policy = {(unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U}}, .hangover = {.recover_time = 0U, .hangover_period = (unsigned char)20U, .dynamic_mode = (unsigned char)1U, .early_termination_mode = (unsigned char)1U, .max_period = (unsigned char)20U, .min_period = (unsigned char)1U, .increase_delta = (unsigned char)1U, .decrease_delta = (unsigned char)2U, .quiet_time = (unsigned char)4U, .increase_time = (unsigned char)1U, .window_size = (unsigned char)16U}, .recovery = {.bug_on_recovery = (unsigned char)0U, .no_recovery = (unsigned char)0U}};

#line 382  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c"
static struct wl12xx_priv_conf wl12xx_default_priv_conf = {.rf = {.tx_per_channel_power_compensation_2 = {(unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U}, .tx_per_channel_power_compensation_5 = {(unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U}}, .mem_wl127x = {.num_stations = (unsigned char)1U, .ssid_profiles = (unsigned char)1U, .rx_block_num = (unsigned char)70U, .tx_min_block_num = (unsigned char)40U, .dynamic_memory = (unsigned char)1U, .min_req_tx_blocks = (unsigned char)100U, .min_req_rx_blocks = (unsigned char)22U, .tx_min = (unsigned char)27U}};

#line 410  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c"
static u8 const wl12xx_rate_to_idx_2ghz[22U] = {(unsigned char)7U, (unsigned char)7U, (unsigned char)6U, (unsigned char)5U, (unsigned char)4U, (unsigned char)3U, (unsigned char)2U, (unsigned char)1U, (unsigned char)0U, (unsigned char)11U, (unsigned char)10U, (unsigned char)9U, (unsigned char)8U, (unsigned char)255U, (unsigned char)7U, (unsigned char)6U, (unsigned char)3U, (unsigned char)5U, (unsigned char)4U, (unsigned char)2U, (unsigned char)1U, (unsigned char)0U};

#line 440  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c"
static u8 const wl12xx_rate_to_idx_5ghz[22U] = {(unsigned char)7U, (unsigned char)7U, (unsigned char)6U, (unsigned char)5U, (unsigned char)4U, (unsigned char)3U, (unsigned char)2U, (unsigned char)1U, (unsigned char)0U, (unsigned char)7U, (unsigned char)6U, (unsigned char)5U, (unsigned char)4U, (unsigned char)255U, (unsigned char)3U, (unsigned char)2U, (unsigned char)255U, (unsigned char)1U, (unsigned char)0U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U};

#line 470  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c"
static u8 const *wl12xx_band_rate_to_idx[2U] = {(u8 const *)(& wl12xx_rate_to_idx_2ghz), (u8 const *)(& wl12xx_rate_to_idx_5ghz)};

#line 501  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c"
static struct wlcore_partition_set wl12xx_ptable[6U] = {{.mem = {.size = 96192U, .start = 0U}, .reg = {.size = 34816U, .start = 3145728U}, .mem2 = {.size = 0U, .start = 0U}, .mem3 = {.size = 0U, .start = 0U}}, {.mem = {.size = 85952U, .start = 262144U}, .reg = {.size = 40960U, .start = 3145728U}, .mem2 = {.size = 4U, .start = 3147000U}, .mem3 = {.size = 0U, .start = 263172U}}, {.mem = {.size = 85952U, .start = 262144U}, .reg = {.size = 34816U, .start = 3145728U}, .mem2 = {.size = 0U, .start = 0U}, .mem3 = {.size = 0U, .start = 0U}}, {.mem = {.size = 85952U, .start = 262144U}, .reg = {.size = 24576U, .start = 3211264U}, .mem2 = {.size = 0U, .start = 0U}, .mem3 = {.size = 0U, .start = 0U}}};

#line 580  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c"
static int const wl12xx_rtable[13U] = {3147780, 3146984, 3146992, 3167752, 3167756, 3146868, 3146972, 3167768, 3167860, 264116, 3145752, 3145736, 126912};

#line 609  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c"
static int wl127x_prepare_read(struct wl1271 *wl, u32 rx_desc, u32 len)
{
  int __retres;
  int ret;
  
#line 613 
  if (wl->chip.id != 84082961U) {
    
#line 614 
    struct wl1271_acx_mem_map *wl_mem_map = wl->target_mem_map;
    
#line 615 
    struct wl12xx_priv *priv = (struct wl12xx_priv *)wl->priv;
    
#line 622 
    u32 mem_block = rx_desc & 255U;
    
#line 624 
    (priv->rx_mem_addr)->addr = (mem_block << 8) + wl_mem_map->packet_memory_pool_start;
    
#line 627 
    (priv->rx_mem_addr)->addr_extra = (priv->rx_mem_addr)->addr + 4U;
    
#line 629 
    ret = wlcore_write(wl,3145736,(void *)priv->rx_mem_addr,8UL,(_Bool)0);
    
#line 631 
    if (ret < 0) {
      
#line 632 
      __retres = ret;
      
#line 632 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 635 
  __retres = 0;
  return_label: 
#line 635 
                return __retres;
}


#line 638  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c"
static int wl12xx_identify_chip(struct wl1271 *wl)
{
  
#line 640 
  int ret = 0;
  
#line 642 
  switch (wl->chip.id) {
    case (u32)67305729: 
#line 643 
    ;
    
#line 644 
    printk("\001",wl->chip.id);
    
#line 647 
    wl->quirks |= 5410U;
    
#line 652 
    wl->sr_fw_name = "ti-connectivity/wl127x-fw-5-sr.bin";
    
#line 653 
    wl->mr_fw_name = "ti-connectivity/wl127x-fw-5-mr.bin";
    
#line 654 
    memcpy((void *)(& wl->conf.mem),(void const *)(& wl12xx_default_priv_conf.mem_wl127x),8UL);
    
#line 658 
    (wl->ops)->prepare_read = & wl127x_prepare_read;
    
#line 660 
    wlcore_set_min_fw_ver(wl,6U,3U,10U,4294967295U,133U,5U,7U,4294967295U,42U);
    
#line 665 
    goto ldv_53435;
    case (u32)67305745: 
#line 667 
    ;
    
#line 668 
    if ((long)((wl12xx_debug_level & 4U) != 0U) != 0L) {
      
#line 668 
      struct _ddebug descriptor = {.modname = "wl12xx", .function = "wl12xx_identify_chip", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c", .format = "wlcore", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))669U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 668 
      if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 668 
                                                          __dynamic_pr_debug(& descriptor,"wlcore",wl->chip.id); else ;
    }
    else ;
    
#line 671 
    wl->quirks |= 5410U;
    
#line 676 
    wl->plt_fw_name = "ti-connectivity/wl127x-fw-5-plt.bin";
    
#line 677 
    wl->sr_fw_name = "ti-connectivity/wl127x-fw-5-sr.bin";
    
#line 678 
    wl->mr_fw_name = "ti-connectivity/wl127x-fw-5-mr.bin";
    
#line 679 
    memcpy((void *)(& wl->conf.mem),(void const *)(& wl12xx_default_priv_conf.mem_wl127x),8UL);
    
#line 683 
    (wl->ops)->prepare_read = & wl127x_prepare_read;
    
#line 685 
    wlcore_set_min_fw_ver(wl,6U,3U,10U,4294967295U,133U,5U,7U,4294967295U,42U);
    
#line 690 
    goto ldv_53435;
    case (u32)84082961: 
#line 692 
    ;
    
#line 693 
    if ((long)((wl12xx_debug_level & 4U) != 0U) != 0L) {
      
#line 693 
      struct _ddebug descriptor_0 = {.modname = "wl12xx", .function = "wl12xx_identify_chip", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c", .format = "wlcore", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))694U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 693 
      if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) 
#line 693 
                                                            __dynamic_pr_debug(& descriptor_0,"wlcore",wl->chip.id); else ;
    }
    else ;
    
#line 695 
    wl->plt_fw_name = "ti-connectivity/wl128x-fw-5-plt.bin";
    
#line 696 
    wl->sr_fw_name = "ti-connectivity/wl128x-fw-5-sr.bin";
    
#line 697 
    wl->mr_fw_name = "ti-connectivity/wl128x-fw-5-mr.bin";
    
#line 700 
    wl->quirks |= 5382U;
    
#line 706 
    wlcore_set_min_fw_ver(wl,7U,3U,10U,4294967295U,133U,5U,7U,4294967295U,42U);
    
#line 711 
    goto ldv_53435;
    case (u32)84082945: 
#line 712 
    ;
    default: 
#line 713 
    ;
    
#line 714 
    printk("\001",wl->chip.id);
    
#line 715 
    ret = -19;
    
#line 716 
    goto out;
  }
  ldv_53435: 
#line 719 
  ;
  
#line 719 
  wl->fw_mem_block_size = 256U;
  
#line 720 
  wl->fwlog_end = 33554432U;
  
#line 723 
  wl->scan_templ_id_2_4 = (unsigned char)9U;
  
#line 724 
  wl->scan_templ_id_5 = (unsigned char)10U;
  
#line 725 
  wl->sched_scan_templ_id_2_4 = (unsigned char)2U;
  
#line 726 
  wl->sched_scan_templ_id_5 = (unsigned char)3U;
  
#line 727 
  wl->max_channels_5 = (unsigned char)23U;
  
#line 728 
  wl->ba_rx_session_count_max = 3;
  out: 
#line 729 
  ;
  
#line 730 
  return ret;
}


#line 733  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c"
static int wl12xx_top_reg_write(struct wl1271 *wl, int addr, u16 val)
{
  int ret;
  
#line 739 
  addr = (addr >> 1) + 196608;
  
#line 740 
  ret = wlcore_write32(wl,3148212,(unsigned int)addr);
  
#line 741 
  if (ret < 0) 
#line 742 
               goto out; else ;
  
#line 745 
  ret = wlcore_write32(wl,3148216,(unsigned int)val);
  
#line 746 
  if (ret < 0) 
#line 747 
               goto out; else ;
  
#line 750 
  ret = wlcore_write32(wl,3148224,1U);
  
#line 751 
  if (ret < 0) 
#line 752 
               goto out; else ;
  out: 
#line 754 
  ;
  
#line 755 
  return ret;
}


#line 758  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c"
static int wl12xx_top_reg_read(struct wl1271 *wl, int addr, u16 *out)
{
  int __retres;
  u32 val;
  int ret;
  
#line 762 
  int timeout = 32;
  
#line 766 
  addr = (addr >> 1) + 196608;
  
#line 767 
  ret = wlcore_write32(wl,3148212,(unsigned int)addr);
  
#line 768 
  if (ret < 0) {
    
#line 769 
    __retres = ret;
    
#line 769 
    goto return_label;
  }
  else ;
  
#line 772 
  ret = wlcore_write32(wl,3148224,2U);
  
#line 773 
  if (ret < 0) {
    
#line 774 
    __retres = ret;
    
#line 774 
    goto return_label;
  }
  else ;
  ldv_53459: 
#line 775 
  ;
  
#line 778 
  ret = wlcore_read32(wl,3148220,& val);
  
#line 779 
  if (ret < 0) {
    
#line 780 
    __retres = ret;
    
#line 780 
    goto return_label;
  }
  else ;
  
#line 781 
  if (((unsigned long)val & 262144UL) == 0UL) {
    
#line 781 
    timeout -= 1;
    
#line 781 
    if (timeout != 0) 
#line 783 
                      goto ldv_53459; else 
#line 786 
                                           goto ldv_53460;
  }
  else 
#line 786 
       goto ldv_53460;
  ldv_53460: 
#line 787 
  ;
  
#line 783 
  if (timeout == 0) {
    
#line 784 
    printk("\001");
    
#line 785 
    __retres = -110;
    
#line 785 
    goto return_label;
  }
  else ;
  
#line 789 
  if (((unsigned long)val & 196608UL) != 65536UL) {
    
#line 790 
    printk("\001");
    
#line 791 
    __retres = -5;
    
#line 791 
    goto return_label;
  }
  else ;
  
#line 794 
  if (out != (u16 *)0U) 
#line 795 
                        *out = (unsigned short)val; else ;
  
#line 797 
  __retres = 0;
  return_label: 
#line 797 
                return __retres;
}


#line 800  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c"
static int wl128x_switch_tcxo_to_fref(struct wl1271 *wl)
{
  int __retres;
  u16 spare_reg;
  int ret;
  
#line 806 
  ret = wl12xx_top_reg_read(wl,8992,& spare_reg);
  
#line 807 
  if (ret < 0) {
    
#line 808 
    __retres = ret;
    
#line 808 
    goto return_label;
  }
  else ;
  
#line 810 
  if ((unsigned int)spare_reg == 65535U) {
    
#line 811 
    __retres = -14;
    
#line 811 
    goto return_label;
  }
  else ;
  
#line 812 
  spare_reg = (unsigned short)((unsigned int)spare_reg | 104U);
  
#line 813 
  ret = wl12xx_top_reg_write(wl,8992,(unsigned short)((int)spare_reg));
  
#line 814 
  if (ret < 0) {
    
#line 815 
    __retres = ret;
    
#line 815 
    goto return_label;
  }
  else ;
  
#line 818 
  ret = wl12xx_top_reg_write(wl,8704,(unsigned short)13);
  
#line 820 
  if (ret < 0) {
    
#line 821 
    __retres = ret;
    
#line 821 
    goto return_label;
  }
  else ;
  {
    
#line 824 
    unsigned long __ms = 15UL;
    {
      unsigned long tmp;
      
#line 824 
      goto ldv_53468;
      ldv_53467: 
#line 825 
      ;
      
#line 824 
      __const_udelay(4295000UL);
      ldv_53468: 
#line 826 
      ;
      
#line 824 
      tmp = __ms;
      
#line 824 
      __ms -= 1UL;
      
#line 824 
      ;
      
#line 824 
      if (tmp != 0UL) 
#line 826 
                      goto ldv_53467; else 
#line 829 
                                           goto ldv_53469;
      ldv_53469: 
#line 830 
      ;
    }
  }
  
#line 826 
  __retres = 0;
  return_label: 
#line 826 
                return __retres;
}


#line 829  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c"
static bool wl128x_is_tcxo_valid(struct wl1271 *wl)
{
  bool __retres;
  u16 tcxo_detection;
  int ret;
  
#line 834 
  ret = wl12xx_top_reg_read(wl,8806,& tcxo_detection);
  
#line 835 
  if (ret < 0) {
    
#line 836 
    __retres = (_Bool)0;
    
#line 836 
    goto return_label;
  }
  else ;
  
#line 838 
  if (((unsigned long)tcxo_detection & 16UL) != 0UL) {
    
#line 839 
    __retres = (_Bool)0;
    
#line 839 
    goto return_label;
  }
  else ;
  
#line 841 
  __retres = (_Bool)1;
  return_label: 
#line 841 
                return __retres;
}


#line 844  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c"
static bool wl128x_is_fref_valid(struct wl1271 *wl)
{
  bool __retres;
  u16 fref_detection;
  int ret;
  
#line 849 
  ret = wl12xx_top_reg_read(wl,8326,& fref_detection);
  
#line 850 
  if (ret < 0) {
    
#line 851 
    __retres = (_Bool)0;
    
#line 851 
    goto return_label;
  }
  else ;
  
#line 853 
  if (((unsigned long)fref_detection & 16UL) != 0UL) {
    
#line 854 
    __retres = (_Bool)0;
    
#line 854 
    goto return_label;
  }
  else ;
  
#line 856 
  __retres = (_Bool)1;
  return_label: 
#line 856 
                return __retres;
}


#line 859  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c"
static int wl128x_manually_configure_mcs_pll(struct wl1271 *wl)
{
  int ret;
  
#line 863 
  ret = wl12xx_top_reg_write(wl,3476,(unsigned short)200);
  
#line 864 
  if (ret < 0) 
#line 865 
               goto out; else ;
  
#line 867 
  ret = wl12xx_top_reg_write(wl,3478,(unsigned short)7);
  
#line 868 
  if (ret < 0) 
#line 869 
               goto out; else ;
  
#line 871 
  ret = wl12xx_top_reg_write(wl,3474,(unsigned short)115);
  out: 
#line 874 
  ;
  
#line 875 
  return ret;
}


#line 878  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c"
static int wl128x_configure_mcs_pll(struct wl1271 *wl, int clk)
{
  int __retres;
  u16 spare_reg;
  u16 pll_config;
  u8 input_freq;
  int ret;
  
#line 883 
  struct wl12xx_priv *priv = (struct wl12xx_priv *)wl->priv;
  
#line 887 
  ret = wl12xx_top_reg_read(wl,8992,& spare_reg);
  
#line 888 
  if (ret < 0) {
    
#line 889 
    __retres = ret;
    
#line 889 
    goto return_label;
  }
  else ;
  
#line 891 
  if ((unsigned int)spare_reg == 65535U) {
    
#line 892 
    __retres = -14;
    
#line 892 
    goto return_label;
  }
  else ;
  
#line 893 
  spare_reg = (unsigned short)((unsigned int)spare_reg | 4U);
  
#line 894 
  ret = wl12xx_top_reg_write(wl,8992,(unsigned short)((int)spare_reg));
  
#line 895 
  if (ret < 0) {
    
#line 896 
    __retres = ret;
    
#line 896 
    goto return_label;
  }
  else ;
  
#line 899 
  if ((unsigned int)priv->tcxo_clock + 4294967290U <= 1U) {
    int tmp;
    
#line 901 
    tmp = wl128x_manually_configure_mcs_pll(wl);
    
#line 901 
    __retres = tmp;
    
#line 901 
    goto return_label;
  }
  else ;
  
#line 904 
  input_freq = (unsigned char)(((unsigned int)((unsigned char)clk) & 1U) + 1U);
  
#line 906 
  ret = wl12xx_top_reg_read(wl,3474,& pll_config);
  
#line 907 
  if (ret < 0) {
    
#line 908 
    __retres = ret;
    
#line 908 
    goto return_label;
  }
  else ;
  
#line 910 
  if ((unsigned int)pll_config == 65535U) {
    
#line 911 
    __retres = -14;
    
#line 911 
    goto return_label;
  }
  else ;
  
#line 912 
  pll_config = (unsigned short)(((int)input_freq << 4) | (int)pll_config);
  
#line 913 
  pll_config = (unsigned short)((unsigned int)pll_config | 3U);
  
#line 914 
  ret = wl12xx_top_reg_write(wl,3474,(unsigned short)((int)pll_config));
  
#line 916 
  __retres = ret;
  return_label: 
#line 916 
                return __retres;
}


#line 926  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c"
static int wl128x_boot_clk(struct wl1271 *wl, int *selected_clock)
{
  int __retres;
  u16 sys_clk_cfg;
  int ret;
  int tmp_2;
  bool tmp_1;
  int tmp_4;
  bool tmp_3;
  int tmp_5;
  
#line 928 
  struct wl12xx_priv *priv = (struct wl12xx_priv *)wl->priv;
  
#line 933 
  if ((unsigned int)priv->ref_clock + 4294967292U <= 1U) {
    int tmp;
    
#line 935 
    tmp = wl128x_switch_tcxo_to_fref(wl);
    
#line 935 
    if (tmp == 0) {
      
#line 936 
      __retres = -22;
      
#line 936 
      goto return_label;
    }
    else ;
    
#line 937 
    goto fref_clk;
  }
  else ;
  
#line 941 
  ret = wl12xx_top_reg_read(wl,8704,& sys_clk_cfg);
  
#line 942 
  if (ret < 0) {
    
#line 943 
    __retres = ret;
    
#line 943 
    goto return_label;
  }
  else ;
  
#line 945 
  if ((unsigned int)sys_clk_cfg == 65535U) {
    
#line 946 
    __retres = -22;
    
#line 946 
    goto return_label;
  }
  else ;
  
#line 947 
  if (((unsigned long)sys_clk_cfg & 16UL) != 0UL) 
#line 948 
                                                  goto fref_clk; else ;
  
#line 951 
  if ((unsigned int)priv->tcxo_clock + 4294967292U <= 1U) {
    int tmp_0;
    
#line 953 
    tmp_0 = wl128x_switch_tcxo_to_fref(wl);
    
#line 953 
    if (tmp_0 == 0) {
      
#line 954 
      __retres = -22;
      
#line 954 
      goto return_label;
    }
    else ;
    
#line 955 
    goto fref_clk;
  }
  else ;
  
#line 959 
  tmp_1 = wl128x_is_tcxo_valid(wl);
  
#line 959 
  if (tmp_1) 
#line 959 
             tmp_2 = 0; else 
#line 959 
                             tmp_2 = 1;
  
#line 959 
  if (tmp_2) {
    
#line 960 
    __retres = -22;
    
#line 960 
    goto return_label;
  }
  else ;
  
#line 961 
  *selected_clock = priv->tcxo_clock;
  
#line 962 
  goto config_mcs_pll;
  fref_clk: 
#line 964 
  ;
  
#line 966 
  tmp_3 = wl128x_is_fref_valid(wl);
  
#line 966 
  if (tmp_3) 
#line 966 
             tmp_4 = 0; else 
#line 966 
                             tmp_4 = 1;
  
#line 966 
  if (tmp_4) {
    
#line 967 
    __retres = -22;
    
#line 967 
    goto return_label;
  }
  else ;
  
#line 968 
  *selected_clock = priv->ref_clock;
  config_mcs_pll: 
#line 970 
  ;
  
#line 971 
  tmp_5 = wl128x_configure_mcs_pll(wl,*selected_clock);
  
#line 971 
  __retres = tmp_5;
  return_label: 
#line 971 
                return __retres;
}


#line 974  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c"
static int wl127x_boot_clk(struct wl1271 *wl)
{
  int __retres;
  u32 pause;
  u32 clk;
  int ret;
  
#line 976 
  struct wl12xx_priv *priv = (struct wl12xx_priv *)wl->priv;
  
#line 981 
  if (((int)wl->hw_pg_ver & 3) <= 2) 
#line 982 
                                     wl->quirks |= 1U; else ;
  
#line 984 
  if ((priv->ref_clock == 0 || priv->ref_clock == 2) || priv->ref_clock == 4) 
    
#line 988 
    clk = 3U;
  else 
    
#line 989 
    if ((priv->ref_clock == 1 || priv->ref_clock == 5) || priv->ref_clock == 3) 
      
#line 993 
      clk = 5U;
    else {
      
#line 995 
      __retres = -22;
      
#line 995 
      goto return_label;
    }
  
#line 997 
  if (priv->ref_clock != 0) {
    u16 val;
    
#line 1000 
    ret = wl12xx_top_reg_read(wl,1096,& val);
    
#line 1001 
    if (ret < 0) 
#line 1002 
                 goto out; else ;
    
#line 1004 
    val = (unsigned short)((unsigned int)val & 65151U);
    
#line 1005 
    ret = wl12xx_top_reg_write(wl,1096,(unsigned short)((int)val));
    
#line 1006 
    if (ret < 0) 
#line 1007 
                 goto out; else ;
    
#line 1010 
    ret = wl12xx_top_reg_read(wl,3252,& val);
    
#line 1011 
    if (ret < 0) 
#line 1012 
                 goto out; else ;
    
#line 1014 
    val = (unsigned short)((unsigned int)val | 49152U);
    
#line 1015 
    ret = wl12xx_top_reg_write(wl,3252,(unsigned short)((int)val));
    
#line 1016 
    if (ret < 0) 
#line 1017 
                 goto out; else ;
  }
  else {
    u16 val_0;
    
#line 1021 
    ret = wl12xx_top_reg_read(wl,3250,& val_0);
    
#line 1022 
    if (ret < 0) 
#line 1023 
                 goto out; else ;
    
#line 1025 
    val_0 = (unsigned short)((unsigned int)val_0 & 63743U);
    
#line 1026 
    val_0 = (unsigned short)((unsigned int)val_0 | 1792U);
    
#line 1027 
    ret = wl12xx_top_reg_write(wl,3250,(unsigned short)((int)val_0));
    
#line 1028 
    if (ret < 0) 
#line 1029 
                 goto out; else ;
  }
  
#line 1032 
  ret = wlcore_write32(wl,3170368,clk);
  
#line 1033 
  if (ret < 0) 
#line 1034 
               goto out; else ;
  
#line 1036 
  ret = wlcore_read32(wl,3170368,& pause);
  
#line 1037 
  if (ret < 0) 
#line 1038 
               goto out; else ;
  
#line 1040 
  if ((long)((wl12xx_debug_level & 4U) != 0U) != 0L) {
    
#line 1040 
    struct _ddebug descriptor = {.modname = "wl12xx", .function = "wl127x_boot_clk", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c", .format = "wlcore", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1040U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1040 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 1040 
                                                        __dynamic_pr_debug(& descriptor,"wlcore",pause); else ;
  }
  else ;
  
#line 1042 
  pause &= 4294966272U;
  
#line 1043 
  pause |= 1023U;
  
#line 1044 
  ret = wlcore_write32(wl,3170312,pause);
  out: 
#line 1046 
  ;
  
#line 1047 
  __retres = ret;
  return_label: 
#line 1047 
                return __retres;
}


#line 1050  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c"
static int wl1271_boot_soft_reset(struct wl1271 *wl)
{
  int __retres;
  unsigned long timeout;
  u32 boot_data;
  unsigned long tmp;
  int tmp_0;
  
#line 1054 
  int ret = 0;
  
#line 1057 
  ret = wlcore_write32(wl,3145728,2U);
  
#line 1058 
  if (ret < 0) 
#line 1059 
               goto out; else ;
  
#line 1062 
  tmp = usecs_to_jiffies(1000000U);
  
#line 1062 
  timeout = tmp + jiffies;
  ldv_53531: 
#line 1063 
  ;
  
#line 1064 
  ret = wlcore_read32(wl,3145728,& boot_data);
  
#line 1065 
  if (ret < 0) 
#line 1066 
               goto out; else ;
  
#line 1068 
  if ((long)((wl12xx_debug_level & 4U) != 0U) != 0L) {
    
#line 1068 
    struct _ddebug descriptor = {.modname = "wl12xx", .function = "wl1271_boot_soft_reset", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c", .format = "wlcore", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1068U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1068 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 1068 
                                                        __dynamic_pr_debug(& descriptor,"wlcore",boot_data); else ;
  }
  else ;
  
#line 1069 
  if (((unsigned long)boot_data & 2UL) == 0UL) 
#line 1070 
                                               goto ldv_53524; else ;
  {
    unsigned long __dummy;
    unsigned long volatile __dummy2;
    
#line 1072 
    tmp_0 = 1;
  }
  
#line 1072 
  if (tmp_0 != 0) {
    int tmp_1;
    {
      unsigned long __dummy_0;
      unsigned long __dummy2_0;
      
#line 1072 
      tmp_1 = 1;
    }
    
#line 1072 
    if (tmp_1 != 0) {
      
#line 1072 
      if ((long)(timeout - jiffies) < 0L) {
        
#line 1075 
        printk("\001");
        
#line 1076 
        __retres = -1;
        
#line 1076 
        goto return_label;
      }
      else ;
    }
    else ;
  }
  else ;
  
#line 1079 
  __const_udelay(4295000UL);
  
#line 1064 
  goto ldv_53531;
  ldv_53524: 
#line 1065 
  ;
  
#line 1083 
  ret = wlcore_write32(wl,3167312,0U);
  
#line 1084 
  if (ret < 0) 
#line 1085 
               goto out; else ;
  
#line 1088 
  ret = wlcore_write32(wl,3148184,65535U);
  out: 
#line 1090 
  ;
  
#line 1091 
  __retres = ret;
  return_label: 
#line 1091 
                return __retres;
}


#line 1094  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c"
static int wl12xx_pre_boot(struct wl1271 *wl)
{
  u32 clk;
  
#line 1096 
  struct wl12xx_priv *priv = (struct wl12xx_priv *)wl->priv;
  
#line 1097 
  int ret = 0;
  
#line 1099 
  int selected_clock = -1;
  
#line 1101 
  if (wl->chip.id == 84082961U) {
    
#line 1102 
    ret = wl128x_boot_clk(wl,& selected_clock);
    
#line 1103 
    if (ret < 0) 
#line 1104 
                 goto out; else ;
  }
  else {
    
#line 1106 
    ret = wl127x_boot_clk(wl);
    
#line 1107 
    if (ret < 0) 
#line 1108 
                 goto out; else ;
  }
  
#line 1112 
  ret = wlcore_write32(wl,3170560,4U);
  
#line 1113 
  if (ret < 0) 
#line 1114 
               goto out; else ;
  
#line 1116 
  __const_udelay(2147500UL);
  
#line 1118 
  ret = wlcore_set_partition(wl,wl->ptable + 3U);
  
#line 1119 
  if (ret < 0) 
#line 1120 
               goto out; else ;
  
#line 1126 
  ret = wlcore_read32(wl,3211308,& clk);
  
#line 1127 
  if (ret < 0) 
#line 1128 
               goto out; else ;
  
#line 1130 
  if ((long)((wl12xx_debug_level & 4U) != 0U) != 0L) {
    
#line 1130 
    struct _ddebug descriptor = {.modname = "wl12xx", .function = "wl12xx_pre_boot", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c", .format = "wlcore", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1130U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1130 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 1130 
                                                        __dynamic_pr_debug(& descriptor,"wlcore",clk); else ;
  }
  else ;
  
#line 1132 
  if (wl->chip.id == 84082961U) 
#line 1133 
                                clk = ((unsigned int)(selected_clock << 5) & 96U) | clk; else 
                                                                    
#line 1135 
                                                                    clk = (unsigned int)(priv->ref_clock << 5) | clk;
  
#line 1137 
  ret = wlcore_write32(wl,3211308,clk);
  
#line 1138 
  if (ret < 0) 
#line 1139 
               goto out; else ;
  
#line 1141 
  ret = wlcore_set_partition(wl,wl->ptable + 1U);
  
#line 1142 
  if (ret < 0) 
#line 1143 
               goto out; else ;
  
#line 1146 
  ret = wlcore_write_reg(wl,6,4294967295U);
  
#line 1147 
  if (ret < 0) 
#line 1148 
               goto out; else ;
  
#line 1150 
  ret = wl1271_boot_soft_reset(wl);
  
#line 1151 
  if (ret < 0) 
#line 1152 
               goto out; else ;
  out: 
#line 1154 
  ;
  
#line 1155 
  return ret;
}


#line 1158  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c"
static int wl12xx_pre_upload(struct wl1271 *wl)
{
  u32 tmp;
  u16 polarity;
  int ret;
  
#line 1166 
  if ((long)((wl12xx_debug_level & 4U) != 0U) != 0L) {
    
#line 1166 
    struct _ddebug descriptor = {.modname = "wl12xx", .function = "wl12xx_pre_upload", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c", .format = "wlcore", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1166U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1166 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 1166 
                                                        __dynamic_pr_debug(& descriptor,"wlcore"); else ;
  }
  else ;
  
#line 1168 
  ret = wlcore_write32(wl,3167768,3167768U);
  
#line 1169 
  if (ret < 0) 
#line 1170 
               goto out; else ;
  
#line 1172 
  ret = wlcore_read_reg(wl,8,& tmp);
  
#line 1173 
  if (ret < 0) 
#line 1174 
               goto out; else ;
  
#line 1176 
  if ((long)((wl12xx_debug_level & 4U) != 0U) != 0L) {
    
#line 1176 
    struct _ddebug descriptor_0 = {.modname = "wl12xx", .function = "wl12xx_pre_upload", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c", .format = "wlcore", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1176U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1176 
    if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) 
#line 1176 
                                                          __dynamic_pr_debug(& descriptor_0,"wlcore",tmp); else ;
  }
  else ;
  
#line 1179 
  ret = wlcore_read32(wl,3167760,& tmp);
  
#line 1180 
  if (ret < 0) 
#line 1181 
               goto out; else ;
  
#line 1186 
  if (wl->chip.id == 84082961U) {
    
#line 1187 
    ret = wl12xx_top_reg_write(wl,3348,(unsigned short)2);
    
#line 1188 
    if (ret < 0) 
#line 1189 
                 goto out; else ;
  }
  else ;
  
#line 1193 
  ret = wl12xx_top_reg_read(wl,100,& polarity);
  
#line 1194 
  if (ret < 0) 
#line 1195 
               goto out; else ;
  
#line 1198 
  polarity = (unsigned short)((unsigned int)polarity & 65533U);
  
#line 1199 
  ret = wl12xx_top_reg_write(wl,100,(unsigned short)((int)polarity));
  out: 
#line 1201 
  ;
  
#line 1202 
  return ret;
}


#line 1205  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c"
static int wl12xx_enable_interrupts(struct wl1271 *wl)
{
  int __retres;
  int ret;
  
#line 1209 
  ret = wlcore_write_reg(wl,6,127U);
  
#line 1211 
  if (ret < 0) 
#line 1212 
               goto out; else ;
  
#line 1214 
  wlcore_enable_interrupts(wl);
  
#line 1215 
  ret = wlcore_write_reg(wl,6,4294967186U);
  
#line 1217 
  if (ret < 0) 
#line 1218 
               goto disable_interrupts; else ;
  
#line 1220 
  ret = wlcore_write32(wl,3147784,60U);
  
#line 1221 
  if (ret < 0) 
#line 1222 
               goto disable_interrupts; else ;
  
#line 1224 
  __retres = ret;
  
#line 1224 
  goto return_label;
  disable_interrupts: 
#line 1226 
  ;
  
#line 1227 
  wlcore_disable_interrupts(wl);
  out: 
#line 1229 
  ;
  
#line 1230 
  __retres = ret;
  return_label: 
#line 1230 
                return __retres;
}


#line 1233  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c"
static int wl12xx_boot(struct wl1271 *wl)
{
  int ret;
  
#line 1237 
  ret = wl12xx_pre_boot(wl);
  
#line 1238 
  if (ret < 0) 
#line 1239 
               goto out; else ;
  
#line 1241 
  ret = wlcore_boot_upload_nvs(wl);
  
#line 1242 
  if (ret < 0) 
#line 1243 
               goto out; else ;
  
#line 1245 
  ret = wl12xx_pre_upload(wl);
  
#line 1246 
  if (ret < 0) 
#line 1247 
               goto out; else ;
  
#line 1249 
  ret = wlcore_boot_upload_firmware(wl);
  
#line 1250 
  if (ret < 0) 
#line 1251 
               goto out; else ;
  
#line 1253 
  wl->event_mask = 4235117569U;
  
#line 1269 
  wl->ap_event_mask = 1048576U;
  
#line 1271 
  ret = wlcore_boot_run_firmware(wl);
  
#line 1272 
  if (ret < 0) 
#line 1273 
               goto out; else ;
  
#line 1275 
  ret = wl12xx_enable_interrupts(wl);
  out: 
#line 1277 
  ;
  
#line 1278 
  return ret;
}


#line 1281  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c"
static int wl12xx_trigger_cmd(struct wl1271 *wl, int cmd_box_addr, void *buf, size_t len)
{
  int __retres;
  int ret;
  
#line 1286 
  ret = wlcore_write(wl,cmd_box_addr,buf,len,(_Bool)0);
  
#line 1287 
  if (ret < 0) {
    
#line 1288 
    __retres = ret;
    
#line 1288 
    goto return_label;
  }
  else ;
  
#line 1290 
  ret = wlcore_write_reg(wl,5,1U);
  
#line 1292 
  __retres = ret;
  return_label: 
#line 1292 
                return __retres;
}


#line 1295  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c"
static int wl12xx_ack_event(struct wl1271 *wl)
{
  int tmp;
  
#line 1297 
  tmp = wlcore_write_reg(wl,5,2U);
  
#line 1297 
  return tmp;
}


#line 1301  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c"
static u32 wl12xx_calc_tx_blocks(struct wl1271 *wl, u32 len, u32 spare_blks)
{
  u32 __retres;
  
#line 1303 
  u32 blk_size = 252U;
  
#line 1304 
  u32 align_len = wlcore_calc_packet_alignment(wl,len);
  
#line 1306 
  __retres = ((align_len + blk_size) + 4294967295U) / blk_size + spare_blks;
  
#line 1306 
  return __retres;
}


#line 1310  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c"
static void wl12xx_set_tx_desc_blocks(struct wl1271 *wl, struct wl1271_tx_hw_descr *desc, u32 blks, u32 spare_blks)
{
  
#line 1313 
  if (wl->chip.id == 84082961U) 
#line 1314 
                                desc->__anonCompField_wl1271_tx_hw_descr_104.wl128x_mem.total_mem_blocks = (unsigned char)blks;
  else {
    
#line 1316 
    desc->__anonCompField_wl1271_tx_hw_descr_104.wl127x_mem.extra_blocks = (unsigned char)spare_blks;
    
#line 1317 
    desc->__anonCompField_wl1271_tx_hw_descr_104.wl127x_mem.total_mem_blocks = (unsigned char)blks;
  }
  
#line 1319 
  return;
}


#line 1322  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c"
static void wl12xx_set_tx_desc_data_len(struct wl1271 *wl, struct wl1271_tx_hw_descr *desc, struct sk_buff *skb)
{
  
#line 1325 
  u32 aligned_len = wlcore_calc_packet_alignment(wl,skb->len);
  
#line 1327 
  if (wl->chip.id == 84082961U) {
    
#line 1328 
    desc->__anonCompField_wl1271_tx_hw_descr_104.wl128x_mem.extra_bytes = (unsigned char)((int)((unsigned char)aligned_len) - (int)((unsigned char)skb->len));
    
#line 1329 
    desc->length = (unsigned short)(aligned_len >> 2);
    
#line 1331 
    if ((long)((wl12xx_debug_level & 64U) != 0U) != 0L) {
      
#line 1331 
      struct _ddebug descriptor = {.modname = "wl12xx", .function = "wl12xx_set_tx_desc_data_len", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c", .format = "wlcore", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1337U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 1331 
      if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 1331 
                                                          __dynamic_pr_debug(& descriptor,"wlcore",(int)desc->hlid,(int)desc->length,(int)desc->life_time,(int)desc->__anonCompField_wl1271_tx_hw_descr_104.wl128x_mem.total_mem_blocks,(int)desc->__anonCompField_wl1271_tx_hw_descr_104.wl128x_mem.extra_bytes); else ;
    }
    else ;
  }
  else {
    
#line 1340 
    int pad = (int)(aligned_len - skb->len);
    
#line 1341 
    desc->tx_attr = (unsigned short)((int)desc->tx_attr | ((int)((unsigned short)pad) << 10U));
    
#line 1345 
    desc->length = (unsigned short)(aligned_len >> 2);
    
#line 1347 
    if ((long)((wl12xx_debug_level & 64U) != 0U) != 0L) {
      
#line 1347 
      struct _ddebug descriptor_0 = {.modname = "wl12xx", .function = "wl12xx_set_tx_desc_data_len", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c", .format = "wlcore", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1352U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 1347 
      if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) 
#line 1347 
                                                            __dynamic_pr_debug(& descriptor_0,"wlcore",pad,(int)desc->hlid,(int)desc->length,(int)desc->life_time,(int)desc->__anonCompField_wl1271_tx_hw_descr_104.wl127x_mem.total_mem_blocks); else ;
    }
    else ;
  }
  
#line 1350 
  return;
}


#line 1357  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c"
static int wl12xx_get_rx_buf_align(struct wl1271 *wl, u32 rx_desc)
{
  int __retres;
  
#line 1359 
  if (((unsigned long)rx_desc & 1048576UL) != 0UL) {
    
#line 1360 
    __retres = 1;
    
#line 1360 
    goto return_label;
  }
  else ;
  
#line 1362 
  __retres = 0;
  return_label: 
#line 1362 
                return __retres;
}


#line 1365  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c"
static u32 wl12xx_get_rx_packet_len(struct wl1271 *wl, void *rx_data, u32 data_len)
{
  u32 __retres;
  
#line 1368 
  struct wl1271_rx_descriptor *desc = (struct wl1271_rx_descriptor *)rx_data;
  
#line 1371 
  if (data_len <= 15U || (unsigned long)data_len < (unsigned long)desc->pad_len + 16UL) {
    
#line 1373 
    __retres = 0U;
    
#line 1373 
    goto return_label;
  }
  else ;
  
#line 1375 
  __retres = (data_len - (unsigned int)desc->pad_len) + 4294967280U;
  return_label: 
#line 1375 
                return __retres;
}


#line 1378  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c"
static int wl12xx_tx_delayed_compl(struct wl1271 *wl)
{
  int __retres;
  int tmp;
  
#line 1380 
  if ((unsigned int)(wl->fw_status)->tx_results_counter == (wl->tx_results_count & 255U)) {
    
#line 1382 
    __retres = 0;
    
#line 1382 
    goto return_label;
  }
  else ;
  
#line 1384 
  tmp = wlcore_tx_complete(wl);
  
#line 1384 
  __retres = tmp;
  return_label: 
#line 1384 
                return __retres;
}


#line 1387  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c"
static int wl12xx_hw_init(struct wl1271 *wl)
{
  int ret;
  
#line 1391 
  if (wl->chip.id == 84082961U) {
    
#line 1392 
    u32 host_cfg_bitmap = 1U;
    
#line 1394 
    ret = wl128x_cmd_general_parms(wl);
    
#line 1395 
    if (ret < 0) 
#line 1396 
                 goto out; else ;
    
#line 1402 
    if (wl->plt_mode == (unsigned int)PLT_FEM_DETECT) 
#line 1403 
                                                      goto out; else ;
    
#line 1405 
    ret = wl128x_cmd_radio_parms(wl);
    
#line 1406 
    if (ret < 0) 
#line 1407 
                 goto out; else ;
    
#line 1409 
    if (((unsigned long)wl->quirks & 4UL) != 0UL) 
#line 1411 
                                                  host_cfg_bitmap |= 8U; else ;
    
#line 1414 
    ret = wl1271_acx_host_if_cfg_bitmap(wl,host_cfg_bitmap);
    
#line 1415 
    if (ret < 0) 
#line 1416 
                 goto out; else ;
  }
  else {
    
#line 1418 
    ret = wl1271_cmd_general_parms(wl);
    
#line 1419 
    if (ret < 0) 
#line 1420 
                 goto out; else ;
    
#line 1426 
    if (wl->plt_mode == (unsigned int)PLT_FEM_DETECT) 
#line 1427 
                                                      goto out; else ;
    
#line 1429 
    ret = wl1271_cmd_radio_parms(wl);
    
#line 1430 
    if (ret < 0) 
#line 1431 
                 goto out; else ;
    
#line 1432 
    ret = wl1271_cmd_ext_radio_parms(wl);
    
#line 1433 
    if (ret < 0) 
#line 1434 
                 goto out; else ;
  }
  out: 
#line 1436 
  ;
  
#line 1437 
  return ret;
}


#line 1440  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c"
static void wl12xx_convert_fw_status(struct wl1271 *wl, void *raw_fw_status, struct wl_fw_status *fw_status)
{
  
#line 1443 
  struct wl12xx_fw_status *int_fw_status = (struct wl12xx_fw_status *)raw_fw_status;
  
#line 1445 
  fw_status->intr = int_fw_status->intr;
  
#line 1446 
  fw_status->fw_rx_counter = int_fw_status->fw_rx_counter;
  
#line 1447 
  fw_status->drv_rx_counter = int_fw_status->drv_rx_counter;
  
#line 1448 
  fw_status->tx_results_counter = int_fw_status->tx_results_counter;
  
#line 1449 
  fw_status->rx_pkt_descs = (__le32 *)(& int_fw_status->rx_pkt_descs);
  
#line 1451 
  fw_status->fw_localtime = int_fw_status->fw_localtime;
  
#line 1452 
  fw_status->link_ps_bitmap = int_fw_status->link_ps_bitmap;
  
#line 1453 
  fw_status->link_fast_bitmap = int_fw_status->link_fast_bitmap;
  
#line 1455 
  fw_status->total_released_blks = int_fw_status->total_released_blks;
  
#line 1457 
  fw_status->tx_total = int_fw_status->tx_total;
  
#line 1459 
  fw_status->counters.tx_released_pkts = (u8 *)(& int_fw_status->counters.tx_released_pkts);
  
#line 1461 
  fw_status->counters.tx_lnk_free_pkts = (u8 *)(& int_fw_status->counters.tx_lnk_free_pkts);
  
#line 1463 
  fw_status->counters.tx_voice_released_blks = int_fw_status->counters.tx_voice_released_blks;
  
#line 1465 
  fw_status->counters.tx_last_rate = int_fw_status->counters.tx_last_rate;
  
#line 1468 
  fw_status->log_start_addr = int_fw_status->log_start_addr;
  
#line 1469 
  return;
}


#line 1471  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c"
static u32 wl12xx_sta_get_ap_rate_mask(struct wl1271 *wl, struct wl12xx_vif *wlvif)
{
  u32 __retres;
  
#line 1474 
  __retres = wlvif->rate_set;
  
#line 1474 
  return __retres;
}


#line 1477  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c"
static void wl12xx_conf_init(struct wl1271 *wl)
{
  
#line 1479 
  struct wl12xx_priv *priv = (struct wl12xx_priv *)wl->priv;
  
#line 1482 
  memcpy((void *)(& wl->conf),(void const *)(& wl12xx_conf),921UL);
  
#line 1485 
  memcpy((void *)(& priv->conf),(void const *)(& wl12xx_default_priv_conf),33UL);
  
#line 1486 
  return;
}


#line 1488  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c"
static bool wl12xx_mac_in_fuse(struct wl1271 *wl)
{
  u8 major;
  u8 minor;
  
#line 1490 
  bool supported = (_Bool)0;
  
#line 1493 
  if (wl->chip.id == 84082961U) {
    
#line 1494 
    major = (unsigned char)((unsigned int)((unsigned char)((int)wl->hw_pg_ver >> 2)) & 3U);
    
#line 1495 
    minor = (unsigned char)((unsigned int)((unsigned char)wl->hw_pg_ver) & 3U);
    
#line 1498 
    if ((unsigned int)major > 2U || ((unsigned int)major == 2U && (unsigned int)minor != 0U)) 
      
#line 1499 
      supported = (_Bool)1; else ;
  }
  else {
    
#line 1501 
    major = (unsigned char)((unsigned int)((unsigned char)wl->hw_pg_ver) & 3U);
    
#line 1502 
    minor = (unsigned char)((unsigned int)((unsigned char)((int)wl->hw_pg_ver >> 2)) & 3U);
    
#line 1505 
    if ((unsigned int)major == 3U && (unsigned int)minor != 0U) 
#line 1506 
                                                                supported = (_Bool)1; else ;
  }
  
#line 1509 
  if ((long)((wl12xx_debug_level & 262144U) != 0U) != 0L) {
    
#line 1509 
    struct _ddebug descriptor = {.modname = "wl12xx", .function = "wl12xx_mac_in_fuse", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c", .format = "wlcore", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1511U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1509 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
      char *tmp;
      
#line 1509 
      if ((int)supported != 0) 
#line 1509 
                               tmp = (char *)"is"; else 
#line 1509 
                                                        tmp = (char *)"is not";
      
#line 1509 
      ;
      
#line 1509 
      ;
      
#line 1509 
      __dynamic_pr_debug(& descriptor,"wlcore",(int)major,(int)minor,tmp);
    }
    else ;
  }
  else ;
  
#line 1513 
  return supported;
}


#line 1516  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c"
static int wl12xx_get_fuse_mac(struct wl1271 *wl)
{
  u32 mac1;
  u32 mac2;
  int ret;
  
#line 1521 
  ret = wlcore_set_partition(wl,wl->ptable + 3U);
  
#line 1522 
  if (ret < 0) 
#line 1523 
               goto out; else ;
  
#line 1525 
  ret = wlcore_read32(wl,3215028,& mac1);
  
#line 1526 
  if (ret < 0) 
#line 1527 
               goto out; else ;
  
#line 1529 
  ret = wlcore_read32(wl,3215032,& mac2);
  
#line 1530 
  if (ret < 0) 
#line 1531 
               goto out; else ;
  
#line 1534 
  wl->fuse_oui_addr = ((mac2 << 8) & 16776960U) + (mac1 >> 24);
  
#line 1536 
  wl->fuse_nic_addr = mac1 & 16777215U;
  
#line 1538 
  ret = wlcore_set_partition(wl,wl->ptable);
  out: 
#line 1540 
  ;
  
#line 1541 
  return ret;
}


#line 1544  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c"
static int wl12xx_get_pg_ver(struct wl1271 *wl, s8 *ver)
{
  u16 die_info;
  int ret;
  
#line 1549 
  if (wl->chip.id == 84082961U) 
#line 1550 
                                ret = wl12xx_top_reg_read(wl,8530,& die_info); else 
                                                                    
#line 1553 
                                                                    ret = wl12xx_top_reg_read(wl,1290,& die_info);
  
#line 1556 
  if (ret >= 0 && ver != (s8 *)0) 
#line 1557 
                                  *ver = (signed char)((int)((signed char)((int)die_info >> 2)) & 15); else ;
  
#line 1559 
  return ret;
}


#line 1562  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c"
static int wl12xx_get_mac(struct wl1271 *wl)
{
  int __retres;
  bool tmp_0;
  
#line 1564 
  tmp_0 = wl12xx_mac_in_fuse(wl);
  
#line 1564 
  if ((int)tmp_0 != 0) {
    int tmp;
    
#line 1565 
    tmp = wl12xx_get_fuse_mac(wl);
    
#line 1565 
    __retres = tmp;
    
#line 1565 
    goto return_label;
  }
  else ;
  
#line 1567 
  __retres = 0;
  return_label: 
#line 1567 
                return __retres;
}


#line 1570  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c"
static void wl12xx_set_tx_desc_csum(struct wl1271 *wl, struct wl1271_tx_hw_descr *desc, struct sk_buff *skb)
{
  
#line 1574 
  desc->__anonCompField_wl1271_tx_hw_descr_105.wl12xx_reserved = (unsigned char)0U;
  
#line 1575 
  return;
}


#line 1577  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c"
static int wl12xx_plt_init(struct wl1271 *wl)
{
  int ret;
  
#line 1581 
  ret = (*((wl->ops)->boot))(wl);
  
#line 1582 
  if (ret < 0) 
#line 1583 
               goto out; else ;
  
#line 1585 
  ret = (*((wl->ops)->hw_init))(wl);
  
#line 1586 
  if (ret < 0) 
#line 1587 
               goto out_irq_disable; else ;
  
#line 1593 
  if (wl->plt_mode == (unsigned int)PLT_FEM_DETECT) 
#line 1594 
                                                    goto out; else ;
  
#line 1596 
  ret = wl1271_acx_init_mem_config(wl);
  
#line 1597 
  if (ret < 0) 
#line 1598 
               goto out_irq_disable; else ;
  
#line 1600 
  ret = wl12xx_acx_mem_cfg(wl);
  
#line 1601 
  if (ret < 0) 
#line 1602 
               goto out_free_memmap; else ;
  
#line 1605 
  ret = wl1271_cmd_data_path(wl,(_Bool)1);
  
#line 1606 
  if (ret < 0) 
#line 1607 
               goto out_free_memmap; else ;
  
#line 1610 
  ret = wl1271_acx_sleep_auth(wl,(unsigned char)0);
  
#line 1611 
  if (ret < 0) 
#line 1612 
               goto out_free_memmap; else ;
  
#line 1615 
  ret = wl1271_acx_pm_config(wl);
  
#line 1616 
  if (ret < 0) 
#line 1617 
               goto out_free_memmap; else ;
  
#line 1619 
  goto out;
  out_free_memmap: 
#line 1621 
  ;
  
#line 1622 
  kfree((void const *)wl->target_mem_map);
  
#line 1623 
  wl->target_mem_map = (struct wl1271_acx_mem_map *)0;
  out_irq_disable: 
#line 1625 
  ;
  
#line 1626 
  ldv_mutex_unlock_72(& wl->mutex);
  
#line 1634 
  wlcore_disable_interrupts(wl);
  
#line 1635 
  ldv_mutex_lock_73(& wl->mutex);
  out: 
#line 1636 
  ;
  
#line 1637 
  return ret;
}


#line 1640  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c"
static int wl12xx_get_spare_blocks(struct wl1271 *wl, bool is_gem)
{
  int __retres;
  
#line 1642 
  if ((int)is_gem != 0) {
    
#line 1643 
    __retres = 2;
    
#line 1643 
    goto return_label;
  }
  else ;
  
#line 1645 
  __retres = 1;
  return_label: 
#line 1645 
                return __retres;
}


#line 1648  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c"
static int wl12xx_set_key(struct wl1271 *wl, enum set_key_cmd cmd, struct ieee80211_vif *vif, struct ieee80211_sta *sta, struct ieee80211_key_conf *key_conf)
{
  int tmp;
  
#line 1653 
  tmp = wlcore_set_key(wl,cmd,vif,sta,key_conf);
  
#line 1653 
  return tmp;
}


#line 1656  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c"
static int wl12xx_set_peer_cap(struct wl1271 *wl, struct ieee80211_sta_ht_cap *ht_cap, bool allow_ht_operation, u32 rate_set, u8 hlid)
{
  int tmp;
  
#line 1661 
  tmp = wl1271_acx_set_ht_capabilities(wl,ht_cap,(_Bool)((bool)((int)allow_ht_operation) != 0),(unsigned char)((int)hlid));
  
#line 1661 
  return tmp;
}


#line 1665  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c"
static bool wl12xx_lnk_high_prio(struct wl1271 *wl, u8 hlid, struct wl1271_link *lnk)
{
  bool __retres;
  u8 thold;
  int tmp_1;
  
#line 1670 
  if (0 != 0) {
    int tmp;
    
#line 1670 
    tmp = constant_test_bit((long)hlid,(unsigned long const volatile *)(& wl->fw_fast_lnk_map));
    
#line 1670 
    tmp_1 = tmp != 0;
  }
  else {
    int tmp_0;
    
#line 1670 
    tmp_0 = variable_test_bit((long)hlid,(unsigned long const volatile *)(& wl->fw_fast_lnk_map));
    
#line 1670 
    tmp_1 = tmp_0 != 0;
  }
  
#line 1670 
  if (tmp_1) 
#line 1671 
             thold = wl->conf.tx.fast_link_thold; else 
#line 1673 
                                                       thold = wl->conf.tx.slow_link_thold;
  
#line 1675 
  __retres = (_Bool)((int)lnk->allocated_pkts < (int)thold);
  
#line 1675 
  return __retres;
}


#line 1678  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c"
static bool wl12xx_lnk_low_prio(struct wl1271 *wl, u8 hlid, struct wl1271_link *lnk)
{
  bool __retres;
  
#line 1682 
  __retres = (_Bool)1;
  
#line 1682 
  return __retres;
}


#line 1685  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c"
static u32 wl12xx_convert_hwaddr(struct wl1271 *wl, u32 hwaddr)
{
  u32 __retres;
  
#line 1687 
  __retres = hwaddr << 5;
  
#line 1687 
  return __retres;
}


#line 1690 
static int wl12xx_setup(struct wl1271 *wl);


#line 1692  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c"
static struct wlcore_ops wl12xx_ops = {.setup = & wl12xx_setup, .identify_chip = & wl12xx_identify_chip, .identify_fw = (int (*)(struct wl1271 *))0, .boot = & wl12xx_boot, .plt_init = & wl12xx_plt_init, .trigger_cmd = & wl12xx_trigger_cmd, .ack_event = & wl12xx_ack_event, .wait_for_event = & wl12xx_wait_for_event, .process_mailbox_events = & wl12xx_process_mailbox_events, .calc_tx_blocks = & wl12xx_calc_tx_blocks, .set_tx_desc_blocks = & wl12xx_set_tx_desc_blocks, .set_tx_desc_data_len = & wl12xx_set_tx_desc_data_len, .get_rx_buf_align = & wl12xx_get_rx_buf_align, .prepare_read = (int (*)(struct wl1271 *, u32 , u32 ))0, .get_rx_packet_len = & wl12xx_get_rx_packet_len, .tx_delayed_compl = & wl12xx_tx_delayed_compl, .tx_immediate_compl = (void (*)(struct wl1271 *))0, .hw_init = & wl12xx_hw_init, .init_vif = (int (*)(struct wl1271 *, struct wl12xx_vif *))0, .convert_fw_status = & wl12xx_convert_fw_status, .sta_get_ap_rate_mask = & wl12xx_sta_get_ap_rate_mask, .get_pg_ver = & wl12xx_get_pg_ver, .get_mac = & wl12xx_get_mac, .set_tx_desc_csum = & wl12xx_set_tx_desc_csum, .set_rx_csum = (void (*)(struct wl1271 *, struct wl1271_rx_descriptor *, struct sk_buff *))0, .ap_get_mimo_wide_rate_mask = (u32 (*)(struct wl1271 *, struct wl12xx_vif *))0, .debugfs_init = & wl12xx_debugfs_add_files, .handle_static_data = (int (*)(struct wl1271 *, struct wl1271_static_data *))0, .scan_start = & wl12xx_scan_start, .scan_stop = & wl12xx_scan_stop, .sched_scan_start = & wl12xx_sched_scan_start, .sched_scan_stop = & wl12xx_scan_sched_scan_stop, .get_spare_blocks = & wl12xx_get_spare_blocks, .set_key = & wl12xx_set_key, .channel_switch = & wl12xx_cmd_channel_switch, .pre_pkt_send = (u32 (*)(struct wl1271 *, u32 , u32 ))0, .sta_rc_update = (void (*)(struct wl1271 *, struct wl12xx_vif *))0, .set_peer_cap = & wl12xx_set_peer_cap, .convert_hwaddr = & wl12xx_convert_hwaddr, .lnk_high_prio = & wl12xx_lnk_high_prio, .lnk_low_prio = & wl12xx_lnk_low_prio, .interrupt_notify = (int (*)(struct wl1271 *, bool ))0, .rx_ba_filter = (int (*)(struct wl1271 *, bool ))0, .ap_sleep = (int (*)(struct wl1271 *))0, .smart_config_start = (int (*)(struct wl1271 *, u32 ))0, .smart_config_stop = (int (*)(struct wl1271 *))0, .smart_config_set_group_key = (int (*)(struct wl1271 *, u16 , u8 , u8 *))0, .set_cac = (int (*)(struct wl1271 *, struct wl12xx_vif *, bool ))0, .dfs_master_restart = (int (*)(struct wl1271 *, struct wl12xx_vif *))0};

#line 1735  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c"
static struct ieee80211_sta_ht_cap wl12xx_ht_cap = {.cap = (unsigned short)304U, .ht_supported = (_Bool)1, .ampdu_factor = (unsigned char)0U, .ampdu_density = (unsigned char)6U, .mcs = {.rx_mask = {(unsigned char)255U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U}, .rx_highest = (unsigned short)72U, .tx_params = (unsigned char)1U, .reserved = {(unsigned char)0, (unsigned char)0, (unsigned char)0}}};

#line 1748  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c"
static struct ieee80211_iface_limit const wl12xx_iface_limits[2U] = {{.max = (unsigned short)3U, .types = (unsigned short)4U}, {.max = (unsigned short)1U, .types = (unsigned short)776U}};

#line 1762  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c"
static struct ieee80211_iface_combination const wl12xx_iface_combinations[1U] = {{.limits = (struct ieee80211_iface_limit const *)(& wl12xx_iface_limits), .num_different_channels = 1U, .max_interfaces = (unsigned short)3U, .n_limits = (unsigned char)2U, .beacon_int_infra_match = (_Bool)0, .radar_detect_widths = (unsigned char)0, .radar_detect_regions = (unsigned char)0}};

#line 1771  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c"
static struct wl12xx_clock const wl12xx_refclock_table[7U] = {{.freq = 19200000U, .xtal = (_Bool)0, .hw_idx = (unsigned char)0U}, {.freq = 26000000U, .xtal = (_Bool)0, .hw_idx = (unsigned char)1U}, {.freq = 26000000U, .xtal = (_Bool)1, .hw_idx = (unsigned char)5U}, {.freq = 38400000U, .xtal = (_Bool)0, .hw_idx = (unsigned char)2U}, {.freq = 38400000U, .xtal = (_Bool)1, .hw_idx = (unsigned char)4U}, {.freq = 52000000U, .xtal = (_Bool)0, .hw_idx = (unsigned char)3U}, {.freq = 0U, .xtal = (_Bool)0, .hw_idx = (unsigned char)0U}};

#line 1781  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c"
static struct wl12xx_clock const wl12xx_tcxoclock_table[9U] = {{.freq = 16368000U, .xtal = (_Bool)1, .hw_idx = (unsigned char)4U}, {.freq = 16800000U, .xtal = (_Bool)1, .hw_idx = (unsigned char)6U}, {.freq = 19200000U, .xtal = (_Bool)1, .hw_idx = (unsigned char)0U}, {.freq = 26000000U, .xtal = (_Bool)1, .hw_idx = (unsigned char)1U}, {.freq = 32736000U, .xtal = (_Bool)1, .hw_idx = (unsigned char)5U}, {.freq = 33600000U, .xtal = (_Bool)1, .hw_idx = (unsigned char)7U}, {.freq = 38400000U, .xtal = (_Bool)1, .hw_idx = (unsigned char)2U}, {.freq = 52000000U, .xtal = (_Bool)1, .hw_idx = (unsigned char)3U}, {.freq = 0U, .xtal = (_Bool)0, .hw_idx = (unsigned char)0U}};

#line 1793  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c"
static int wl12xx_get_clock_idx(struct wl12xx_clock const *table, u32 freq, bool xtal)
{
  int __retres;
  int i;
  
#line 1798 
  i = 0;
  
#line 1798 
  goto ldv_53716;
  ldv_53715: 
#line 1799 
  ;
  
#line 1799 
  if ((table + i)->freq == freq && (int)(table + i)->xtal == (xtal != 0)) {
    
#line 1800 
    __retres = (int)(table + i)->hw_idx;
    
#line 1800 
    goto return_label;
  }
  else ;
  
#line 1798 
  i += 1;
  ldv_53716: 
#line 1799 
  ;
  
#line 1798 
  if ((table + i)->freq != 0U) 
#line 1800 
                               goto ldv_53715; else 
#line 1803 
                                                    goto ldv_53717;
  ldv_53717: 
#line 1804 
  ;
  
#line 1802 
  __retres = -22;
  return_label: 
#line 1802 
                return __retres;
}


#line 1810 
void __compiletime_assert_1810(void);


#line 1811 
void __compiletime_assert_1811(void);


#line 1805  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c"
static int wl12xx_setup(struct wl1271 *wl)
{
  int __retres;
  
#line 1807 
  struct wl12xx_priv *priv = (struct wl12xx_priv *)wl->priv;
  
#line 1808 
  struct wlcore_platdev_data *pdev_data = dev_get_platdata((struct device const *)(& (wl->pdev)->dev));
  {
    
#line 1810 
    bool __cond = (_Bool)0;
    
#line 1810 
    if ((int)__cond != 0) 
#line 1810 
                          __compiletime_assert_1810(); else ;
  }
  {
    
#line 1811 
    bool __cond_0 = (_Bool)0;
    
#line 1811 
    if ((int)__cond_0 != 0) 
#line 1811 
                            __compiletime_assert_1811(); else ;
  }
  
#line 1813 
  wl->rtable = (int const *)(& wl12xx_rtable);
  
#line 1814 
  wl->num_tx_desc = 16U;
  
#line 1815 
  wl->num_rx_desc = 8U;
  
#line 1816 
  wl->num_links = (unsigned char)12U;
  
#line 1817 
  wl->max_ap_stations = (unsigned char)8U;
  
#line 1818 
  wl->iface_combinations = (struct ieee80211_iface_combination const *)(& wl12xx_iface_combinations);
  
#line 1819 
  wl->n_iface_combinations = (unsigned char)1U;
  
#line 1820 
  wl->num_mac_addr = 2;
  
#line 1821 
  wl->band_rate_to_idx = (u8 const **)(& wl12xx_band_rate_to_idx);
  
#line 1822 
  wl->hw_tx_rate_tbl_size = (unsigned char)22U;
  
#line 1823 
  wl->hw_min_ht_rate = (unsigned char)8U;
  
#line 1824 
  wl->fw_status_len = 84UL;
  
#line 1825 
  wl->fw_status_priv_len = 0UL;
  
#line 1826 
  wl->stats.fw_stats_len = 364UL;
  
#line 1827 
  wl->ofdm_only_ap = (_Bool)1;
  
#line 1828 
  wlcore_set_ht_cap(wl,(enum ieee80211_band)IEEE80211_BAND_2GHZ,& wl12xx_ht_cap);
  
#line 1829 
  wlcore_set_ht_cap(wl,(enum ieee80211_band)IEEE80211_BAND_5GHZ,& wl12xx_ht_cap);
  
#line 1830 
  wl12xx_conf_init(wl);
  
#line 1832 
  if (fref_param == (char *)0) {
    
#line 1833 
    priv->ref_clock = wl12xx_get_clock_idx((struct wl12xx_clock const *)(& wl12xx_refclock_table),pdev_data->ref_clock_freq,(_Bool)((bool)((int)pdev_data->ref_clock_xtal) != 0));
    
#line 1836 
    if (priv->ref_clock < 0) {
      char *tmp_0;
      
#line 1837 
      if ((int)pdev_data->ref_clock_xtal != 0) 
#line 1837 
                                               tmp_0 = (char *)"XTAL"; else 
                                                                    
#line 1837 
                                                                    tmp_0 = (char *)"not XTAL";
      
#line 1837 
      ;
      
#line 1837 
      printk("\001",pdev_data->ref_clock_freq,tmp_0);
      
#line 1842 
      __retres = priv->ref_clock;
      
#line 1842 
      goto return_label;
    }
    else ;
  }
  else {
    int tmp_6;
    
#line 1845 
    tmp_6 = strcmp((char const *)fref_param,"19.2");
    
#line 1845 
    if (tmp_6 == 0) 
#line 1846 
                    priv->ref_clock = 0;
    else {
      int tmp_5;
      
#line 1847 
      tmp_5 = strcmp((char const *)fref_param,"26");
      
#line 1847 
      if (tmp_5 == 0) 
#line 1848 
                      priv->ref_clock = 1;
      else {
        int tmp_4;
        
#line 1849 
        tmp_4 = strcmp((char const *)fref_param,"26x");
        
#line 1849 
        if (tmp_4 == 0) 
#line 1850 
                        priv->ref_clock = 5;
        else {
          int tmp_3;
          
#line 1851 
          tmp_3 = strcmp((char const *)fref_param,"38.4");
          
#line 1851 
          if (tmp_3 == 0) 
#line 1852 
                          priv->ref_clock = 2;
          else {
            int tmp_2;
            
#line 1853 
            tmp_2 = strcmp((char const *)fref_param,"38.4x");
            
#line 1853 
            if (tmp_2 == 0) 
#line 1854 
                            priv->ref_clock = 4;
            else {
              int tmp_1;
              
#line 1855 
              tmp_1 = strcmp((char const *)fref_param,"52");
              
#line 1855 
              if (tmp_1 == 0) 
#line 1856 
                              priv->ref_clock = 3; else 
#line 1858 
                                                        printk("\001",fref_param);
            }
          }
        }
      }
    }
  }
  
#line 1861 
  if (tcxo_param == (char *)0 && pdev_data->tcxo_clock_freq != 0U) {
    
#line 1862 
    priv->tcxo_clock = wl12xx_get_clock_idx((struct wl12xx_clock const *)(& wl12xx_tcxoclock_table),pdev_data->tcxo_clock_freq,(_Bool)1);
    
#line 1865 
    if (priv->tcxo_clock < 0) {
      
#line 1866 
      printk("\001",pdev_data->tcxo_clock_freq);
      
#line 1869 
      __retres = priv->tcxo_clock;
      
#line 1869 
      goto return_label;
    }
    else ;
  }
  else 
    
#line 1871 
    if (tcxo_param != (char *)0) {
      int tmp_14;
      
#line 1872 
      tmp_14 = strcmp((char const *)tcxo_param,"19.2");
      
#line 1872 
      if (tmp_14 == 0) 
#line 1873 
                       priv->tcxo_clock = 0;
      else {
        int tmp_13;
        
#line 1874 
        tmp_13 = strcmp((char const *)tcxo_param,"26");
        
#line 1874 
        if (tmp_13 == 0) 
#line 1875 
                         priv->tcxo_clock = 1;
        else {
          int tmp_12;
          
#line 1876 
          tmp_12 = strcmp((char const *)tcxo_param,"38.4");
          
#line 1876 
          if (tmp_12 == 0) 
#line 1877 
                           priv->tcxo_clock = 2;
          else {
            int tmp_11;
            
#line 1878 
            tmp_11 = strcmp((char const *)tcxo_param,"52");
            
#line 1878 
            if (tmp_11 == 0) 
#line 1879 
                             priv->tcxo_clock = 3;
            else {
              int tmp_10;
              
#line 1880 
              tmp_10 = strcmp((char const *)tcxo_param,"16.368");
              
#line 1880 
              if (tmp_10 == 0) 
#line 1881 
                               priv->tcxo_clock = 4;
              else {
                int tmp_9;
                
#line 1882 
                tmp_9 = strcmp((char const *)tcxo_param,"32.736");
                
#line 1882 
                if (tmp_9 == 0) 
#line 1883 
                                priv->tcxo_clock = 5;
                else {
                  int tmp_8;
                  
#line 1884 
                  tmp_8 = strcmp((char const *)tcxo_param,"16.8");
                  
#line 1884 
                  if (tmp_8 == 0) 
#line 1885 
                                  priv->tcxo_clock = 6;
                  else {
                    int tmp_7;
                    
#line 1886 
                    tmp_7 = strcmp((char const *)tcxo_param,"33.6");
                    
#line 1886 
                    if (tmp_7 == 0) 
#line 1887 
                                    priv->tcxo_clock = 7; else 
#line 1889 
                                                               printk("\001",tcxo_param);
                  }
                }
              }
            }
          }
        }
      }
    }
    else ;
  
#line 1892 
  priv->rx_mem_addr = (struct wl127x_rx_mem_pool_addr *)kmalloc(8UL,208U);
  
#line 1893 
  if (priv->rx_mem_addr == (struct wl127x_rx_mem_pool_addr *)0) {
    
#line 1894 
    __retres = -12;
    
#line 1894 
    goto return_label;
  }
  else ;
  
#line 1896 
  __retres = 0;
  return_label: 
#line 1896 
                return __retres;
}


#line 1899  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c"
static int wl12xx_probe(struct platform_device *pdev)
{
  int __retres;
  struct wl1271 *wl;
  struct ieee80211_hw *hw;
  int ret;
  bool tmp_0;
  
#line 1905 
  hw = wlcore_alloc_hw(56UL,16384U,64U);
  
#line 1908 
  tmp_0 = IS_ERR((void const *)hw);
  
#line 1908 
  if ((int)tmp_0 != 0) {
    long tmp;
    
#line 1909 
    printk("\001");
    
#line 1910 
    tmp = PTR_ERR((void const *)hw);
    
#line 1910 
    ret = (int)tmp;
    
#line 1911 
    goto out;
  }
  else ;
  
#line 1914 
  wl = (struct wl1271 *)hw->priv;
  
#line 1915 
  wl->ops = & wl12xx_ops;
  
#line 1916 
  wl->ptable = (struct wlcore_partition_set const *)(& wl12xx_ptable);
  
#line 1917 
  ret = wlcore_probe(wl,pdev);
  
#line 1918 
  if (ret != 0) 
#line 1919 
                goto out_free; else ;
  
#line 1921 
  __retres = ret;
  
#line 1921 
  goto return_label;
  out_free: 
#line 1923 
  ;
  
#line 1924 
  wlcore_free_hw(wl);
  out: 
#line 1925 
  ;
  
#line 1926 
  __retres = ret;
  return_label: 
#line 1926 
                return __retres;
}


#line 1929  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c"
static int wl12xx_remove(struct platform_device *pdev)
{
  struct wl12xx_priv *priv;
  int tmp_0;
  
#line 1931 
  struct wl1271 *wl = platform_get_drvdata((struct platform_device const *)pdev);
  
#line 1934 
  if (wl == (struct wl1271 *)0) 
#line 1935 
                                goto out; else ;
  
#line 1936 
  priv = (struct wl12xx_priv *)wl->priv;
  
#line 1938 
  kfree((void const *)priv->rx_mem_addr);
  out: 
#line 1940 
  ;
  
#line 1941 
  tmp_0 = wlcore_remove(pdev);
  
#line 1941 
  return tmp_0;
}


#line 1944  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c"
static struct platform_device_id const wl12xx_id_table[2U] = {{.name = {(char)'w', (char)'l', (char)'1', (char)'2', (char)'x', (char)'x', (char)'\000'}, .driver_data = 0UL}, {.name = {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0}, .driver_data = 0UL}};

#line 1948  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c"
struct platform_device_id const __mod_platform__wl12xx_id_table_device_table[2U];

#line 1950  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c"
static struct platform_driver wl12xx_driver = {.probe = & wl12xx_probe, .remove = & wl12xx_remove, .shutdown = (void (*)(struct platform_device *))0, .suspend = (int (*)(struct platform_device *, pm_message_t ))0, .resume = (int (*)(struct platform_device *))0, .driver = {.name = "wl12xx_driver", .bus = (struct bus_type *)0, .owner = (struct module *)0, .mod_name = (char const *)0, .suppress_bind_attrs = (_Bool)0, .probe_type = 0, .of_match_table = (struct of_device_id const *)0, .acpi_match_table = (struct acpi_device_id const *)0, .probe = (int (*)(struct device *))0, .remove = (int (*)(struct device *))0, .shutdown = (void (*)(struct device *))0, .suspend = (int (*)(struct device *, pm_message_t ))0, .resume = (int (*)(struct device *))0, .groups = (struct attribute_group const **)0, .pm = (struct dev_pm_ops const *)0, .p = (struct driver_private *)0}, .id_table = (struct platform_device_id const *)(& wl12xx_id_table), .prevent_deferred_probe = (_Bool)0};

#line 1959  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c"
static int wl12xx_driver_init(void)
{
  int tmp;
  
#line 1959 
  tmp = ldv___platform_driver_register_74(& wl12xx_driver,& __this_module);
  
#line 1959 
  return tmp;
}


#line 1959  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/main.c"
static void wl12xx_driver_exit(void)
{
  
#line 1959 
  ldv_platform_driver_unregister_75(& wl12xx_driver);
  
#line 1960 
  return;
}


#line 56  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
struct platform_driver *ldv_emg_alias_wl12xx_driver_2 = & wl12xx_driver;

#line 59 
int ldv_emg___platform_driver_register(struct platform_driver *arg0, struct module *arg1);


#line 60 
void ldv_emg_platform_driver_unregister(struct platform_driver *arg0);


#line 65  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
void ldv_emg_wl12xx_driver_exit(void)
{
  
#line 66 
  wl12xx_driver_exit();
  
#line 67 
  return;
}


#line 69  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
int ldv_emg_wrapper_wl12xx_remove_3(struct platform_device *arg0)
{
  int tmp;
  
#line 70 
  tmp = wl12xx_remove(arg0);
  
#line 70 
  return tmp;
}


#line 74  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
int ldv_emg_wrapper_wl12xx_probe_2(struct platform_device *arg0)
{
  int tmp;
  
#line 75 
  tmp = wl12xx_probe(arg0);
  
#line 75 
  return tmp;
}


#line 79  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
int ldv_emg_wl12xx_driver_init(void)
{
  int tmp;
  
#line 80 
  tmp = wl12xx_driver_init();
  
#line 80 
  return tmp;
}


#line 91  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static long PTR_ERR(void const *ptr)
{
  long tmp;
  
#line 94 
  tmp = ldv_ptr_err(ptr);
  
#line 94 
  return tmp;
}


#line 98  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static bool IS_ERR(void const *ptr)
{
  bool __retres;
  long ret;
  
#line 102 
  ret = ldv_is_err(ptr);
  
#line 103 
  __retres = (_Bool)(ret != 0L);
  
#line 103 
  return __retres;
}


#line 487  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void *kmalloc(size_t size, gfp_t flags)
{
  void *tmp;
  
#line 490 
  tmp = ldv_kmalloc(size,flags);
  
#line 490 
  return tmp;
}


#line 754  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_mutex_unlock_72(struct mutex *ldv_func_arg1)
{
  
#line 758 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"mutex_of_wl1271");
  
#line 759 
  return;
}


#line 762  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_mutex_lock_73(struct mutex *ldv_func_arg1)
{
  
#line 766 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"mutex_of_wl1271");
  
#line 767 
  return;
}


#line 770  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static int ldv___platform_driver_register_74(struct platform_driver *ldv_func_arg1, struct module *ldv_func_arg2)
{
  int tmp;
  
#line 774 
  tmp = ldv_emg___platform_driver_register(ldv_func_arg1,ldv_func_arg2);
  
#line 774 
  return tmp;
}


#line 778  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_platform_driver_unregister_75(struct platform_driver *ldv_func_arg1)
{
  
#line 782 
  ldv_emg_platform_driver_unregister(ldv_func_arg1);
  
#line 783 
  return;
}


#line 431  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/printk.h"
void print_hex_dump(char const *, char const *, int, int, int, void const *, size_t, bool);


#line 581  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/slab.h"
static void *kzalloc_0(size_t size, gfp_t flags);


#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/cmd.h"
int wl1271_cmd_send(struct wl1271 *, u16, void *, size_t, size_t);


#line 45 
int wl1271_cmd_test(struct wl1271 *, void *, size_t, u8);


#line 29  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/cmd.c"
int wl1271_cmd_ext_radio_parms(struct wl1271 *wl)
{
  int __retres;
  struct wl1271_ext_radio_parms_cmd *ext_radio_parms;
  int ret;
  
#line 32 
  struct wl12xx_priv *priv = (struct wl12xx_priv *)wl->priv;
  
#line 33 
  struct wl12xx_conf_rf *rf = & priv->conf.rf;
  
#line 36 
  if (wl->nvs == (void *)0) {
    
#line 37 
    __retres = -19;
    
#line 37 
    goto return_label;
  }
  else ;
  
#line 39 
  ext_radio_parms = (struct wl1271_ext_radio_parms_cmd *)kzalloc_0(36UL,208U);
  
#line 40 
  if (ext_radio_parms == (struct wl1271_ext_radio_parms_cmd *)0) {
    
#line 41 
    __retres = -12;
    
#line 41 
    goto return_label;
  }
  else ;
  
#line 43 
  ext_radio_parms->test.id = (unsigned char)38U;
  
#line 45 
  memcpy((void *)(& ext_radio_parms->tx_per_channel_power_compensation_2),(void const *)(& rf->tx_per_channel_power_compensation_2),7UL);
  
#line 48 
  memcpy((void *)(& ext_radio_parms->tx_per_channel_power_compensation_5),(void const *)(& rf->tx_per_channel_power_compensation_5),18UL);
  
#line 52 
  if ((wl12xx_debug_level & 4096U) != 0U) {
    
#line 52 
    struct _ddebug descriptor = {.modname = "wl12xx", .function = "wl1271_cmd_ext_radio_parms", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/cmd.c", .format = "wlcore", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))53U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 52 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
      size_t tmp_1;
      {
        size_t tmp_0;
        
#line 52 
        size_t __min1 = 36UL;
        
#line 52 
        size_t __min2 = 1024UL;
        
#line 52 
        if (__min1 < __min2) 
#line 52 
                             tmp_0 = __min1; else 
#line 52 
                                                  tmp_0 = __min2;
        
#line 52 
        tmp_1 = tmp_0;
      }
      
#line 52 
      ;
      
#line 52 
      print_hex_dump("\001","wlcore",2,16,1,(void const *)ext_radio_parms,tmp_1,(_Bool)0);
    }
    else ;
  }
  else ;
  
#line 55 
  ret = wl1271_cmd_test(wl,(void *)ext_radio_parms,36UL,(unsigned char)0);
  
#line 56 
  if (ret < 0) 
#line 57 
               printk("\001"); else ;
  
#line 59 
  kfree((void const *)ext_radio_parms);
  
#line 60 
  __retres = ret;
  return_label: 
#line 60 
                return __retres;
}


#line 63  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/cmd.c"
int wl1271_cmd_general_parms(struct wl1271 *wl)
{
  int __retres;
  struct wl1271_general_parms_cmd *gen_parms;
  int ret;
  
#line 66 
  struct wl1271_ini_general_params *gp = & ((struct wl1271_nvs_file *)wl->nvs)->general_params;
  
#line 68 
  struct wl12xx_priv *priv = (struct wl12xx_priv *)wl->priv;
  
#line 69 
  bool answer = (_Bool)0;
  
#line 72 
  if (wl->nvs == (void *)0) {
    
#line 73 
    __retres = -19;
    
#line 73 
    goto return_label;
  }
  else ;
  
#line 75 
  if ((unsigned int)gp->tx_bip_fem_manufacturer > 3U) {
    
#line 76 
    printk("\001");
    
#line 77 
    __retres = -22;
    
#line 77 
    goto return_label;
  }
  else ;
  
#line 80 
  gen_parms = (struct wl1271_general_parms_cmd *)kzalloc_0(88UL,208U);
  
#line 81 
  if (gen_parms == (struct wl1271_general_parms_cmd *)0) {
    
#line 82 
    __retres = -12;
    
#line 82 
    goto return_label;
  }
  else ;
  
#line 84 
  gen_parms->test.id = (unsigned char)30U;
  
#line 86 
  memcpy((void *)(& gen_parms->general_params),(void const *)gp,57UL);
  
#line 89 
  if (wl->plt_mode == (unsigned int)PLT_FEM_DETECT) 
#line 90 
                                                    gen_parms->general_params.tx_bip_fem_auto_detect = (unsigned char)1U; else ;
  
#line 92 
  if ((unsigned int)gen_parms->general_params.tx_bip_fem_auto_detect != 0U) 
    
#line 93 
    answer = (_Bool)1; else ;
  
#line 96 
  gen_parms->general_params.ref_clock = (unsigned char)priv->ref_clock;
  
#line 98 
  ret = wl1271_cmd_test(wl,(void *)gen_parms,88UL,(unsigned char)((int)answer));
  
#line 99 
  if (ret < 0) {
    
#line 100 
    printk("\001");
    
#line 101 
    goto out;
  }
  else ;
  
#line 104 
  gp->tx_bip_fem_manufacturer = gen_parms->general_params.tx_bip_fem_manufacturer;
  
#line 107 
  if ((unsigned int)gp->tx_bip_fem_manufacturer > 3U) {
    
#line 108 
    printk("\001");
    
#line 109 
    ret = -22;
    
#line 110 
    goto out;
  }
  else ;
  
#line 114 
  if (wl->plt_mode == (unsigned int)PLT_FEM_DETECT) 
#line 115 
                                                    wl->fem_manuf = gp->tx_bip_fem_manufacturer; else ;
  
#line 117 
  if ((long)((wl12xx_debug_level & 4096U) != 0U) != 0L) {
    
#line 117 
    struct _ddebug descriptor = {.modname = "wl12xx", .function = "wl1271_cmd_general_parms", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/cmd.c", .format = "wlcore", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))123U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 117 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
      char *tmp_1;
      
#line 117 
      ;
      
#line 117 
      if (! answer) 
#line 117 
                    tmp_1 = (char *)"manual";
      else {
        char *tmp_0;
        
#line 117 
        if (wl->plt_mode == (unsigned int)PLT_FEM_DETECT) 
#line 117 
                                                          tmp_0 = (char *)"calibrator_fem_detect"; else 
                                                                    
#line 117 
                                                                    tmp_0 = (char *)"auto";
        
#line 117 
        tmp_1 = tmp_0;
      }
      
#line 117 
      __dynamic_pr_debug(& descriptor,"wlcore",tmp_1,(int)gp->tx_bip_fem_manufacturer);
    }
    else ;
  }
  else ;
  out: 
#line 125 
  ;
  
#line 126 
  kfree((void const *)gen_parms);
  
#line 127 
  __retres = ret;
  return_label: 
#line 127 
                return __retres;
}


#line 130  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/cmd.c"
int wl128x_cmd_general_parms(struct wl1271 *wl)
{
  int __retres;
  struct wl128x_general_parms_cmd *gen_parms;
  int ret;
  
#line 133 
  struct wl128x_ini_general_params *gp = & ((struct wl128x_nvs_file *)wl->nvs)->general_params;
  
#line 135 
  struct wl12xx_priv *priv = (struct wl12xx_priv *)wl->priv;
  
#line 136 
  bool answer = (_Bool)0;
  
#line 139 
  if (wl->nvs == (void *)0) {
    
#line 140 
    __retres = -19;
    
#line 140 
    goto return_label;
  }
  else ;
  
#line 142 
  if ((unsigned int)gp->tx_bip_fem_manufacturer > 3U) {
    
#line 143 
    printk("\001");
    
#line 144 
    __retres = -22;
    
#line 144 
    goto return_label;
  }
  else ;
  
#line 147 
  gen_parms = (struct wl128x_general_parms_cmd *)kzalloc_0(96UL,208U);
  
#line 148 
  if (gen_parms == (struct wl128x_general_parms_cmd *)0) {
    
#line 149 
    __retres = -12;
    
#line 149 
    goto return_label;
  }
  else ;
  
#line 151 
  gen_parms->test.id = (unsigned char)30U;
  
#line 153 
  memcpy((void *)(& gen_parms->general_params),(void const *)gp,65UL);
  
#line 156 
  if (wl->plt_mode == (unsigned int)PLT_FEM_DETECT) 
#line 157 
                                                    gen_parms->general_params.tx_bip_fem_auto_detect = (unsigned char)1U; else ;
  
#line 159 
  if ((unsigned int)gen_parms->general_params.tx_bip_fem_auto_detect != 0U) 
    
#line 160 
    answer = (_Bool)1; else ;
  
#line 163 
  gen_parms->general_params.ref_clock = (unsigned char)priv->ref_clock;
  
#line 164 
  gen_parms->general_params.tcxo_ref_clock = (unsigned char)priv->tcxo_clock;
  
#line 166 
  ret = wl1271_cmd_test(wl,(void *)gen_parms,96UL,(unsigned char)((int)answer));
  
#line 167 
  if (ret < 0) {
    
#line 168 
    printk("\001");
    
#line 169 
    goto out;
  }
  else ;
  
#line 172 
  gp->tx_bip_fem_manufacturer = gen_parms->general_params.tx_bip_fem_manufacturer;
  
#line 175 
  if ((unsigned int)gp->tx_bip_fem_manufacturer > 3U) {
    
#line 176 
    printk("\001");
    
#line 177 
    ret = -22;
    
#line 178 
    goto out;
  }
  else ;
  
#line 182 
  if (wl->plt_mode == (unsigned int)PLT_FEM_DETECT) 
#line 183 
                                                    wl->fem_manuf = gp->tx_bip_fem_manufacturer; else ;
  
#line 185 
  if ((long)((wl12xx_debug_level & 4096U) != 0U) != 0L) {
    
#line 185 
    struct _ddebug descriptor = {.modname = "wl12xx", .function = "wl128x_cmd_general_parms", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/cmd.c", .format = "wlcore", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))191U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 185 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
      char *tmp_1;
      
#line 185 
      ;
      
#line 185 
      if (! answer) 
#line 185 
                    tmp_1 = (char *)"manual";
      else {
        char *tmp_0;
        
#line 185 
        if (wl->plt_mode == (unsigned int)PLT_FEM_DETECT) 
#line 185 
                                                          tmp_0 = (char *)"calibrator_fem_detect"; else 
                                                                    
#line 185 
                                                                    tmp_0 = (char *)"auto";
        
#line 185 
        tmp_1 = tmp_0;
      }
      
#line 185 
      __dynamic_pr_debug(& descriptor,"wlcore",tmp_1,(int)gp->tx_bip_fem_manufacturer);
    }
    else ;
  }
  else ;
  out: 
#line 193 
  ;
  
#line 194 
  kfree((void const *)gen_parms);
  
#line 195 
  __retres = ret;
  return_label: 
#line 195 
                return __retres;
}


#line 198  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/cmd.c"
int wl1271_cmd_radio_parms(struct wl1271 *wl)
{
  int __retres;
  struct wl1271_radio_parms_cmd *radio_parms;
  int ret;
  int fem_idx;
  
#line 200 
  struct wl1271_nvs_file *nvs = (struct wl1271_nvs_file *)wl->nvs;
  
#line 202 
  struct wl1271_ini_general_params *gp = & nvs->general_params;
  
#line 205 
  if (wl->nvs == (void *)0) {
    
#line 206 
    __retres = -19;
    
#line 206 
    goto return_label;
  }
  else ;
  
#line 208 
  radio_parms = (struct wl1271_radio_parms_cmd *)kzalloc_0(224UL,208U);
  
#line 209 
  if (radio_parms == (struct wl1271_radio_parms_cmd *)0) {
    
#line 210 
    __retres = -12;
    
#line 210 
    goto return_label;
  }
  else ;
  
#line 212 
  radio_parms->test.id = (unsigned char)25U;
  
#line 214 
  fem_idx = (unsigned int)gp->tx_bip_fem_manufacturer == 1U;
  
#line 217 
  memcpy((void *)(& radio_parms->static_params_2),(void const *)(& nvs->stat_radio_params_2),17UL);
  
#line 219 
  memcpy((void *)(& radio_parms->dyn_params_2),(void const *)(& nvs->dyn_radio_params_2[fem_idx].params),65UL);
  
#line 224 
  memcpy((void *)(& radio_parms->static_params_5),(void const *)(& nvs->stat_radio_params_5),29UL);
  
#line 227 
  memcpy((void *)(& radio_parms->dyn_params_5),(void const *)(& nvs->dyn_radio_params_5[fem_idx].params),102UL);
  
#line 231 
  if ((wl12xx_debug_level & 4096U) != 0U) {
    
#line 231 
    struct _ddebug descriptor = {.modname = "wl12xx", .function = "wl1271_cmd_radio_parms", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/cmd.c", .format = "wlcore", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))232U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 231 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
      size_t tmp_1;
      {
        size_t tmp_0;
        
#line 231 
        size_t __min1 = 224UL;
        
#line 231 
        size_t __min2 = 1024UL;
        
#line 231 
        if (__min1 < __min2) 
#line 231 
                             tmp_0 = __min1; else 
#line 231 
                                                  tmp_0 = __min2;
        
#line 231 
        tmp_1 = tmp_0;
      }
      
#line 231 
      ;
      
#line 231 
      print_hex_dump("\001","wlcore",2,16,1,(void const *)radio_parms,tmp_1,(_Bool)0);
    }
    else ;
  }
  else ;
  
#line 234 
  ret = wl1271_cmd_test(wl,(void *)radio_parms,224UL,(unsigned char)0);
  
#line 235 
  if (ret < 0) 
#line 236 
               printk("\001"); else ;
  
#line 238 
  kfree((void const *)radio_parms);
  
#line 239 
  __retres = ret;
  return_label: 
#line 239 
                return __retres;
}


#line 242  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/cmd.c"
int wl128x_cmd_radio_parms(struct wl1271 *wl)
{
  int __retres;
  struct wl128x_radio_parms_cmd *radio_parms;
  int ret;
  int fem_idx;
  
#line 244 
  struct wl128x_nvs_file *nvs = (struct wl128x_nvs_file *)wl->nvs;
  
#line 246 
  struct wl128x_ini_general_params *gp = & nvs->general_params;
  
#line 249 
  if (wl->nvs == (void *)0) {
    
#line 250 
    __retres = -19;
    
#line 250 
    goto return_label;
  }
  else ;
  
#line 252 
  radio_parms = (struct wl128x_radio_parms_cmd *)kzalloc_0(340UL,208U);
  
#line 253 
  if (radio_parms == (struct wl128x_radio_parms_cmd *)0) {
    
#line 254 
    __retres = -12;
    
#line 254 
    goto return_label;
  }
  else ;
  
#line 256 
  radio_parms->test.id = (unsigned char)25U;
  
#line 258 
  fem_idx = (unsigned int)gp->tx_bip_fem_manufacturer == 1U;
  
#line 261 
  memcpy((void *)(& radio_parms->static_params_2),(void const *)(& nvs->stat_radio_params_2),30UL);
  
#line 263 
  memcpy((void *)(& radio_parms->dyn_params_2),(void const *)(& nvs->dyn_radio_params_2[fem_idx].params),87UL);
  
#line 268 
  memcpy((void *)(& radio_parms->static_params_5),(void const *)(& nvs->stat_radio_params_5),57UL);
  
#line 271 
  memcpy((void *)(& radio_parms->dyn_params_5),(void const *)(& nvs->dyn_radio_params_5[fem_idx].params),156UL);
  
#line 275 
  radio_parms->fem_vendor_and_options = nvs->fem_vendor_and_options;
  
#line 277 
  if ((wl12xx_debug_level & 4096U) != 0U) {
    
#line 277 
    struct _ddebug descriptor = {.modname = "wl12xx", .function = "wl128x_cmd_radio_parms", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/cmd.c", .format = "wlcore", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))278U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 277 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
      size_t tmp_1;
      {
        size_t tmp_0;
        
#line 277 
        size_t __min1 = 340UL;
        
#line 277 
        size_t __min2 = 1024UL;
        
#line 277 
        if (__min1 < __min2) 
#line 277 
                             tmp_0 = __min1; else 
#line 277 
                                                  tmp_0 = __min2;
        
#line 277 
        tmp_1 = tmp_0;
      }
      
#line 277 
      ;
      
#line 277 
      print_hex_dump("\001","wlcore",2,16,1,(void const *)radio_parms,tmp_1,(_Bool)0);
    }
    else ;
  }
  else ;
  
#line 280 
  ret = wl1271_cmd_test(wl,(void *)radio_parms,340UL,(unsigned char)0);
  
#line 281 
  if (ret < 0) 
#line 282 
               printk("\001"); else ;
  
#line 284 
  kfree((void const *)radio_parms);
  
#line 285 
  __retres = ret;
  return_label: 
#line 285 
                return __retres;
}


#line 288  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/cmd.c"
int wl12xx_cmd_channel_switch(struct wl1271 *wl, struct wl12xx_vif *wlvif, struct ieee80211_channel_switch *ch_switch)
{
  struct wl12xx_cmd_channel_switch *cmd;
  int ret;
  
#line 295 
  if ((long)((wl12xx_debug_level & 8192U) != 0U) != 0L) {
    
#line 295 
    struct _ddebug descriptor = {.modname = "wl12xx", .function = "wl12xx_cmd_channel_switch", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/cmd.c", .format = "wlcore", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))295U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 295 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 295 
                                                        __dynamic_pr_debug(& descriptor,"wlcore"); else ;
  }
  else ;
  
#line 297 
  cmd = (struct wl12xx_cmd_channel_switch *)kzalloc_0(12UL,208U);
  
#line 298 
  if (cmd == (struct wl12xx_cmd_channel_switch *)0) {
    
#line 299 
    ret = -12;
    
#line 300 
    goto out;
  }
  else ;
  
#line 303 
  cmd->role_id = wlvif->role_id;
  
#line 304 
  cmd->channel = (unsigned char)(ch_switch->chandef.chan)->hw_value;
  
#line 305 
  cmd->switch_time = ch_switch->count;
  
#line 306 
  cmd->stop_tx = (unsigned char)ch_switch->block_tx;
  
#line 310 
  cmd->post_switch_tx_disable = (unsigned char)0U;
  
#line 312 
  ret = wl1271_cmd_send(wl,(unsigned short)20,(void *)cmd,12UL,0UL);
  
#line 313 
  if (ret < 0) {
    
#line 314 
    printk("\001");
    
#line 315 
    goto out_free;
  }
  else ;
  out_free: 
#line 318 
  ;
  
#line 319 
  kfree((void const *)cmd);
  out: 
#line 321 
  ;
  
#line 322 
  return ret;
}


#line 485  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_cmd.c.aux"
static void *kzalloc_0(size_t size, gfp_t flags)
{
  void *tmp;
  
#line 488 
  tmp = ldv_kzalloc(size,flags);
  
#line 488 
  return tmp;
}


#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/err.h"
static long PTR_ERR_0(void const *ptr);


#line 41 
static bool IS_ERR_0(void const *ptr);


#line 2662  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
loff_t generic_file_llseek(struct file *, loff_t, int);


#line 2812 
int simple_open(struct inode *, struct file *);


#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/debugfs.h"
static struct dentry *ldv_debugfs_create_file_72(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 58 
static struct dentry *ldv_debugfs_create_file_73(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 62 
static struct dentry *ldv_debugfs_create_file_74(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 66 
static struct dentry *ldv_debugfs_create_file_75(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 70 
static struct dentry *ldv_debugfs_create_file_76(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 74 
static struct dentry *ldv_debugfs_create_file_77(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 78 
static struct dentry *ldv_debugfs_create_file_78(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 82 
static struct dentry *ldv_debugfs_create_file_79(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 86 
static struct dentry *ldv_debugfs_create_file_80(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 90 
static struct dentry *ldv_debugfs_create_file_81(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 94 
static struct dentry *ldv_debugfs_create_file_82(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 98 
static struct dentry *ldv_debugfs_create_file_83(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 102 
static struct dentry *ldv_debugfs_create_file_84(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 106 
static struct dentry *ldv_debugfs_create_file_85(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 110 
static struct dentry *ldv_debugfs_create_file_86(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 114 
static struct dentry *ldv_debugfs_create_file_87(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 118 
static struct dentry *ldv_debugfs_create_file_88(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 122 
static struct dentry *ldv_debugfs_create_file_89(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 126 
static struct dentry *ldv_debugfs_create_file_90(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 130 
static struct dentry *ldv_debugfs_create_file_91(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 134 
static struct dentry *ldv_debugfs_create_file_92(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 138 
static struct dentry *ldv_debugfs_create_file_93(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 142 
static struct dentry *ldv_debugfs_create_file_94(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 146 
static struct dentry *ldv_debugfs_create_file_95(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 150 
static struct dentry *ldv_debugfs_create_file_96(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 154 
static struct dentry *ldv_debugfs_create_file_97(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 158 
static struct dentry *ldv_debugfs_create_file_98(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 162 
static struct dentry *ldv_debugfs_create_file_99(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 166 
static struct dentry *ldv_debugfs_create_file_100(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 170 
static struct dentry *ldv_debugfs_create_file_101(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 174 
static struct dentry *ldv_debugfs_create_file_102(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 178 
static struct dentry *ldv_debugfs_create_file_103(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 182 
static struct dentry *ldv_debugfs_create_file_104(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 186 
static struct dentry *ldv_debugfs_create_file_105(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 190 
static struct dentry *ldv_debugfs_create_file_106(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 194 
static struct dentry *ldv_debugfs_create_file_107(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 198 
static struct dentry *ldv_debugfs_create_file_108(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 202 
static struct dentry *ldv_debugfs_create_file_109(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 206 
static struct dentry *ldv_debugfs_create_file_110(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 210 
static struct dentry *ldv_debugfs_create_file_111(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 214 
static struct dentry *ldv_debugfs_create_file_112(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 218 
static struct dentry *ldv_debugfs_create_file_113(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 222 
static struct dentry *ldv_debugfs_create_file_114(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 226 
static struct dentry *ldv_debugfs_create_file_115(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 230 
static struct dentry *ldv_debugfs_create_file_116(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 234 
static struct dentry *ldv_debugfs_create_file_117(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 238 
static struct dentry *ldv_debugfs_create_file_118(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 242 
static struct dentry *ldv_debugfs_create_file_119(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 246 
static struct dentry *ldv_debugfs_create_file_120(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 250 
static struct dentry *ldv_debugfs_create_file_121(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 254 
static struct dentry *ldv_debugfs_create_file_122(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 258 
static struct dentry *ldv_debugfs_create_file_123(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 262 
static struct dentry *ldv_debugfs_create_file_124(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 266 
static struct dentry *ldv_debugfs_create_file_125(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 270 
static struct dentry *ldv_debugfs_create_file_126(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 274 
static struct dentry *ldv_debugfs_create_file_127(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 278 
static struct dentry *ldv_debugfs_create_file_128(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 282 
static struct dentry *ldv_debugfs_create_file_129(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 286 
static struct dentry *ldv_debugfs_create_file_130(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 290 
static struct dentry *ldv_debugfs_create_file_131(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 294 
static struct dentry *ldv_debugfs_create_file_132(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 298 
static struct dentry *ldv_debugfs_create_file_133(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 302 
static struct dentry *ldv_debugfs_create_file_134(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 306 
static struct dentry *ldv_debugfs_create_file_135(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 310 
static struct dentry *ldv_debugfs_create_file_136(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 314 
static struct dentry *ldv_debugfs_create_file_137(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 318 
static struct dentry *ldv_debugfs_create_file_138(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 322 
static struct dentry *ldv_debugfs_create_file_139(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 326 
static struct dentry *ldv_debugfs_create_file_140(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 330 
static struct dentry *ldv_debugfs_create_file_141(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 334 
static struct dentry *ldv_debugfs_create_file_142(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 338 
static struct dentry *ldv_debugfs_create_file_143(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 342 
static struct dentry *ldv_debugfs_create_file_144(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 346 
static struct dentry *ldv_debugfs_create_file_145(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 350 
static struct dentry *ldv_debugfs_create_file_146(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 354 
static struct dentry *ldv_debugfs_create_file_147(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 358 
static struct dentry *ldv_debugfs_create_file_148(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 362 
static struct dentry *ldv_debugfs_create_file_149(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 370 
struct dentry *debugfs_create_dir(char const *, struct dentry *);


#line 29  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/debugfs.h"
int wl1271_format_buffer(char *, size_t, loff_t *, char * , ...);


#line 35 
void wl1271_debugfs_update_stats(struct wl1271 *);


#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t tx_internal_desc_overflow_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 33 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 33 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 33 
  wl1271_debugfs_update_stats(wl);
  
#line 33 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->tx.internal_desc_overflow);
  
#line 33 
  __retres = (long)tmp;
  
#line 33 
  return __retres;
}


#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const tx_internal_desc_overflow_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & tx_internal_desc_overflow_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t rx_out_of_mem_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 35 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 35 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 35 
  wl1271_debugfs_update_stats(wl);
  
#line 35 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->rx.out_of_mem);
  
#line 35 
  __retres = (long)tmp;
  
#line 35 
  return __retres;
}


#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const rx_out_of_mem_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & rx_out_of_mem_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 36  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t rx_hdr_overflow_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 36 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 36 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 36 
  wl1271_debugfs_update_stats(wl);
  
#line 36 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->rx.hdr_overflow);
  
#line 36 
  __retres = (long)tmp;
  
#line 36 
  return __retres;
}


#line 36  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const rx_hdr_overflow_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & rx_hdr_overflow_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t rx_hw_stuck_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 37 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 37 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 37 
  wl1271_debugfs_update_stats(wl);
  
#line 37 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->rx.hw_stuck);
  
#line 37 
  __retres = (long)tmp;
  
#line 37 
  return __retres;
}


#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const rx_hw_stuck_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & rx_hw_stuck_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t rx_dropped_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 38 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 38 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 38 
  wl1271_debugfs_update_stats(wl);
  
#line 38 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->rx.dropped);
  
#line 38 
  __retres = (long)tmp;
  
#line 38 
  return __retres;
}


#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const rx_dropped_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & rx_dropped_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t rx_fcs_err_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 39 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 39 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 39 
  wl1271_debugfs_update_stats(wl);
  
#line 39 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->rx.fcs_err);
  
#line 39 
  __retres = (long)tmp;
  
#line 39 
  return __retres;
}


#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const rx_fcs_err_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & rx_fcs_err_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 40  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t rx_xfr_hint_trig_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 40 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 40 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 40 
  wl1271_debugfs_update_stats(wl);
  
#line 40 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->rx.xfr_hint_trig);
  
#line 40 
  __retres = (long)tmp;
  
#line 40 
  return __retres;
}


#line 40  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const rx_xfr_hint_trig_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & rx_xfr_hint_trig_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t rx_path_reset_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 41 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 41 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 41 
  wl1271_debugfs_update_stats(wl);
  
#line 41 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->rx.path_reset);
  
#line 41 
  __retres = (long)tmp;
  
#line 41 
  return __retres;
}


#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const rx_path_reset_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & rx_path_reset_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 42  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t rx_reset_counter_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 42 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 42 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 42 
  wl1271_debugfs_update_stats(wl);
  
#line 42 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->rx.reset_counter);
  
#line 42 
  __retres = (long)tmp;
  
#line 42 
  return __retres;
}


#line 42  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const rx_reset_counter_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & rx_reset_counter_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 44  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t dma_rx_requested_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 44 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 44 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 44 
  wl1271_debugfs_update_stats(wl);
  
#line 44 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->dma.rx_requested);
  
#line 44 
  __retres = (long)tmp;
  
#line 44 
  return __retres;
}


#line 44  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const dma_rx_requested_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & dma_rx_requested_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 45  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t dma_rx_errors_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 45 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 45 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 45 
  wl1271_debugfs_update_stats(wl);
  
#line 45 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->dma.rx_errors);
  
#line 45 
  __retres = (long)tmp;
  
#line 45 
  return __retres;
}


#line 45  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const dma_rx_errors_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & dma_rx_errors_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 46  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t dma_tx_requested_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 46 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 46 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 46 
  wl1271_debugfs_update_stats(wl);
  
#line 46 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->dma.tx_requested);
  
#line 46 
  __retres = (long)tmp;
  
#line 46 
  return __retres;
}


#line 46  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const dma_tx_requested_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & dma_tx_requested_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 47  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t dma_tx_errors_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 47 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 47 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 47 
  wl1271_debugfs_update_stats(wl);
  
#line 47 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->dma.tx_errors);
  
#line 47 
  __retres = (long)tmp;
  
#line 47 
  return __retres;
}


#line 47  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const dma_tx_errors_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & dma_tx_errors_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 49  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t isr_cmd_cmplt_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 49 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 49 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 49 
  wl1271_debugfs_update_stats(wl);
  
#line 49 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->isr.cmd_cmplt);
  
#line 49 
  __retres = (long)tmp;
  
#line 49 
  return __retres;
}


#line 49  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const isr_cmd_cmplt_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & isr_cmd_cmplt_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 50  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t isr_fiqs_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 50 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 50 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 50 
  wl1271_debugfs_update_stats(wl);
  
#line 50 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->isr.fiqs);
  
#line 50 
  __retres = (long)tmp;
  
#line 50 
  return __retres;
}


#line 50  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const isr_fiqs_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & isr_fiqs_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t isr_rx_headers_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 51 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 51 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 51 
  wl1271_debugfs_update_stats(wl);
  
#line 51 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->isr.rx_headers);
  
#line 51 
  __retres = (long)tmp;
  
#line 51 
  return __retres;
}


#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const isr_rx_headers_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & isr_rx_headers_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 52  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t isr_rx_mem_overflow_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 52 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 52 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 52 
  wl1271_debugfs_update_stats(wl);
  
#line 52 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->isr.rx_mem_overflow);
  
#line 52 
  __retres = (long)tmp;
  
#line 52 
  return __retres;
}


#line 52  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const isr_rx_mem_overflow_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & isr_rx_mem_overflow_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 53  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t isr_rx_rdys_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 53 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 53 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 53 
  wl1271_debugfs_update_stats(wl);
  
#line 53 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->isr.rx_rdys);
  
#line 53 
  __retres = (long)tmp;
  
#line 53 
  return __retres;
}


#line 53  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const isr_rx_rdys_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & isr_rx_rdys_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t isr_irqs_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 54 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 54 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 54 
  wl1271_debugfs_update_stats(wl);
  
#line 54 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->isr.irqs);
  
#line 54 
  __retres = (long)tmp;
  
#line 54 
  return __retres;
}


#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const isr_irqs_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & isr_irqs_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 55  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t isr_tx_procs_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 55 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 55 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 55 
  wl1271_debugfs_update_stats(wl);
  
#line 55 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->isr.tx_procs);
  
#line 55 
  __retres = (long)tmp;
  
#line 55 
  return __retres;
}


#line 55  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const isr_tx_procs_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & isr_tx_procs_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 56  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t isr_decrypt_done_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 56 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 56 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 56 
  wl1271_debugfs_update_stats(wl);
  
#line 56 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->isr.decrypt_done);
  
#line 56 
  __retres = (long)tmp;
  
#line 56 
  return __retres;
}


#line 56  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const isr_decrypt_done_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & isr_decrypt_done_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 57  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t isr_dma0_done_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 57 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 57 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 57 
  wl1271_debugfs_update_stats(wl);
  
#line 57 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->isr.dma0_done);
  
#line 57 
  __retres = (long)tmp;
  
#line 57 
  return __retres;
}


#line 57  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const isr_dma0_done_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & isr_dma0_done_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t isr_dma1_done_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 58 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 58 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 58 
  wl1271_debugfs_update_stats(wl);
  
#line 58 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->isr.dma1_done);
  
#line 58 
  __retres = (long)tmp;
  
#line 58 
  return __retres;
}


#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const isr_dma1_done_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & isr_dma1_done_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 59  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t isr_tx_exch_complete_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 59 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 59 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 59 
  wl1271_debugfs_update_stats(wl);
  
#line 59 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->isr.tx_exch_complete);
  
#line 59 
  __retres = (long)tmp;
  
#line 59 
  return __retres;
}


#line 59  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const isr_tx_exch_complete_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & isr_tx_exch_complete_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 60  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t isr_commands_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 60 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 60 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 60 
  wl1271_debugfs_update_stats(wl);
  
#line 60 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->isr.commands);
  
#line 60 
  __retres = (long)tmp;
  
#line 60 
  return __retres;
}


#line 60  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const isr_commands_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & isr_commands_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t isr_rx_procs_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 61 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 61 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 61 
  wl1271_debugfs_update_stats(wl);
  
#line 61 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->isr.rx_procs);
  
#line 61 
  __retres = (long)tmp;
  
#line 61 
  return __retres;
}


#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const isr_rx_procs_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & isr_rx_procs_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 62  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t isr_hw_pm_mode_changes_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 62 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 62 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 62 
  wl1271_debugfs_update_stats(wl);
  
#line 62 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->isr.hw_pm_mode_changes);
  
#line 62 
  __retres = (long)tmp;
  
#line 62 
  return __retres;
}


#line 62  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const isr_hw_pm_mode_changes_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & isr_hw_pm_mode_changes_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 63  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t isr_host_acknowledges_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 63 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 63 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 63 
  wl1271_debugfs_update_stats(wl);
  
#line 63 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->isr.host_acknowledges);
  
#line 63 
  __retres = (long)tmp;
  
#line 63 
  return __retres;
}


#line 63  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const isr_host_acknowledges_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & isr_host_acknowledges_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 64  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t isr_pci_pm_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 64 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 64 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 64 
  wl1271_debugfs_update_stats(wl);
  
#line 64 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->isr.pci_pm);
  
#line 64 
  __retres = (long)tmp;
  
#line 64 
  return __retres;
}


#line 64  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const isr_pci_pm_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & isr_pci_pm_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t isr_wakeups_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 65 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 65 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 65 
  wl1271_debugfs_update_stats(wl);
  
#line 65 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->isr.wakeups);
  
#line 65 
  __retres = (long)tmp;
  
#line 65 
  return __retres;
}


#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const isr_wakeups_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & isr_wakeups_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t isr_low_rssi_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 66 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 66 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 66 
  wl1271_debugfs_update_stats(wl);
  
#line 66 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->isr.low_rssi);
  
#line 66 
  __retres = (long)tmp;
  
#line 66 
  return __retres;
}


#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const isr_low_rssi_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & isr_low_rssi_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 68  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t wep_addr_key_count_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 68 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 68 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 68 
  wl1271_debugfs_update_stats(wl);
  
#line 68 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->wep.addr_key_count);
  
#line 68 
  __retres = (long)tmp;
  
#line 68 
  return __retres;
}


#line 68  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const wep_addr_key_count_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & wep_addr_key_count_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t wep_default_key_count_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 69 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 69 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 69 
  wl1271_debugfs_update_stats(wl);
  
#line 69 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->wep.default_key_count);
  
#line 69 
  __retres = (long)tmp;
  
#line 69 
  return __retres;
}


#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const wep_default_key_count_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & wep_default_key_count_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 71  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t wep_key_not_found_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 71 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 71 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 71 
  wl1271_debugfs_update_stats(wl);
  
#line 71 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->wep.key_not_found);
  
#line 71 
  __retres = (long)tmp;
  
#line 71 
  return __retres;
}


#line 71  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const wep_key_not_found_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & wep_key_not_found_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t wep_decrypt_fail_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 72 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 72 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 72 
  wl1271_debugfs_update_stats(wl);
  
#line 72 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->wep.decrypt_fail);
  
#line 72 
  __retres = (long)tmp;
  
#line 72 
  return __retres;
}


#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const wep_decrypt_fail_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & wep_decrypt_fail_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t wep_packets_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 73 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 73 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 73 
  wl1271_debugfs_update_stats(wl);
  
#line 73 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->wep.packets);
  
#line 73 
  __retres = (long)tmp;
  
#line 73 
  return __retres;
}


#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const wep_packets_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & wep_packets_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 74  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t wep_interrupt_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 74 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 74 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 74 
  wl1271_debugfs_update_stats(wl);
  
#line 74 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->wep.interrupt);
  
#line 74 
  __retres = (long)tmp;
  
#line 74 
  return __retres;
}


#line 74  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const wep_interrupt_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & wep_interrupt_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 76  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t pwr_ps_enter_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 76 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 76 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 76 
  wl1271_debugfs_update_stats(wl);
  
#line 76 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->pwr.ps_enter);
  
#line 76 
  __retres = (long)tmp;
  
#line 76 
  return __retres;
}


#line 76  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const pwr_ps_enter_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & pwr_ps_enter_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 77  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t pwr_elp_enter_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 77 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 77 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 77 
  wl1271_debugfs_update_stats(wl);
  
#line 77 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->pwr.elp_enter);
  
#line 77 
  __retres = (long)tmp;
  
#line 77 
  return __retres;
}


#line 77  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const pwr_elp_enter_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & pwr_elp_enter_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 78  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t pwr_missing_bcns_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 78 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 78 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 78 
  wl1271_debugfs_update_stats(wl);
  
#line 78 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->pwr.missing_bcns);
  
#line 78 
  __retres = (long)tmp;
  
#line 78 
  return __retres;
}


#line 78  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const pwr_missing_bcns_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & pwr_missing_bcns_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t pwr_wake_on_host_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 79 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 79 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 79 
  wl1271_debugfs_update_stats(wl);
  
#line 79 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->pwr.wake_on_host);
  
#line 79 
  __retres = (long)tmp;
  
#line 79 
  return __retres;
}


#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const pwr_wake_on_host_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & pwr_wake_on_host_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 80  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t pwr_wake_on_timer_exp_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 80 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 80 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 80 
  wl1271_debugfs_update_stats(wl);
  
#line 80 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->pwr.wake_on_timer_exp);
  
#line 80 
  __retres = (long)tmp;
  
#line 80 
  return __retres;
}


#line 80  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const pwr_wake_on_timer_exp_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & pwr_wake_on_timer_exp_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 81  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t pwr_tx_with_ps_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 81 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 81 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 81 
  wl1271_debugfs_update_stats(wl);
  
#line 81 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->pwr.tx_with_ps);
  
#line 81 
  __retres = (long)tmp;
  
#line 81 
  return __retres;
}


#line 81  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const pwr_tx_with_ps_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & pwr_tx_with_ps_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 82  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t pwr_tx_without_ps_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 82 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 82 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 82 
  wl1271_debugfs_update_stats(wl);
  
#line 82 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->pwr.tx_without_ps);
  
#line 82 
  __retres = (long)tmp;
  
#line 82 
  return __retres;
}


#line 82  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const pwr_tx_without_ps_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & pwr_tx_without_ps_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 83  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t pwr_rcvd_beacons_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 83 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 83 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 83 
  wl1271_debugfs_update_stats(wl);
  
#line 83 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->pwr.rcvd_beacons);
  
#line 83 
  __retres = (long)tmp;
  
#line 83 
  return __retres;
}


#line 83  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const pwr_rcvd_beacons_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & pwr_rcvd_beacons_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 84  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t pwr_power_save_off_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 84 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 84 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 84 
  wl1271_debugfs_update_stats(wl);
  
#line 84 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->pwr.power_save_off);
  
#line 84 
  __retres = (long)tmp;
  
#line 84 
  return __retres;
}


#line 84  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const pwr_power_save_off_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & pwr_power_save_off_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 85  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t pwr_enable_ps_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 85 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 85 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 85 
  wl1271_debugfs_update_stats(wl);
  
#line 85 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",(int)stats->pwr.enable_ps);
  
#line 85 
  __retres = (long)tmp;
  
#line 85 
  return __retres;
}


#line 85  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const pwr_enable_ps_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & pwr_enable_ps_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 86  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t pwr_disable_ps_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 86 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 86 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 86 
  wl1271_debugfs_update_stats(wl);
  
#line 86 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",(int)stats->pwr.disable_ps);
  
#line 86 
  __retres = (long)tmp;
  
#line 86 
  return __retres;
}


#line 86  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const pwr_disable_ps_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & pwr_disable_ps_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 87  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t pwr_fix_tsf_ps_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 87 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 87 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 87 
  wl1271_debugfs_update_stats(wl);
  
#line 87 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->pwr.fix_tsf_ps);
  
#line 87 
  __retres = (long)tmp;
  
#line 87 
  return __retres;
}


#line 87  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const pwr_fix_tsf_ps_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & pwr_fix_tsf_ps_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t pwr_rcvd_awake_beacons_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 89 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 89 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 89 
  wl1271_debugfs_update_stats(wl);
  
#line 89 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->pwr.rcvd_awake_beacons);
  
#line 89 
  __retres = (long)tmp;
  
#line 89 
  return __retres;
}


#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const pwr_rcvd_awake_beacons_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & pwr_rcvd_awake_beacons_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 91  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t mic_rx_pkts_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 91 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 91 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 91 
  wl1271_debugfs_update_stats(wl);
  
#line 91 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->mic.rx_pkts);
  
#line 91 
  __retres = (long)tmp;
  
#line 91 
  return __retres;
}


#line 91  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const mic_rx_pkts_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & mic_rx_pkts_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 92  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t mic_calc_failure_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 92 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 92 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 92 
  wl1271_debugfs_update_stats(wl);
  
#line 92 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->mic.calc_failure);
  
#line 92 
  __retres = (long)tmp;
  
#line 92 
  return __retres;
}


#line 92  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const mic_calc_failure_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & mic_calc_failure_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 94  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t aes_encrypt_fail_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 94 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 94 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 94 
  wl1271_debugfs_update_stats(wl);
  
#line 94 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->aes.encrypt_fail);
  
#line 94 
  __retres = (long)tmp;
  
#line 94 
  return __retres;
}


#line 94  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const aes_encrypt_fail_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & aes_encrypt_fail_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 95  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t aes_decrypt_fail_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 95 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 95 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 95 
  wl1271_debugfs_update_stats(wl);
  
#line 95 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->aes.decrypt_fail);
  
#line 95 
  __retres = (long)tmp;
  
#line 95 
  return __retres;
}


#line 95  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const aes_decrypt_fail_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & aes_decrypt_fail_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 96  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t aes_encrypt_packets_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 96 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 96 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 96 
  wl1271_debugfs_update_stats(wl);
  
#line 96 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->aes.encrypt_packets);
  
#line 96 
  __retres = (long)tmp;
  
#line 96 
  return __retres;
}


#line 96  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const aes_encrypt_packets_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & aes_encrypt_packets_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 97  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t aes_decrypt_packets_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 97 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 97 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 97 
  wl1271_debugfs_update_stats(wl);
  
#line 97 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->aes.decrypt_packets);
  
#line 97 
  __retres = (long)tmp;
  
#line 97 
  return __retres;
}


#line 97  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const aes_decrypt_packets_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & aes_decrypt_packets_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 98  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t aes_encrypt_interrupt_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 98 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 98 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 98 
  wl1271_debugfs_update_stats(wl);
  
#line 98 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->aes.encrypt_interrupt);
  
#line 98 
  __retres = (long)tmp;
  
#line 98 
  return __retres;
}


#line 98  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const aes_encrypt_interrupt_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & aes_encrypt_interrupt_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 99  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t aes_decrypt_interrupt_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 99 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 99 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 99 
  wl1271_debugfs_update_stats(wl);
  
#line 99 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->aes.decrypt_interrupt);
  
#line 99 
  __retres = (long)tmp;
  
#line 99 
  return __retres;
}


#line 99  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const aes_decrypt_interrupt_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & aes_decrypt_interrupt_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 101  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t event_heart_beat_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 101 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 101 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 101 
  wl1271_debugfs_update_stats(wl);
  
#line 101 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->event.heart_beat);
  
#line 101 
  __retres = (long)tmp;
  
#line 101 
  return __retres;
}


#line 101  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const event_heart_beat_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & event_heart_beat_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 102  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t event_calibration_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 102 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 102 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 102 
  wl1271_debugfs_update_stats(wl);
  
#line 102 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->event.calibration);
  
#line 102 
  __retres = (long)tmp;
  
#line 102 
  return __retres;
}


#line 102  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const event_calibration_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & event_calibration_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 103  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t event_rx_mismatch_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 103 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 103 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 103 
  wl1271_debugfs_update_stats(wl);
  
#line 103 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->event.rx_mismatch);
  
#line 103 
  __retres = (long)tmp;
  
#line 103 
  return __retres;
}


#line 103  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const event_rx_mismatch_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & event_rx_mismatch_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t event_rx_mem_empty_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 104 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 104 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 104 
  wl1271_debugfs_update_stats(wl);
  
#line 104 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->event.rx_mem_empty);
  
#line 104 
  __retres = (long)tmp;
  
#line 104 
  return __retres;
}


#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const event_rx_mem_empty_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & event_rx_mem_empty_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 105  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t event_rx_pool_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 105 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 105 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 105 
  wl1271_debugfs_update_stats(wl);
  
#line 105 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->event.rx_pool);
  
#line 105 
  __retres = (long)tmp;
  
#line 105 
  return __retres;
}


#line 105  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const event_rx_pool_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & event_rx_pool_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 106  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t event_oom_late_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 106 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 106 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 106 
  wl1271_debugfs_update_stats(wl);
  
#line 106 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->event.oom_late);
  
#line 106 
  __retres = (long)tmp;
  
#line 106 
  return __retres;
}


#line 106  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const event_oom_late_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & event_oom_late_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 107  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t event_phy_transmit_error_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 107 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 107 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 107 
  wl1271_debugfs_update_stats(wl);
  
#line 107 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->event.phy_transmit_error);
  
#line 107 
  __retres = (long)tmp;
  
#line 107 
  return __retres;
}


#line 107  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const event_phy_transmit_error_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & event_phy_transmit_error_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 108  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t event_tx_stuck_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 108 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 108 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 108 
  wl1271_debugfs_update_stats(wl);
  
#line 108 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->event.tx_stuck);
  
#line 108 
  __retres = (long)tmp;
  
#line 108 
  return __retres;
}


#line 108  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const event_tx_stuck_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & event_tx_stuck_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 110  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t ps_pspoll_timeouts_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 110 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 110 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 110 
  wl1271_debugfs_update_stats(wl);
  
#line 110 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->ps.pspoll_timeouts);
  
#line 110 
  __retres = (long)tmp;
  
#line 110 
  return __retres;
}


#line 110  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const ps_pspoll_timeouts_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & ps_pspoll_timeouts_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 111  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t ps_upsd_timeouts_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 111 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 111 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 111 
  wl1271_debugfs_update_stats(wl);
  
#line 111 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->ps.upsd_timeouts);
  
#line 111 
  __retres = (long)tmp;
  
#line 111 
  return __retres;
}


#line 111  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const ps_upsd_timeouts_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & ps_upsd_timeouts_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 112  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t ps_upsd_max_sptime_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 112 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 112 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 112 
  wl1271_debugfs_update_stats(wl);
  
#line 112 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->ps.upsd_max_sptime);
  
#line 112 
  __retres = (long)tmp;
  
#line 112 
  return __retres;
}


#line 112  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const ps_upsd_max_sptime_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & ps_upsd_max_sptime_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 113  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t ps_upsd_max_apturn_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 113 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 113 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 113 
  wl1271_debugfs_update_stats(wl);
  
#line 113 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->ps.upsd_max_apturn);
  
#line 113 
  __retres = (long)tmp;
  
#line 113 
  return __retres;
}


#line 113  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const ps_upsd_max_apturn_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & ps_upsd_max_apturn_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 114  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t ps_pspoll_max_apturn_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 114 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 114 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 114 
  wl1271_debugfs_update_stats(wl);
  
#line 114 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->ps.pspoll_max_apturn);
  
#line 114 
  __retres = (long)tmp;
  
#line 114 
  return __retres;
}


#line 114  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const ps_pspoll_max_apturn_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & ps_pspoll_max_apturn_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 115  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t ps_pspoll_utilization_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 115 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 115 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 115 
  wl1271_debugfs_update_stats(wl);
  
#line 115 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->ps.pspoll_utilization);
  
#line 115 
  __retres = (long)tmp;
  
#line 115 
  return __retres;
}


#line 115  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const ps_pspoll_utilization_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & ps_pspoll_utilization_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 116  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t ps_upsd_utilization_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 116 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 116 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 116 
  wl1271_debugfs_update_stats(wl);
  
#line 116 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->ps.upsd_utilization);
  
#line 116 
  __retres = (long)tmp;
  
#line 116 
  return __retres;
}


#line 116  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const ps_upsd_utilization_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & ps_upsd_utilization_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 118  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t rxpipe_rx_prep_beacon_drop_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 118 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 118 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 118 
  wl1271_debugfs_update_stats(wl);
  
#line 118 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->rxpipe.rx_prep_beacon_drop);
  
#line 118 
  __retres = (long)tmp;
  
#line 118 
  return __retres;
}


#line 118  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const rxpipe_rx_prep_beacon_drop_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & rxpipe_rx_prep_beacon_drop_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 119  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t rxpipe_descr_host_int_trig_rx_data_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 119 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 119 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 119 
  wl1271_debugfs_update_stats(wl);
  
#line 119 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->rxpipe.descr_host_int_trig_rx_data);
  
#line 119 
  __retres = (long)tmp;
  
#line 119 
  return __retres;
}


#line 119  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const rxpipe_descr_host_int_trig_rx_data_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & rxpipe_descr_host_int_trig_rx_data_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 120  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t rxpipe_beacon_buffer_thres_host_int_trig_rx_data_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 120 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 120 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 120 
  wl1271_debugfs_update_stats(wl);
  
#line 120 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->rxpipe.beacon_buffer_thres_host_int_trig_rx_data);
  
#line 120 
  __retres = (long)tmp;
  
#line 120 
  return __retres;
}


#line 120  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const rxpipe_beacon_buffer_thres_host_int_trig_rx_data_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & rxpipe_beacon_buffer_thres_host_int_trig_rx_data_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 122  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t rxpipe_missed_beacon_host_int_trig_rx_data_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 122 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 122 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 122 
  wl1271_debugfs_update_stats(wl);
  
#line 122 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->rxpipe.missed_beacon_host_int_trig_rx_data);
  
#line 122 
  __retres = (long)tmp;
  
#line 122 
  return __retres;
}


#line 122  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const rxpipe_missed_beacon_host_int_trig_rx_data_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & rxpipe_missed_beacon_host_int_trig_rx_data_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static ssize_t rxpipe_tx_xfr_host_int_trig_rx_data_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 123 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 123 
  struct wl12xx_acx_statistics *stats = (struct wl12xx_acx_statistics *)wl->stats.fw_stats;
  
#line 123 
  wl1271_debugfs_update_stats(wl);
  
#line 123 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->rxpipe.tx_xfr_host_int_trig_rx_data);
  
#line 123 
  __retres = (long)tmp;
  
#line 123 
  return __retres;
}


#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
static struct file_operations const rxpipe_tx_xfr_host_int_trig_rx_data_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & rxpipe_tx_xfr_host_int_trig_rx_data_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 125  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/debugfs.c"
int wl12xx_debugfs_add_files(struct wl1271 *wl, struct dentry *rootdir)
{
  int __retres;
  struct dentry *entry;
  struct dentry *stats;
  struct dentry *moddir;
  bool tmp_80;
  
#line 128 
  int ret = 0;
  
#line 131 
  moddir = debugfs_create_dir("wl12xx",rootdir);
  
#line 132 
  if (moddir == (struct dentry *)0) 
#line 132 
                                    goto _LOR;
  else {
    bool tmp;
    
#line 132 
    tmp = IS_ERR_0((void const *)moddir);
    
#line 132 
    if ((int)tmp != 0) {
      _LOR: {
              
#line 133 
              entry = moddir;
              
#line 134 
              goto err;
            }
    }
    else ;
  }
  
#line 137 
  stats = debugfs_create_dir("fw_stats",moddir);
  
#line 138 
  if (stats == (struct dentry *)0) 
#line 138 
                                   goto _LOR_0;
  else {
    bool tmp_0;
    
#line 138 
    tmp_0 = IS_ERR_0((void const *)stats);
    
#line 138 
    if ((int)tmp_0 != 0) {
      _LOR_0: {
                
#line 139 
                entry = stats;
                
#line 140 
                goto err;
              }
    }
    else ;
  }
  
#line 143 
  entry = ldv_debugfs_create_file_72("tx_internal_desc_overflow",(unsigned short)256,stats,(void *)wl,& tx_internal_desc_overflow_ops);
  
#line 143 
  if (entry == (struct dentry *)0) 
#line 143 
                                   goto err;
  else {
    bool tmp_1;
    
#line 143 
    tmp_1 = IS_ERR_0((void const *)entry);
    
#line 143 
    if ((int)tmp_1 != 0) 
#line 143 
                         goto err; else ;
  }
  
#line 145 
  entry = ldv_debugfs_create_file_73("rx_out_of_mem",(unsigned short)256,stats,(void *)wl,& rx_out_of_mem_ops);
  
#line 145 
  if (entry == (struct dentry *)0) 
#line 145 
                                   goto err;
  else {
    bool tmp_2;
    
#line 145 
    tmp_2 = IS_ERR_0((void const *)entry);
    
#line 145 
    if ((int)tmp_2 != 0) 
#line 145 
                         goto err; else ;
  }
  
#line 146 
  entry = ldv_debugfs_create_file_74("rx_hdr_overflow",(unsigned short)256,stats,(void *)wl,& rx_hdr_overflow_ops);
  
#line 146 
  if (entry == (struct dentry *)0) 
#line 146 
                                   goto err;
  else {
    bool tmp_3;
    
#line 146 
    tmp_3 = IS_ERR_0((void const *)entry);
    
#line 146 
    if ((int)tmp_3 != 0) 
#line 146 
                         goto err; else ;
  }
  
#line 147 
  entry = ldv_debugfs_create_file_75("rx_hw_stuck",(unsigned short)256,stats,(void *)wl,& rx_hw_stuck_ops);
  
#line 147 
  if (entry == (struct dentry *)0) 
#line 147 
                                   goto err;
  else {
    bool tmp_4;
    
#line 147 
    tmp_4 = IS_ERR_0((void const *)entry);
    
#line 147 
    if ((int)tmp_4 != 0) 
#line 147 
                         goto err; else ;
  }
  
#line 148 
  entry = ldv_debugfs_create_file_76("rx_dropped",(unsigned short)256,stats,(void *)wl,& rx_dropped_ops);
  
#line 148 
  if (entry == (struct dentry *)0) 
#line 148 
                                   goto err;
  else {
    bool tmp_5;
    
#line 148 
    tmp_5 = IS_ERR_0((void const *)entry);
    
#line 148 
    if ((int)tmp_5 != 0) 
#line 148 
                         goto err; else ;
  }
  
#line 149 
  entry = ldv_debugfs_create_file_77("rx_fcs_err",(unsigned short)256,stats,(void *)wl,& rx_fcs_err_ops);
  
#line 149 
  if (entry == (struct dentry *)0) 
#line 149 
                                   goto err;
  else {
    bool tmp_6;
    
#line 149 
    tmp_6 = IS_ERR_0((void const *)entry);
    
#line 149 
    if ((int)tmp_6 != 0) 
#line 149 
                         goto err; else ;
  }
  
#line 150 
  entry = ldv_debugfs_create_file_78("rx_xfr_hint_trig",(unsigned short)256,stats,(void *)wl,& rx_xfr_hint_trig_ops);
  
#line 150 
  if (entry == (struct dentry *)0) 
#line 150 
                                   goto err;
  else {
    bool tmp_7;
    
#line 150 
    tmp_7 = IS_ERR_0((void const *)entry);
    
#line 150 
    if ((int)tmp_7 != 0) 
#line 150 
                         goto err; else ;
  }
  
#line 151 
  entry = ldv_debugfs_create_file_79("rx_path_reset",(unsigned short)256,stats,(void *)wl,& rx_path_reset_ops);
  
#line 151 
  if (entry == (struct dentry *)0) 
#line 151 
                                   goto err;
  else {
    bool tmp_8;
    
#line 151 
    tmp_8 = IS_ERR_0((void const *)entry);
    
#line 151 
    if ((int)tmp_8 != 0) 
#line 151 
                         goto err; else ;
  }
  
#line 152 
  entry = ldv_debugfs_create_file_80("rx_reset_counter",(unsigned short)256,stats,(void *)wl,& rx_reset_counter_ops);
  
#line 152 
  if (entry == (struct dentry *)0) 
#line 152 
                                   goto err;
  else {
    bool tmp_9;
    
#line 152 
    tmp_9 = IS_ERR_0((void const *)entry);
    
#line 152 
    if ((int)tmp_9 != 0) 
#line 152 
                         goto err; else ;
  }
  
#line 154 
  entry = ldv_debugfs_create_file_81("dma_rx_requested",(unsigned short)256,stats,(void *)wl,& dma_rx_requested_ops);
  
#line 154 
  if (entry == (struct dentry *)0) 
#line 154 
                                   goto err;
  else {
    bool tmp_10;
    
#line 154 
    tmp_10 = IS_ERR_0((void const *)entry);
    
#line 154 
    if ((int)tmp_10 != 0) 
#line 154 
                          goto err; else ;
  }
  
#line 155 
  entry = ldv_debugfs_create_file_82("dma_rx_errors",(unsigned short)256,stats,(void *)wl,& dma_rx_errors_ops);
  
#line 155 
  if (entry == (struct dentry *)0) 
#line 155 
                                   goto err;
  else {
    bool tmp_11;
    
#line 155 
    tmp_11 = IS_ERR_0((void const *)entry);
    
#line 155 
    if ((int)tmp_11 != 0) 
#line 155 
                          goto err; else ;
  }
  
#line 156 
  entry = ldv_debugfs_create_file_83("dma_tx_requested",(unsigned short)256,stats,(void *)wl,& dma_tx_requested_ops);
  
#line 156 
  if (entry == (struct dentry *)0) 
#line 156 
                                   goto err;
  else {
    bool tmp_12;
    
#line 156 
    tmp_12 = IS_ERR_0((void const *)entry);
    
#line 156 
    if ((int)tmp_12 != 0) 
#line 156 
                          goto err; else ;
  }
  
#line 157 
  entry = ldv_debugfs_create_file_84("dma_tx_errors",(unsigned short)256,stats,(void *)wl,& dma_tx_errors_ops);
  
#line 157 
  if (entry == (struct dentry *)0) 
#line 157 
                                   goto err;
  else {
    bool tmp_13;
    
#line 157 
    tmp_13 = IS_ERR_0((void const *)entry);
    
#line 157 
    if ((int)tmp_13 != 0) 
#line 157 
                          goto err; else ;
  }
  
#line 159 
  entry = ldv_debugfs_create_file_85("isr_cmd_cmplt",(unsigned short)256,stats,(void *)wl,& isr_cmd_cmplt_ops);
  
#line 159 
  if (entry == (struct dentry *)0) 
#line 159 
                                   goto err;
  else {
    bool tmp_14;
    
#line 159 
    tmp_14 = IS_ERR_0((void const *)entry);
    
#line 159 
    if ((int)tmp_14 != 0) 
#line 159 
                          goto err; else ;
  }
  
#line 160 
  entry = ldv_debugfs_create_file_86("isr_fiqs",(unsigned short)256,stats,(void *)wl,& isr_fiqs_ops);
  
#line 160 
  if (entry == (struct dentry *)0) 
#line 160 
                                   goto err;
  else {
    bool tmp_15;
    
#line 160 
    tmp_15 = IS_ERR_0((void const *)entry);
    
#line 160 
    if ((int)tmp_15 != 0) 
#line 160 
                          goto err; else ;
  }
  
#line 161 
  entry = ldv_debugfs_create_file_87("isr_rx_headers",(unsigned short)256,stats,(void *)wl,& isr_rx_headers_ops);
  
#line 161 
  if (entry == (struct dentry *)0) 
#line 161 
                                   goto err;
  else {
    bool tmp_16;
    
#line 161 
    tmp_16 = IS_ERR_0((void const *)entry);
    
#line 161 
    if ((int)tmp_16 != 0) 
#line 161 
                          goto err; else ;
  }
  
#line 162 
  entry = ldv_debugfs_create_file_88("isr_rx_mem_overflow",(unsigned short)256,stats,(void *)wl,& isr_rx_mem_overflow_ops);
  
#line 162 
  if (entry == (struct dentry *)0) 
#line 162 
                                   goto err;
  else {
    bool tmp_17;
    
#line 162 
    tmp_17 = IS_ERR_0((void const *)entry);
    
#line 162 
    if ((int)tmp_17 != 0) 
#line 162 
                          goto err; else ;
  }
  
#line 163 
  entry = ldv_debugfs_create_file_89("isr_rx_rdys",(unsigned short)256,stats,(void *)wl,& isr_rx_rdys_ops);
  
#line 163 
  if (entry == (struct dentry *)0) 
#line 163 
                                   goto err;
  else {
    bool tmp_18;
    
#line 163 
    tmp_18 = IS_ERR_0((void const *)entry);
    
#line 163 
    if ((int)tmp_18 != 0) 
#line 163 
                          goto err; else ;
  }
  
#line 164 
  entry = ldv_debugfs_create_file_90("isr_irqs",(unsigned short)256,stats,(void *)wl,& isr_irqs_ops);
  
#line 164 
  if (entry == (struct dentry *)0) 
#line 164 
                                   goto err;
  else {
    bool tmp_19;
    
#line 164 
    tmp_19 = IS_ERR_0((void const *)entry);
    
#line 164 
    if ((int)tmp_19 != 0) 
#line 164 
                          goto err; else ;
  }
  
#line 165 
  entry = ldv_debugfs_create_file_91("isr_tx_procs",(unsigned short)256,stats,(void *)wl,& isr_tx_procs_ops);
  
#line 165 
  if (entry == (struct dentry *)0) 
#line 165 
                                   goto err;
  else {
    bool tmp_20;
    
#line 165 
    tmp_20 = IS_ERR_0((void const *)entry);
    
#line 165 
    if ((int)tmp_20 != 0) 
#line 165 
                          goto err; else ;
  }
  
#line 166 
  entry = ldv_debugfs_create_file_92("isr_decrypt_done",(unsigned short)256,stats,(void *)wl,& isr_decrypt_done_ops);
  
#line 166 
  if (entry == (struct dentry *)0) 
#line 166 
                                   goto err;
  else {
    bool tmp_21;
    
#line 166 
    tmp_21 = IS_ERR_0((void const *)entry);
    
#line 166 
    if ((int)tmp_21 != 0) 
#line 166 
                          goto err; else ;
  }
  
#line 167 
  entry = ldv_debugfs_create_file_93("isr_dma0_done",(unsigned short)256,stats,(void *)wl,& isr_dma0_done_ops);
  
#line 167 
  if (entry == (struct dentry *)0) 
#line 167 
                                   goto err;
  else {
    bool tmp_22;
    
#line 167 
    tmp_22 = IS_ERR_0((void const *)entry);
    
#line 167 
    if ((int)tmp_22 != 0) 
#line 167 
                          goto err; else ;
  }
  
#line 168 
  entry = ldv_debugfs_create_file_94("isr_dma1_done",(unsigned short)256,stats,(void *)wl,& isr_dma1_done_ops);
  
#line 168 
  if (entry == (struct dentry *)0) 
#line 168 
                                   goto err;
  else {
    bool tmp_23;
    
#line 168 
    tmp_23 = IS_ERR_0((void const *)entry);
    
#line 168 
    if ((int)tmp_23 != 0) 
#line 168 
                          goto err; else ;
  }
  
#line 169 
  entry = ldv_debugfs_create_file_95("isr_tx_exch_complete",(unsigned short)256,stats,(void *)wl,& isr_tx_exch_complete_ops);
  
#line 169 
  if (entry == (struct dentry *)0) 
#line 169 
                                   goto err;
  else {
    bool tmp_24;
    
#line 169 
    tmp_24 = IS_ERR_0((void const *)entry);
    
#line 169 
    if ((int)tmp_24 != 0) 
#line 169 
                          goto err; else ;
  }
  
#line 170 
  entry = ldv_debugfs_create_file_96("isr_commands",(unsigned short)256,stats,(void *)wl,& isr_commands_ops);
  
#line 170 
  if (entry == (struct dentry *)0) 
#line 170 
                                   goto err;
  else {
    bool tmp_25;
    
#line 170 
    tmp_25 = IS_ERR_0((void const *)entry);
    
#line 170 
    if ((int)tmp_25 != 0) 
#line 170 
                          goto err; else ;
  }
  
#line 171 
  entry = ldv_debugfs_create_file_97("isr_rx_procs",(unsigned short)256,stats,(void *)wl,& isr_rx_procs_ops);
  
#line 171 
  if (entry == (struct dentry *)0) 
#line 171 
                                   goto err;
  else {
    bool tmp_26;
    
#line 171 
    tmp_26 = IS_ERR_0((void const *)entry);
    
#line 171 
    if ((int)tmp_26 != 0) 
#line 171 
                          goto err; else ;
  }
  
#line 172 
  entry = ldv_debugfs_create_file_98("isr_hw_pm_mode_changes",(unsigned short)256,stats,(void *)wl,& isr_hw_pm_mode_changes_ops);
  
#line 172 
  if (entry == (struct dentry *)0) 
#line 172 
                                   goto err;
  else {
    bool tmp_27;
    
#line 172 
    tmp_27 = IS_ERR_0((void const *)entry);
    
#line 172 
    if ((int)tmp_27 != 0) 
#line 172 
                          goto err; else ;
  }
  
#line 173 
  entry = ldv_debugfs_create_file_99("isr_host_acknowledges",(unsigned short)256,stats,(void *)wl,& isr_host_acknowledges_ops);
  
#line 173 
  if (entry == (struct dentry *)0) 
#line 173 
                                   goto err;
  else {
    bool tmp_28;
    
#line 173 
    tmp_28 = IS_ERR_0((void const *)entry);
    
#line 173 
    if ((int)tmp_28 != 0) 
#line 173 
                          goto err; else ;
  }
  
#line 174 
  entry = ldv_debugfs_create_file_100("isr_pci_pm",(unsigned short)256,stats,(void *)wl,& isr_pci_pm_ops);
  
#line 174 
  if (entry == (struct dentry *)0) 
#line 174 
                                   goto err;
  else {
    bool tmp_29;
    
#line 174 
    tmp_29 = IS_ERR_0((void const *)entry);
    
#line 174 
    if ((int)tmp_29 != 0) 
#line 174 
                          goto err; else ;
  }
  
#line 175 
  entry = ldv_debugfs_create_file_101("isr_wakeups",(unsigned short)256,stats,(void *)wl,& isr_wakeups_ops);
  
#line 175 
  if (entry == (struct dentry *)0) 
#line 175 
                                   goto err;
  else {
    bool tmp_30;
    
#line 175 
    tmp_30 = IS_ERR_0((void const *)entry);
    
#line 175 
    if ((int)tmp_30 != 0) 
#line 175 
                          goto err; else ;
  }
  
#line 176 
  entry = ldv_debugfs_create_file_102("isr_low_rssi",(unsigned short)256,stats,(void *)wl,& isr_low_rssi_ops);
  
#line 176 
  if (entry == (struct dentry *)0) 
#line 176 
                                   goto err;
  else {
    bool tmp_31;
    
#line 176 
    tmp_31 = IS_ERR_0((void const *)entry);
    
#line 176 
    if ((int)tmp_31 != 0) 
#line 176 
                          goto err; else ;
  }
  
#line 178 
  entry = ldv_debugfs_create_file_103("wep_addr_key_count",(unsigned short)256,stats,(void *)wl,& wep_addr_key_count_ops);
  
#line 178 
  if (entry == (struct dentry *)0) 
#line 178 
                                   goto err;
  else {
    bool tmp_32;
    
#line 178 
    tmp_32 = IS_ERR_0((void const *)entry);
    
#line 178 
    if ((int)tmp_32 != 0) 
#line 178 
                          goto err; else ;
  }
  
#line 179 
  entry = ldv_debugfs_create_file_104("wep_default_key_count",(unsigned short)256,stats,(void *)wl,& wep_default_key_count_ops);
  
#line 179 
  if (entry == (struct dentry *)0) 
#line 179 
                                   goto err;
  else {
    bool tmp_33;
    
#line 179 
    tmp_33 = IS_ERR_0((void const *)entry);
    
#line 179 
    if ((int)tmp_33 != 0) 
#line 179 
                          goto err; else ;
  }
  
#line 181 
  entry = ldv_debugfs_create_file_105("wep_key_not_found",(unsigned short)256,stats,(void *)wl,& wep_key_not_found_ops);
  
#line 181 
  if (entry == (struct dentry *)0) 
#line 181 
                                   goto err;
  else {
    bool tmp_34;
    
#line 181 
    tmp_34 = IS_ERR_0((void const *)entry);
    
#line 181 
    if ((int)tmp_34 != 0) 
#line 181 
                          goto err; else ;
  }
  
#line 182 
  entry = ldv_debugfs_create_file_106("wep_decrypt_fail",(unsigned short)256,stats,(void *)wl,& wep_decrypt_fail_ops);
  
#line 182 
  if (entry == (struct dentry *)0) 
#line 182 
                                   goto err;
  else {
    bool tmp_35;
    
#line 182 
    tmp_35 = IS_ERR_0((void const *)entry);
    
#line 182 
    if ((int)tmp_35 != 0) 
#line 182 
                          goto err; else ;
  }
  
#line 183 
  entry = ldv_debugfs_create_file_107("wep_packets",(unsigned short)256,stats,(void *)wl,& wep_packets_ops);
  
#line 183 
  if (entry == (struct dentry *)0) 
#line 183 
                                   goto err;
  else {
    bool tmp_36;
    
#line 183 
    tmp_36 = IS_ERR_0((void const *)entry);
    
#line 183 
    if ((int)tmp_36 != 0) 
#line 183 
                          goto err; else ;
  }
  
#line 184 
  entry = ldv_debugfs_create_file_108("wep_interrupt",(unsigned short)256,stats,(void *)wl,& wep_interrupt_ops);
  
#line 184 
  if (entry == (struct dentry *)0) 
#line 184 
                                   goto err;
  else {
    bool tmp_37;
    
#line 184 
    tmp_37 = IS_ERR_0((void const *)entry);
    
#line 184 
    if ((int)tmp_37 != 0) 
#line 184 
                          goto err; else ;
  }
  
#line 186 
  entry = ldv_debugfs_create_file_109("pwr_ps_enter",(unsigned short)256,stats,(void *)wl,& pwr_ps_enter_ops);
  
#line 186 
  if (entry == (struct dentry *)0) 
#line 186 
                                   goto err;
  else {
    bool tmp_38;
    
#line 186 
    tmp_38 = IS_ERR_0((void const *)entry);
    
#line 186 
    if ((int)tmp_38 != 0) 
#line 186 
                          goto err; else ;
  }
  
#line 187 
  entry = ldv_debugfs_create_file_110("pwr_elp_enter",(unsigned short)256,stats,(void *)wl,& pwr_elp_enter_ops);
  
#line 187 
  if (entry == (struct dentry *)0) 
#line 187 
                                   goto err;
  else {
    bool tmp_39;
    
#line 187 
    tmp_39 = IS_ERR_0((void const *)entry);
    
#line 187 
    if ((int)tmp_39 != 0) 
#line 187 
                          goto err; else ;
  }
  
#line 188 
  entry = ldv_debugfs_create_file_111("pwr_missing_bcns",(unsigned short)256,stats,(void *)wl,& pwr_missing_bcns_ops);
  
#line 188 
  if (entry == (struct dentry *)0) 
#line 188 
                                   goto err;
  else {
    bool tmp_40;
    
#line 188 
    tmp_40 = IS_ERR_0((void const *)entry);
    
#line 188 
    if ((int)tmp_40 != 0) 
#line 188 
                          goto err; else ;
  }
  
#line 189 
  entry = ldv_debugfs_create_file_112("pwr_wake_on_host",(unsigned short)256,stats,(void *)wl,& pwr_wake_on_host_ops);
  
#line 189 
  if (entry == (struct dentry *)0) 
#line 189 
                                   goto err;
  else {
    bool tmp_41;
    
#line 189 
    tmp_41 = IS_ERR_0((void const *)entry);
    
#line 189 
    if ((int)tmp_41 != 0) 
#line 189 
                          goto err; else ;
  }
  
#line 190 
  entry = ldv_debugfs_create_file_113("pwr_wake_on_timer_exp",(unsigned short)256,stats,(void *)wl,& pwr_wake_on_timer_exp_ops);
  
#line 190 
  if (entry == (struct dentry *)0) 
#line 190 
                                   goto err;
  else {
    bool tmp_42;
    
#line 190 
    tmp_42 = IS_ERR_0((void const *)entry);
    
#line 190 
    if ((int)tmp_42 != 0) 
#line 190 
                          goto err; else ;
  }
  
#line 191 
  entry = ldv_debugfs_create_file_114("pwr_tx_with_ps",(unsigned short)256,stats,(void *)wl,& pwr_tx_with_ps_ops);
  
#line 191 
  if (entry == (struct dentry *)0) 
#line 191 
                                   goto err;
  else {
    bool tmp_43;
    
#line 191 
    tmp_43 = IS_ERR_0((void const *)entry);
    
#line 191 
    if ((int)tmp_43 != 0) 
#line 191 
                          goto err; else ;
  }
  
#line 192 
  entry = ldv_debugfs_create_file_115("pwr_tx_without_ps",(unsigned short)256,stats,(void *)wl,& pwr_tx_without_ps_ops);
  
#line 192 
  if (entry == (struct dentry *)0) 
#line 192 
                                   goto err;
  else {
    bool tmp_44;
    
#line 192 
    tmp_44 = IS_ERR_0((void const *)entry);
    
#line 192 
    if ((int)tmp_44 != 0) 
#line 192 
                          goto err; else ;
  }
  
#line 193 
  entry = ldv_debugfs_create_file_116("pwr_rcvd_beacons",(unsigned short)256,stats,(void *)wl,& pwr_rcvd_beacons_ops);
  
#line 193 
  if (entry == (struct dentry *)0) 
#line 193 
                                   goto err;
  else {
    bool tmp_45;
    
#line 193 
    tmp_45 = IS_ERR_0((void const *)entry);
    
#line 193 
    if ((int)tmp_45 != 0) 
#line 193 
                          goto err; else ;
  }
  
#line 194 
  entry = ldv_debugfs_create_file_117("pwr_power_save_off",(unsigned short)256,stats,(void *)wl,& pwr_power_save_off_ops);
  
#line 194 
  if (entry == (struct dentry *)0) 
#line 194 
                                   goto err;
  else {
    bool tmp_46;
    
#line 194 
    tmp_46 = IS_ERR_0((void const *)entry);
    
#line 194 
    if ((int)tmp_46 != 0) 
#line 194 
                          goto err; else ;
  }
  
#line 195 
  entry = ldv_debugfs_create_file_118("pwr_enable_ps",(unsigned short)256,stats,(void *)wl,& pwr_enable_ps_ops);
  
#line 195 
  if (entry == (struct dentry *)0) 
#line 195 
                                   goto err;
  else {
    bool tmp_47;
    
#line 195 
    tmp_47 = IS_ERR_0((void const *)entry);
    
#line 195 
    if ((int)tmp_47 != 0) 
#line 195 
                          goto err; else ;
  }
  
#line 196 
  entry = ldv_debugfs_create_file_119("pwr_disable_ps",(unsigned short)256,stats,(void *)wl,& pwr_disable_ps_ops);
  
#line 196 
  if (entry == (struct dentry *)0) 
#line 196 
                                   goto err;
  else {
    bool tmp_48;
    
#line 196 
    tmp_48 = IS_ERR_0((void const *)entry);
    
#line 196 
    if ((int)tmp_48 != 0) 
#line 196 
                          goto err; else ;
  }
  
#line 197 
  entry = ldv_debugfs_create_file_120("pwr_fix_tsf_ps",(unsigned short)256,stats,(void *)wl,& pwr_fix_tsf_ps_ops);
  
#line 197 
  if (entry == (struct dentry *)0) 
#line 197 
                                   goto err;
  else {
    bool tmp_49;
    
#line 197 
    tmp_49 = IS_ERR_0((void const *)entry);
    
#line 197 
    if ((int)tmp_49 != 0) 
#line 197 
                          goto err; else ;
  }
  
#line 199 
  entry = ldv_debugfs_create_file_121("pwr_rcvd_awake_beacons",(unsigned short)256,stats,(void *)wl,& pwr_rcvd_awake_beacons_ops);
  
#line 199 
  if (entry == (struct dentry *)0) 
#line 199 
                                   goto err;
  else {
    bool tmp_50;
    
#line 199 
    tmp_50 = IS_ERR_0((void const *)entry);
    
#line 199 
    if ((int)tmp_50 != 0) 
#line 199 
                          goto err; else ;
  }
  
#line 201 
  entry = ldv_debugfs_create_file_122("mic_rx_pkts",(unsigned short)256,stats,(void *)wl,& mic_rx_pkts_ops);
  
#line 201 
  if (entry == (struct dentry *)0) 
#line 201 
                                   goto err;
  else {
    bool tmp_51;
    
#line 201 
    tmp_51 = IS_ERR_0((void const *)entry);
    
#line 201 
    if ((int)tmp_51 != 0) 
#line 201 
                          goto err; else ;
  }
  
#line 202 
  entry = ldv_debugfs_create_file_123("mic_calc_failure",(unsigned short)256,stats,(void *)wl,& mic_calc_failure_ops);
  
#line 202 
  if (entry == (struct dentry *)0) 
#line 202 
                                   goto err;
  else {
    bool tmp_52;
    
#line 202 
    tmp_52 = IS_ERR_0((void const *)entry);
    
#line 202 
    if ((int)tmp_52 != 0) 
#line 202 
                          goto err; else ;
  }
  
#line 204 
  entry = ldv_debugfs_create_file_124("aes_encrypt_fail",(unsigned short)256,stats,(void *)wl,& aes_encrypt_fail_ops);
  
#line 204 
  if (entry == (struct dentry *)0) 
#line 204 
                                   goto err;
  else {
    bool tmp_53;
    
#line 204 
    tmp_53 = IS_ERR_0((void const *)entry);
    
#line 204 
    if ((int)tmp_53 != 0) 
#line 204 
                          goto err; else ;
  }
  
#line 205 
  entry = ldv_debugfs_create_file_125("aes_decrypt_fail",(unsigned short)256,stats,(void *)wl,& aes_decrypt_fail_ops);
  
#line 205 
  if (entry == (struct dentry *)0) 
#line 205 
                                   goto err;
  else {
    bool tmp_54;
    
#line 205 
    tmp_54 = IS_ERR_0((void const *)entry);
    
#line 205 
    if ((int)tmp_54 != 0) 
#line 205 
                          goto err; else ;
  }
  
#line 206 
  entry = ldv_debugfs_create_file_126("aes_encrypt_packets",(unsigned short)256,stats,(void *)wl,& aes_encrypt_packets_ops);
  
#line 206 
  if (entry == (struct dentry *)0) 
#line 206 
                                   goto err;
  else {
    bool tmp_55;
    
#line 206 
    tmp_55 = IS_ERR_0((void const *)entry);
    
#line 206 
    if ((int)tmp_55 != 0) 
#line 206 
                          goto err; else ;
  }
  
#line 207 
  entry = ldv_debugfs_create_file_127("aes_decrypt_packets",(unsigned short)256,stats,(void *)wl,& aes_decrypt_packets_ops);
  
#line 207 
  if (entry == (struct dentry *)0) 
#line 207 
                                   goto err;
  else {
    bool tmp_56;
    
#line 207 
    tmp_56 = IS_ERR_0((void const *)entry);
    
#line 207 
    if ((int)tmp_56 != 0) 
#line 207 
                          goto err; else ;
  }
  
#line 208 
  entry = ldv_debugfs_create_file_128("aes_encrypt_interrupt",(unsigned short)256,stats,(void *)wl,& aes_encrypt_interrupt_ops);
  
#line 208 
  if (entry == (struct dentry *)0) 
#line 208 
                                   goto err;
  else {
    bool tmp_57;
    
#line 208 
    tmp_57 = IS_ERR_0((void const *)entry);
    
#line 208 
    if ((int)tmp_57 != 0) 
#line 208 
                          goto err; else ;
  }
  
#line 209 
  entry = ldv_debugfs_create_file_129("aes_decrypt_interrupt",(unsigned short)256,stats,(void *)wl,& aes_decrypt_interrupt_ops);
  
#line 209 
  if (entry == (struct dentry *)0) 
#line 209 
                                   goto err;
  else {
    bool tmp_58;
    
#line 209 
    tmp_58 = IS_ERR_0((void const *)entry);
    
#line 209 
    if ((int)tmp_58 != 0) 
#line 209 
                          goto err; else ;
  }
  
#line 211 
  entry = ldv_debugfs_create_file_130("event_heart_beat",(unsigned short)256,stats,(void *)wl,& event_heart_beat_ops);
  
#line 211 
  if (entry == (struct dentry *)0) 
#line 211 
                                   goto err;
  else {
    bool tmp_59;
    
#line 211 
    tmp_59 = IS_ERR_0((void const *)entry);
    
#line 211 
    if ((int)tmp_59 != 0) 
#line 211 
                          goto err; else ;
  }
  
#line 212 
  entry = ldv_debugfs_create_file_131("event_calibration",(unsigned short)256,stats,(void *)wl,& event_calibration_ops);
  
#line 212 
  if (entry == (struct dentry *)0) 
#line 212 
                                   goto err;
  else {
    bool tmp_60;
    
#line 212 
    tmp_60 = IS_ERR_0((void const *)entry);
    
#line 212 
    if ((int)tmp_60 != 0) 
#line 212 
                          goto err; else ;
  }
  
#line 213 
  entry = ldv_debugfs_create_file_132("event_rx_mismatch",(unsigned short)256,stats,(void *)wl,& event_rx_mismatch_ops);
  
#line 213 
  if (entry == (struct dentry *)0) 
#line 213 
                                   goto err;
  else {
    bool tmp_61;
    
#line 213 
    tmp_61 = IS_ERR_0((void const *)entry);
    
#line 213 
    if ((int)tmp_61 != 0) 
#line 213 
                          goto err; else ;
  }
  
#line 214 
  entry = ldv_debugfs_create_file_133("event_rx_mem_empty",(unsigned short)256,stats,(void *)wl,& event_rx_mem_empty_ops);
  
#line 214 
  if (entry == (struct dentry *)0) 
#line 214 
                                   goto err;
  else {
    bool tmp_62;
    
#line 214 
    tmp_62 = IS_ERR_0((void const *)entry);
    
#line 214 
    if ((int)tmp_62 != 0) 
#line 214 
                          goto err; else ;
  }
  
#line 215 
  entry = ldv_debugfs_create_file_134("event_rx_pool",(unsigned short)256,stats,(void *)wl,& event_rx_pool_ops);
  
#line 215 
  if (entry == (struct dentry *)0) 
#line 215 
                                   goto err;
  else {
    bool tmp_63;
    
#line 215 
    tmp_63 = IS_ERR_0((void const *)entry);
    
#line 215 
    if ((int)tmp_63 != 0) 
#line 215 
                          goto err; else ;
  }
  
#line 216 
  entry = ldv_debugfs_create_file_135("event_oom_late",(unsigned short)256,stats,(void *)wl,& event_oom_late_ops);
  
#line 216 
  if (entry == (struct dentry *)0) 
#line 216 
                                   goto err;
  else {
    bool tmp_64;
    
#line 216 
    tmp_64 = IS_ERR_0((void const *)entry);
    
#line 216 
    if ((int)tmp_64 != 0) 
#line 216 
                          goto err; else ;
  }
  
#line 217 
  entry = ldv_debugfs_create_file_136("event_phy_transmit_error",(unsigned short)256,stats,(void *)wl,& event_phy_transmit_error_ops);
  
#line 217 
  if (entry == (struct dentry *)0) 
#line 217 
                                   goto err;
  else {
    bool tmp_65;
    
#line 217 
    tmp_65 = IS_ERR_0((void const *)entry);
    
#line 217 
    if ((int)tmp_65 != 0) 
#line 217 
                          goto err; else ;
  }
  
#line 218 
  entry = ldv_debugfs_create_file_137("event_tx_stuck",(unsigned short)256,stats,(void *)wl,& event_tx_stuck_ops);
  
#line 218 
  if (entry == (struct dentry *)0) 
#line 218 
                                   goto err;
  else {
    bool tmp_66;
    
#line 218 
    tmp_66 = IS_ERR_0((void const *)entry);
    
#line 218 
    if ((int)tmp_66 != 0) 
#line 218 
                          goto err; else ;
  }
  
#line 220 
  entry = ldv_debugfs_create_file_138("ps_pspoll_timeouts",(unsigned short)256,stats,(void *)wl,& ps_pspoll_timeouts_ops);
  
#line 220 
  if (entry == (struct dentry *)0) 
#line 220 
                                   goto err;
  else {
    bool tmp_67;
    
#line 220 
    tmp_67 = IS_ERR_0((void const *)entry);
    
#line 220 
    if ((int)tmp_67 != 0) 
#line 220 
                          goto err; else ;
  }
  
#line 221 
  entry = ldv_debugfs_create_file_139("ps_upsd_timeouts",(unsigned short)256,stats,(void *)wl,& ps_upsd_timeouts_ops);
  
#line 221 
  if (entry == (struct dentry *)0) 
#line 221 
                                   goto err;
  else {
    bool tmp_68;
    
#line 221 
    tmp_68 = IS_ERR_0((void const *)entry);
    
#line 221 
    if ((int)tmp_68 != 0) 
#line 221 
                          goto err; else ;
  }
  
#line 222 
  entry = ldv_debugfs_create_file_140("ps_upsd_max_sptime",(unsigned short)256,stats,(void *)wl,& ps_upsd_max_sptime_ops);
  
#line 222 
  if (entry == (struct dentry *)0) 
#line 222 
                                   goto err;
  else {
    bool tmp_69;
    
#line 222 
    tmp_69 = IS_ERR_0((void const *)entry);
    
#line 222 
    if ((int)tmp_69 != 0) 
#line 222 
                          goto err; else ;
  }
  
#line 223 
  entry = ldv_debugfs_create_file_141("ps_upsd_max_apturn",(unsigned short)256,stats,(void *)wl,& ps_upsd_max_apturn_ops);
  
#line 223 
  if (entry == (struct dentry *)0) 
#line 223 
                                   goto err;
  else {
    bool tmp_70;
    
#line 223 
    tmp_70 = IS_ERR_0((void const *)entry);
    
#line 223 
    if ((int)tmp_70 != 0) 
#line 223 
                          goto err; else ;
  }
  
#line 224 
  entry = ldv_debugfs_create_file_142("ps_pspoll_max_apturn",(unsigned short)256,stats,(void *)wl,& ps_pspoll_max_apturn_ops);
  
#line 224 
  if (entry == (struct dentry *)0) 
#line 224 
                                   goto err;
  else {
    bool tmp_71;
    
#line 224 
    tmp_71 = IS_ERR_0((void const *)entry);
    
#line 224 
    if ((int)tmp_71 != 0) 
#line 224 
                          goto err; else ;
  }
  
#line 225 
  entry = ldv_debugfs_create_file_143("ps_pspoll_utilization",(unsigned short)256,stats,(void *)wl,& ps_pspoll_utilization_ops);
  
#line 225 
  if (entry == (struct dentry *)0) 
#line 225 
                                   goto err;
  else {
    bool tmp_72;
    
#line 225 
    tmp_72 = IS_ERR_0((void const *)entry);
    
#line 225 
    if ((int)tmp_72 != 0) 
#line 225 
                          goto err; else ;
  }
  
#line 226 
  entry = ldv_debugfs_create_file_144("ps_upsd_utilization",(unsigned short)256,stats,(void *)wl,& ps_upsd_utilization_ops);
  
#line 226 
  if (entry == (struct dentry *)0) 
#line 226 
                                   goto err;
  else {
    bool tmp_73;
    
#line 226 
    tmp_73 = IS_ERR_0((void const *)entry);
    
#line 226 
    if ((int)tmp_73 != 0) 
#line 226 
                          goto err; else ;
  }
  
#line 228 
  entry = ldv_debugfs_create_file_145("rxpipe_rx_prep_beacon_drop",(unsigned short)256,stats,(void *)wl,& rxpipe_rx_prep_beacon_drop_ops);
  
#line 228 
  if (entry == (struct dentry *)0) 
#line 228 
                                   goto err;
  else {
    bool tmp_74;
    
#line 228 
    tmp_74 = IS_ERR_0((void const *)entry);
    
#line 228 
    if ((int)tmp_74 != 0) 
#line 228 
                          goto err; else ;
  }
  
#line 229 
  entry = ldv_debugfs_create_file_146("rxpipe_descr_host_int_trig_rx_data",(unsigned short)256,stats,(void *)wl,& rxpipe_descr_host_int_trig_rx_data_ops);
  
#line 229 
  if (entry == (struct dentry *)0) 
#line 229 
                                   goto err;
  else {
    bool tmp_75;
    
#line 229 
    tmp_75 = IS_ERR_0((void const *)entry);
    
#line 229 
    if ((int)tmp_75 != 0) 
#line 229 
                          goto err; else ;
  }
  
#line 230 
  entry = ldv_debugfs_create_file_147("rxpipe_beacon_buffer_thres_host_int_trig_rx_data",(unsigned short)256,stats,(void *)wl,& rxpipe_beacon_buffer_thres_host_int_trig_rx_data_ops);
  
#line 230 
  if (entry == (struct dentry *)0) 
#line 230 
                                   goto err;
  else {
    bool tmp_76;
    
#line 230 
    tmp_76 = IS_ERR_0((void const *)entry);
    
#line 230 
    if ((int)tmp_76 != 0) 
#line 230 
                          goto err; else ;
  }
  
#line 231 
  entry = ldv_debugfs_create_file_148("rxpipe_missed_beacon_host_int_trig_rx_data",(unsigned short)256,stats,(void *)wl,& rxpipe_missed_beacon_host_int_trig_rx_data_ops);
  
#line 231 
  if (entry == (struct dentry *)0) 
#line 231 
                                   goto err;
  else {
    bool tmp_77;
    
#line 231 
    tmp_77 = IS_ERR_0((void const *)entry);
    
#line 231 
    if ((int)tmp_77 != 0) 
#line 231 
                          goto err; else ;
  }
  
#line 232 
  entry = ldv_debugfs_create_file_149("rxpipe_tx_xfr_host_int_trig_rx_data",(unsigned short)256,stats,(void *)wl,& rxpipe_tx_xfr_host_int_trig_rx_data_ops);
  
#line 232 
  if (entry == (struct dentry *)0) 
#line 232 
                                   goto err;
  else {
    bool tmp_78;
    
#line 232 
    tmp_78 = IS_ERR_0((void const *)entry);
    
#line 232 
    if ((int)tmp_78 != 0) 
#line 232 
                          goto err; else ;
  }
  
#line 234 
  __retres = 0;
  
#line 234 
  goto return_label;
  err: 
#line 236 
  ;
  
#line 237 
  tmp_80 = IS_ERR_0((void const *)entry);
  
#line 237 
  if ((int)tmp_80 != 0) {
    long tmp_79;
    
#line 238 
    tmp_79 = PTR_ERR_0((void const *)entry);
    
#line 238 
    ret = (int)tmp_79;
  }
  else 
#line 240 
       ret = -12;
  
#line 242 
  __retres = ret;
  return_label: 
#line 242 
                return __retres;
}


#line 56  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_rxpipe_descr_host_int_trig_rx_data_ops_2 = (struct file_operations *)(& rxpipe_descr_host_int_trig_rx_data_ops);

#line 57  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_rxpipe_tx_xfr_host_int_trig_rx_data_ops_2 = (struct file_operations *)(& rxpipe_tx_xfr_host_int_trig_rx_data_ops);

#line 58  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_wep_decrypt_fail_ops_2 = (struct file_operations *)(& wep_decrypt_fail_ops);

#line 59  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_event_phy_transmit_error_ops_2 = (struct file_operations *)(& event_phy_transmit_error_ops);

#line 60  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_rx_reset_counter_ops_2 = (struct file_operations *)(& rx_reset_counter_ops);

#line 61  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_rxpipe_missed_beacon_host_int_trig_rx_data_ops_2 = (struct file_operations *)(& rxpipe_missed_beacon_host_int_trig_rx_data_ops);

#line 62  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_pwr_fix_tsf_ps_ops_2 = (struct file_operations *)(& pwr_fix_tsf_ps_ops);

#line 63  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_aes_decrypt_fail_ops_2 = (struct file_operations *)(& aes_decrypt_fail_ops);

#line 64  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_rx_fcs_err_ops_2 = (struct file_operations *)(& rx_fcs_err_ops);

#line 65  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_isr_cmd_cmplt_ops_2 = (struct file_operations *)(& isr_cmd_cmplt_ops);

#line 66  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_isr_rx_mem_overflow_ops_2 = (struct file_operations *)(& isr_rx_mem_overflow_ops);

#line 67  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_isr_tx_procs_ops_2 = (struct file_operations *)(& isr_tx_procs_ops);

#line 68  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_rx_xfr_hint_trig_ops_2 = (struct file_operations *)(& rx_xfr_hint_trig_ops);

#line 69  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_isr_decrypt_done_ops_2 = (struct file_operations *)(& isr_decrypt_done_ops);

#line 70  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_event_tx_stuck_ops_2 = (struct file_operations *)(& event_tx_stuck_ops);

#line 71  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_isr_low_rssi_ops_2 = (struct file_operations *)(& isr_low_rssi_ops);

#line 72  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
int (*ldv_emg_alias_simple_open_5)(struct inode *, struct file *) = & simple_open;

#line 73  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_wep_default_key_count_ops_2 = (struct file_operations *)(& wep_default_key_count_ops);

#line 74  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_pwr_rcvd_beacons_ops_2 = (struct file_operations *)(& pwr_rcvd_beacons_ops);

#line 75  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_dma_rx_requested_ops_2 = (struct file_operations *)(& dma_rx_requested_ops);

#line 76  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_isr_rx_headers_ops_2 = (struct file_operations *)(& isr_rx_headers_ops);

#line 77  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_event_rx_mismatch_ops_2 = (struct file_operations *)(& event_rx_mismatch_ops);

#line 78  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_pwr_power_save_off_ops_2 = (struct file_operations *)(& pwr_power_save_off_ops);

#line 79  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_isr_rx_rdys_ops_2 = (struct file_operations *)(& isr_rx_rdys_ops);

#line 80  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_dma_tx_requested_ops_2 = (struct file_operations *)(& dma_tx_requested_ops);

#line 81  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_event_oom_late_ops_2 = (struct file_operations *)(& event_oom_late_ops);

#line 82  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_pwr_enable_ps_ops_2 = (struct file_operations *)(& pwr_enable_ps_ops);

#line 83  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_isr_irqs_ops_2 = (struct file_operations *)(& isr_irqs_ops);

#line 84  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_rx_out_of_mem_ops_2 = (struct file_operations *)(& rx_out_of_mem_ops);

#line 85  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_ps_pspoll_max_apturn_ops_2 = (struct file_operations *)(& ps_pspoll_max_apturn_ops);

#line 86  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_isr_tx_exch_complete_ops_2 = (struct file_operations *)(& isr_tx_exch_complete_ops);

#line 87  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_ps_upsd_utilization_ops_2 = (struct file_operations *)(& ps_upsd_utilization_ops);

#line 88  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_isr_fiqs_ops_2 = (struct file_operations *)(& isr_fiqs_ops);

#line 89  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_isr_hw_pm_mode_changes_ops_2 = (struct file_operations *)(& isr_hw_pm_mode_changes_ops);

#line 90  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_pwr_wake_on_timer_exp_ops_2 = (struct file_operations *)(& pwr_wake_on_timer_exp_ops);

#line 91  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_pwr_rcvd_awake_beacons_ops_2 = (struct file_operations *)(& pwr_rcvd_awake_beacons_ops);

#line 92  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_isr_dma0_done_ops_2 = (struct file_operations *)(& isr_dma0_done_ops);

#line 93  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_isr_host_acknowledges_ops_2 = (struct file_operations *)(& isr_host_acknowledges_ops);

#line 94  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_pwr_elp_enter_ops_2 = (struct file_operations *)(& pwr_elp_enter_ops);

#line 95  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_event_rx_pool_ops_2 = (struct file_operations *)(& event_rx_pool_ops);

#line 96  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_isr_rx_procs_ops_2 = (struct file_operations *)(& isr_rx_procs_ops);

#line 97  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_mic_calc_failure_ops_2 = (struct file_operations *)(& mic_calc_failure_ops);

#line 98  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_rx_path_reset_ops_2 = (struct file_operations *)(& rx_path_reset_ops);

#line 99  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_ps_upsd_max_sptime_ops_2 = (struct file_operations *)(& ps_upsd_max_sptime_ops);

#line 100  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_dma_tx_errors_ops_2 = (struct file_operations *)(& dma_tx_errors_ops);

#line 101  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_rx_dropped_ops_2 = (struct file_operations *)(& rx_dropped_ops);

#line 102  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_wep_packets_ops_2 = (struct file_operations *)(& wep_packets_ops);

#line 103  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_aes_encrypt_interrupt_ops_2 = (struct file_operations *)(& aes_encrypt_interrupt_ops);

#line 104  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_isr_commands_ops_2 = (struct file_operations *)(& isr_commands_ops);

#line 105  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_aes_decrypt_interrupt_ops_2 = (struct file_operations *)(& aes_decrypt_interrupt_ops);

#line 106  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_pwr_tx_with_ps_ops_2 = (struct file_operations *)(& pwr_tx_with_ps_ops);

#line 107  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_isr_dma1_done_ops_2 = (struct file_operations *)(& isr_dma1_done_ops);

#line 108  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_aes_encrypt_fail_ops_2 = (struct file_operations *)(& aes_encrypt_fail_ops);

#line 109  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_ps_pspoll_timeouts_ops_2 = (struct file_operations *)(& ps_pspoll_timeouts_ops);

#line 110  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_ps_upsd_max_apturn_ops_2 = (struct file_operations *)(& ps_upsd_max_apturn_ops);

#line 111  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_ps_upsd_timeouts_ops_2 = (struct file_operations *)(& ps_upsd_timeouts_ops);

#line 112  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_wep_addr_key_count_ops_2 = (struct file_operations *)(& wep_addr_key_count_ops);

#line 113  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_rx_hdr_overflow_ops_2 = (struct file_operations *)(& rx_hdr_overflow_ops);

#line 114  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_event_calibration_ops_2 = (struct file_operations *)(& event_calibration_ops);

#line 115  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_aes_decrypt_packets_ops_2 = (struct file_operations *)(& aes_decrypt_packets_ops);

#line 116  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_event_heart_beat_ops_2 = (struct file_operations *)(& event_heart_beat_ops);

#line 117  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_rxpipe_beacon_buffer_thres_host_int_trig_rx_data_ops_2 = (struct file_operations *)(& rxpipe_beacon_buffer_thres_host_int_trig_rx_data_ops);

#line 118  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long long (*ldv_emg_alias_generic_file_llseek_3)(struct file *, long long , int ) = & generic_file_llseek;

#line 119  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_aes_encrypt_packets_ops_2 = (struct file_operations *)(& aes_encrypt_packets_ops);

#line 120  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_mic_rx_pkts_ops_2 = (struct file_operations *)(& mic_rx_pkts_ops);

#line 121  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_dma_rx_errors_ops_2 = (struct file_operations *)(& dma_rx_errors_ops);

#line 122  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_isr_pci_pm_ops_2 = (struct file_operations *)(& isr_pci_pm_ops);

#line 123  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_wep_interrupt_ops_2 = (struct file_operations *)(& wep_interrupt_ops);

#line 124  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_rxpipe_rx_prep_beacon_drop_ops_2 = (struct file_operations *)(& rxpipe_rx_prep_beacon_drop_ops);

#line 125  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_event_rx_mem_empty_ops_2 = (struct file_operations *)(& event_rx_mem_empty_ops);

#line 126  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_tx_internal_desc_overflow_ops_2 = (struct file_operations *)(& tx_internal_desc_overflow_ops);

#line 127  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_pwr_missing_bcns_ops_2 = (struct file_operations *)(& pwr_missing_bcns_ops);

#line 128  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_ps_pspoll_utilization_ops_2 = (struct file_operations *)(& ps_pspoll_utilization_ops);

#line 129  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_pwr_disable_ps_ops_2 = (struct file_operations *)(& pwr_disable_ps_ops);

#line 130  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_rx_hw_stuck_ops_2 = (struct file_operations *)(& rx_hw_stuck_ops);

#line 131  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_pwr_ps_enter_ops_2 = (struct file_operations *)(& pwr_ps_enter_ops);

#line 132  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_wep_key_not_found_ops_2 = (struct file_operations *)(& wep_key_not_found_ops);

#line 133  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_pwr_tx_without_ps_ops_2 = (struct file_operations *)(& pwr_tx_without_ps_ops);

#line 134  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_pwr_wake_on_host_ops_2 = (struct file_operations *)(& pwr_wake_on_host_ops);

#line 135  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_isr_wakeups_ops_2 = (struct file_operations *)(& isr_wakeups_ops);

#line 140 
struct dentry *ldv_emg_debugfs_create_file(char *arg0, unsigned short arg1, struct dentry *arg2, void *arg3, struct file_operations *arg4);


#line 144  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_isr_decrypt_done_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 145 
  tmp = isr_decrypt_done_read(arg0,arg1,arg2,arg3);
  
#line 145 
  return tmp;
}


#line 149  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_rx_reset_counter_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 150 
  tmp = rx_reset_counter_read(arg0,arg1,arg2,arg3);
  
#line 150 
  return tmp;
}


#line 154  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_pwr_wake_on_timer_exp_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 155 
  tmp = pwr_wake_on_timer_exp_read(arg0,arg1,arg2,arg3);
  
#line 155 
  return tmp;
}


#line 159  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_event_heart_beat_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 160 
  tmp = event_heart_beat_read(arg0,arg1,arg2,arg3);
  
#line 160 
  return tmp;
}


#line 164  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_rx_out_of_mem_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 165 
  tmp = rx_out_of_mem_read(arg0,arg1,arg2,arg3);
  
#line 165 
  return tmp;
}


#line 169  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_event_calibration_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 170 
  tmp = event_calibration_read(arg0,arg1,arg2,arg3);
  
#line 170 
  return tmp;
}


#line 174  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_rxpipe_descr_host_int_trig_rx_data_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 175 
  tmp = rxpipe_descr_host_int_trig_rx_data_read(arg0,arg1,arg2,arg3);
  
#line 175 
  return tmp;
}


#line 179  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_pwr_elp_enter_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 180 
  tmp = pwr_elp_enter_read(arg0,arg1,arg2,arg3);
  
#line 180 
  return tmp;
}


#line 184  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_rxpipe_rx_prep_beacon_drop_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 185 
  tmp = rxpipe_rx_prep_beacon_drop_read(arg0,arg1,arg2,arg3);
  
#line 185 
  return tmp;
}


#line 189  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_wep_addr_key_count_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 190 
  tmp = wep_addr_key_count_read(arg0,arg1,arg2,arg3);
  
#line 190 
  return tmp;
}


#line 194  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_pwr_power_save_off_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 195 
  tmp = pwr_power_save_off_read(arg0,arg1,arg2,arg3);
  
#line 195 
  return tmp;
}


#line 199  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_rx_fcs_err_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 200 
  tmp = rx_fcs_err_read(arg0,arg1,arg2,arg3);
  
#line 200 
  return tmp;
}


#line 204  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_aes_decrypt_interrupt_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 205 
  tmp = aes_decrypt_interrupt_read(arg0,arg1,arg2,arg3);
  
#line 205 
  return tmp;
}


#line 209  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_isr_cmd_cmplt_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 210 
  tmp = isr_cmd_cmplt_read(arg0,arg1,arg2,arg3);
  
#line 210 
  return tmp;
}


#line 214  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_pwr_ps_enter_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 215 
  tmp = pwr_ps_enter_read(arg0,arg1,arg2,arg3);
  
#line 215 
  return tmp;
}


#line 219  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_isr_rx_rdys_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 220 
  tmp = isr_rx_rdys_read(arg0,arg1,arg2,arg3);
  
#line 220 
  return tmp;
}


#line 224  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_tx_internal_desc_overflow_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 225 
  tmp = tx_internal_desc_overflow_read(arg0,arg1,arg2,arg3);
  
#line 225 
  return tmp;
}


#line 229  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_isr_host_acknowledges_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 230 
  tmp = isr_host_acknowledges_read(arg0,arg1,arg2,arg3);
  
#line 230 
  return tmp;
}


#line 234  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_wep_default_key_count_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 235 
  tmp = wep_default_key_count_read(arg0,arg1,arg2,arg3);
  
#line 235 
  return tmp;
}


#line 239  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_pwr_wake_on_host_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 240 
  tmp = pwr_wake_on_host_read(arg0,arg1,arg2,arg3);
  
#line 240 
  return tmp;
}


#line 244  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_isr_pci_pm_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 245 
  tmp = isr_pci_pm_read(arg0,arg1,arg2,arg3);
  
#line 245 
  return tmp;
}


#line 249  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_aes_encrypt_packets_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 250 
  tmp = aes_encrypt_packets_read(arg0,arg1,arg2,arg3);
  
#line 250 
  return tmp;
}


#line 254  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_pwr_tx_without_ps_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 255 
  tmp = pwr_tx_without_ps_read(arg0,arg1,arg2,arg3);
  
#line 255 
  return tmp;
}


#line 259  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_aes_encrypt_interrupt_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 260 
  tmp = aes_encrypt_interrupt_read(arg0,arg1,arg2,arg3);
  
#line 260 
  return tmp;
}


#line 264  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_rx_path_reset_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 265 
  tmp = rx_path_reset_read(arg0,arg1,arg2,arg3);
  
#line 265 
  return tmp;
}


#line 269  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_dma_tx_requested_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 270 
  tmp = dma_tx_requested_read(arg0,arg1,arg2,arg3);
  
#line 270 
  return tmp;
}


#line 274  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_isr_tx_procs_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 275 
  tmp = isr_tx_procs_read(arg0,arg1,arg2,arg3);
  
#line 275 
  return tmp;
}


#line 279  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_isr_dma1_done_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 280 
  tmp = isr_dma1_done_read(arg0,arg1,arg2,arg3);
  
#line 280 
  return tmp;
}


#line 284  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_event_tx_stuck_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 285 
  tmp = event_tx_stuck_read(arg0,arg1,arg2,arg3);
  
#line 285 
  return tmp;
}


#line 289  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_ps_pspoll_utilization_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 290 
  tmp = ps_pspoll_utilization_read(arg0,arg1,arg2,arg3);
  
#line 290 
  return tmp;
}


#line 294  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_isr_rx_headers_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 295 
  tmp = isr_rx_headers_read(arg0,arg1,arg2,arg3);
  
#line 295 
  return tmp;
}


#line 299  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_isr_rx_mem_overflow_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 300 
  tmp = isr_rx_mem_overflow_read(arg0,arg1,arg2,arg3);
  
#line 300 
  return tmp;
}


#line 304  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_event_rx_pool_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 305 
  tmp = event_rx_pool_read(arg0,arg1,arg2,arg3);
  
#line 305 
  return tmp;
}


#line 309  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_pwr_missing_bcns_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 310 
  tmp = pwr_missing_bcns_read(arg0,arg1,arg2,arg3);
  
#line 310 
  return tmp;
}


#line 314  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_rx_dropped_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 315 
  tmp = rx_dropped_read(arg0,arg1,arg2,arg3);
  
#line 315 
  return tmp;
}


#line 319  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_pwr_rcvd_awake_beacons_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 320 
  tmp = pwr_rcvd_awake_beacons_read(arg0,arg1,arg2,arg3);
  
#line 320 
  return tmp;
}


#line 324  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_wep_interrupt_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 325 
  tmp = wep_interrupt_read(arg0,arg1,arg2,arg3);
  
#line 325 
  return tmp;
}


#line 329  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_event_rx_mismatch_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 330 
  tmp = event_rx_mismatch_read(arg0,arg1,arg2,arg3);
  
#line 330 
  return tmp;
}


#line 334  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_isr_dma0_done_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 335 
  tmp = isr_dma0_done_read(arg0,arg1,arg2,arg3);
  
#line 335 
  return tmp;
}


#line 339  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_rx_hw_stuck_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 340 
  tmp = rx_hw_stuck_read(arg0,arg1,arg2,arg3);
  
#line 340 
  return tmp;
}


#line 344  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_isr_wakeups_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 345 
  tmp = isr_wakeups_read(arg0,arg1,arg2,arg3);
  
#line 345 
  return tmp;
}


#line 349  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_isr_low_rssi_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 350 
  tmp = isr_low_rssi_read(arg0,arg1,arg2,arg3);
  
#line 350 
  return tmp;
}


#line 354  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_aes_encrypt_fail_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 355 
  tmp = aes_encrypt_fail_read(arg0,arg1,arg2,arg3);
  
#line 355 
  return tmp;
}


#line 359  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_pwr_enable_ps_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 360 
  tmp = pwr_enable_ps_read(arg0,arg1,arg2,arg3);
  
#line 360 
  return tmp;
}


#line 364  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_ps_upsd_timeouts_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 365 
  tmp = ps_upsd_timeouts_read(arg0,arg1,arg2,arg3);
  
#line 365 
  return tmp;
}


#line 369  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_isr_rx_procs_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 370 
  tmp = isr_rx_procs_read(arg0,arg1,arg2,arg3);
  
#line 370 
  return tmp;
}


#line 374  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_pwr_disable_ps_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 375 
  tmp = pwr_disable_ps_read(arg0,arg1,arg2,arg3);
  
#line 375 
  return tmp;
}


#line 379  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_event_oom_late_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 380 
  tmp = event_oom_late_read(arg0,arg1,arg2,arg3);
  
#line 380 
  return tmp;
}


#line 384  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_aes_decrypt_packets_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 385 
  tmp = aes_decrypt_packets_read(arg0,arg1,arg2,arg3);
  
#line 385 
  return tmp;
}


#line 389  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_isr_hw_pm_mode_changes_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 390 
  tmp = isr_hw_pm_mode_changes_read(arg0,arg1,arg2,arg3);
  
#line 390 
  return tmp;
}


#line 394  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_mic_calc_failure_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 395 
  tmp = mic_calc_failure_read(arg0,arg1,arg2,arg3);
  
#line 395 
  return tmp;
}


#line 399  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_dma_rx_requested_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 400 
  tmp = dma_rx_requested_read(arg0,arg1,arg2,arg3);
  
#line 400 
  return tmp;
}


#line 404  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_ps_pspoll_max_apturn_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 405 
  tmp = ps_pspoll_max_apturn_read(arg0,arg1,arg2,arg3);
  
#line 405 
  return tmp;
}


#line 409  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_pwr_rcvd_beacons_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 410 
  tmp = pwr_rcvd_beacons_read(arg0,arg1,arg2,arg3);
  
#line 410 
  return tmp;
}


#line 414  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_wep_decrypt_fail_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 415 
  tmp = wep_decrypt_fail_read(arg0,arg1,arg2,arg3);
  
#line 415 
  return tmp;
}


#line 419  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_dma_rx_errors_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 420 
  tmp = dma_rx_errors_read(arg0,arg1,arg2,arg3);
  
#line 420 
  return tmp;
}


#line 424  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_mic_rx_pkts_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 425 
  tmp = mic_rx_pkts_read(arg0,arg1,arg2,arg3);
  
#line 425 
  return tmp;
}


#line 429  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_rx_hdr_overflow_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 430 
  tmp = rx_hdr_overflow_read(arg0,arg1,arg2,arg3);
  
#line 430 
  return tmp;
}


#line 434  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_rxpipe_tx_xfr_host_int_trig_rx_data_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 435 
  tmp = rxpipe_tx_xfr_host_int_trig_rx_data_read(arg0,arg1,arg2,arg3);
  
#line 435 
  return tmp;
}


#line 439  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_rx_xfr_hint_trig_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 440 
  tmp = rx_xfr_hint_trig_read(arg0,arg1,arg2,arg3);
  
#line 440 
  return tmp;
}


#line 444  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_aes_decrypt_fail_read_4(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 445 
  tmp = aes_decrypt_fail_read(arg0,arg1,arg2,arg3);
  
#line 445 
  return tmp;
}


#line 449  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_isr_commands_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 450 
  tmp = isr_commands_read(arg0,arg1,arg2,arg3);
  
#line 450 
  return tmp;
}


#line 454  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_ps_pspoll_timeouts_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 455 
  tmp = ps_pspoll_timeouts_read(arg0,arg1,arg2,arg3);
  
#line 455 
  return tmp;
}


#line 459  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_pwr_tx_with_ps_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 460 
  tmp = pwr_tx_with_ps_read(arg0,arg1,arg2,arg3);
  
#line 460 
  return tmp;
}


#line 464  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_ps_upsd_max_apturn_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 465 
  tmp = ps_upsd_max_apturn_read(arg0,arg1,arg2,arg3);
  
#line 465 
  return tmp;
}


#line 469  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_wep_key_not_found_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 470 
  tmp = wep_key_not_found_read(arg0,arg1,arg2,arg3);
  
#line 470 
  return tmp;
}


#line 474  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_isr_fiqs_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 475 
  tmp = isr_fiqs_read(arg0,arg1,arg2,arg3);
  
#line 475 
  return tmp;
}


#line 479  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_rxpipe_missed_beacon_host_int_trig_rx_data_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 480 
  tmp = rxpipe_missed_beacon_host_int_trig_rx_data_read(arg0,arg1,arg2,arg3);
  
#line 480 
  return tmp;
}


#line 484  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_wep_packets_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 485 
  tmp = wep_packets_read(arg0,arg1,arg2,arg3);
  
#line 485 
  return tmp;
}


#line 489  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_dma_tx_errors_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 490 
  tmp = dma_tx_errors_read(arg0,arg1,arg2,arg3);
  
#line 490 
  return tmp;
}


#line 494  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_ps_upsd_max_sptime_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 495 
  tmp = ps_upsd_max_sptime_read(arg0,arg1,arg2,arg3);
  
#line 495 
  return tmp;
}


#line 499  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_pwr_fix_tsf_ps_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 500 
  tmp = pwr_fix_tsf_ps_read(arg0,arg1,arg2,arg3);
  
#line 500 
  return tmp;
}


#line 504  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_rxpipe_beacon_buffer_thres_host_int_trig_rx_data_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 505 
  tmp = rxpipe_beacon_buffer_thres_host_int_trig_rx_data_read(arg0,arg1,arg2,arg3);
  
#line 505 
  return tmp;
}


#line 509  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_event_rx_mem_empty_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 510 
  tmp = event_rx_mem_empty_read(arg0,arg1,arg2,arg3);
  
#line 510 
  return tmp;
}


#line 514  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_isr_irqs_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 515 
  tmp = isr_irqs_read(arg0,arg1,arg2,arg3);
  
#line 515 
  return tmp;
}


#line 519  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_isr_tx_exch_complete_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 520 
  tmp = isr_tx_exch_complete_read(arg0,arg1,arg2,arg3);
  
#line 520 
  return tmp;
}


#line 524  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_event_phy_transmit_error_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 525 
  tmp = event_phy_transmit_error_read(arg0,arg1,arg2,arg3);
  
#line 525 
  return tmp;
}


#line 529  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_ps_upsd_utilization_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 530 
  tmp = ps_upsd_utilization_read(arg0,arg1,arg2,arg3);
  
#line 530 
  return tmp;
}


#line 542  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static long PTR_ERR_0(void const *ptr)
{
  long tmp;
  
#line 545 
  tmp = ldv_ptr_err(ptr);
  
#line 545 
  return tmp;
}


#line 549  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static bool IS_ERR_0(void const *ptr)
{
  bool __retres;
  long ret;
  
#line 553 
  ret = ldv_is_err(ptr);
  
#line 554 
  __retres = (_Bool)(ret != 0L);
  
#line 554 
  return __retres;
}


#line 1205  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_72(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1209 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1209 
  return tmp;
}


#line 1213  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_73(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1217 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1217 
  return tmp;
}


#line 1221  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_74(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1225 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1225 
  return tmp;
}


#line 1229  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_75(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1233 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1233 
  return tmp;
}


#line 1237  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_76(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1241 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1241 
  return tmp;
}


#line 1245  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_77(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1249 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1249 
  return tmp;
}


#line 1253  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_78(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1257 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1257 
  return tmp;
}


#line 1261  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_79(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1265 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1265 
  return tmp;
}


#line 1269  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_80(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1273 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1273 
  return tmp;
}


#line 1277  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_81(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1281 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1281 
  return tmp;
}


#line 1285  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_82(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1289 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1289 
  return tmp;
}


#line 1293  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_83(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1297 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1297 
  return tmp;
}


#line 1301  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_84(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1305 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1305 
  return tmp;
}


#line 1309  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_85(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1313 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1313 
  return tmp;
}


#line 1317  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_86(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1321 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1321 
  return tmp;
}


#line 1325  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_87(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1329 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1329 
  return tmp;
}


#line 1333  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_88(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1337 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1337 
  return tmp;
}


#line 1341  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_89(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1345 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1345 
  return tmp;
}


#line 1349  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_90(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1353 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1353 
  return tmp;
}


#line 1357  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_91(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1361 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1361 
  return tmp;
}


#line 1365  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_92(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1369 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1369 
  return tmp;
}


#line 1373  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_93(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1377 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1377 
  return tmp;
}


#line 1381  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_94(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1385 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1385 
  return tmp;
}


#line 1389  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_95(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1393 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1393 
  return tmp;
}


#line 1397  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_96(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1401 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1401 
  return tmp;
}


#line 1405  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_97(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1409 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1409 
  return tmp;
}


#line 1413  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_98(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1417 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1417 
  return tmp;
}


#line 1421  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_99(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1425 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1425 
  return tmp;
}


#line 1429  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_100(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1433 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1433 
  return tmp;
}


#line 1437  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_101(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1441 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1441 
  return tmp;
}


#line 1445  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_102(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1449 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1449 
  return tmp;
}


#line 1453  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_103(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1457 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1457 
  return tmp;
}


#line 1461  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_104(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1465 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1465 
  return tmp;
}


#line 1469  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_105(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1473 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1473 
  return tmp;
}


#line 1477  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_106(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1481 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1481 
  return tmp;
}


#line 1485  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_107(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1489 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1489 
  return tmp;
}


#line 1493  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_108(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1497 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1497 
  return tmp;
}


#line 1501  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_109(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1505 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1505 
  return tmp;
}


#line 1509  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_110(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1513 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1513 
  return tmp;
}


#line 1517  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_111(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1521 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1521 
  return tmp;
}


#line 1525  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_112(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1529 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1529 
  return tmp;
}


#line 1533  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_113(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1537 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1537 
  return tmp;
}


#line 1541  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_114(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1545 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1545 
  return tmp;
}


#line 1549  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_115(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1553 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1553 
  return tmp;
}


#line 1557  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_116(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1561 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1561 
  return tmp;
}


#line 1565  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_117(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1569 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1569 
  return tmp;
}


#line 1573  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_118(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1577 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1577 
  return tmp;
}


#line 1581  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_119(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1585 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1585 
  return tmp;
}


#line 1589  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_120(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1593 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1593 
  return tmp;
}


#line 1597  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_121(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1601 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1601 
  return tmp;
}


#line 1605  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_122(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1609 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1609 
  return tmp;
}


#line 1613  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_123(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1617 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1617 
  return tmp;
}


#line 1621  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_124(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1625 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1625 
  return tmp;
}


#line 1629  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_125(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1633 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1633 
  return tmp;
}


#line 1637  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_126(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1641 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1641 
  return tmp;
}


#line 1645  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_127(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1649 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1649 
  return tmp;
}


#line 1653  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_128(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1657 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1657 
  return tmp;
}


#line 1661  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_129(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1665 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1665 
  return tmp;
}


#line 1669  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_130(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1673 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1673 
  return tmp;
}


#line 1677  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_131(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1681 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1681 
  return tmp;
}


#line 1685  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_132(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1689 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1689 
  return tmp;
}


#line 1693  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_133(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1697 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1697 
  return tmp;
}


#line 1701  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_134(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1705 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1705 
  return tmp;
}


#line 1709  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_135(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1713 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1713 
  return tmp;
}


#line 1717  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_136(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1721 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1721 
  return tmp;
}


#line 1725  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_137(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1729 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1729 
  return tmp;
}


#line 1733  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_138(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1737 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1737 
  return tmp;
}


#line 1741  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_139(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1745 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1745 
  return tmp;
}


#line 1749  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_140(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1753 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1753 
  return tmp;
}


#line 1757  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_141(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1761 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1761 
  return tmp;
}


#line 1765  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_142(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1769 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1769 
  return tmp;
}


#line 1773  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_143(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1777 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1777 
  return tmp;
}


#line 1781  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_144(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1785 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1785 
  return tmp;
}


#line 1789  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_145(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1793 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1793 
  return tmp;
}


#line 1797  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_146(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1801 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1801 
  return tmp;
}


#line 1805  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_147(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1809 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1809 
  return tmp;
}


#line 1813  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_148(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1817 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1817 
  return tmp;
}


#line 1821  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_149(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1825 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1825 
  return tmp;
}


#line 56  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/string_64.h"
void *memset(void *, int, size_t);


#line 292  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jiffies.h"
unsigned long __msecs_to_jiffies(unsigned int const);


#line 299  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jiffies.h"
__inline static unsigned long _msecs_to_jiffies(unsigned int const m)
{
  unsigned long __retres;
  
#line 301 
  __retres = (unsigned long)(((long)m + 3L) / 4L);
  
#line 301 
  return __retres;
}


#line 354  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jiffies.h"
__inline static unsigned long msecs_to_jiffies(unsigned int const m)
{
  unsigned long __retres;
  
#line 356 
  if (0 != 0) {
    unsigned long tmp;
    
#line 357 
    if ((int)m < 0) {
      
#line 358 
      __retres = 4611686018427387902UL;
      
#line 358 
      goto return_label;
    }
    else ;
    
#line 359 
    tmp = _msecs_to_jiffies(m);
    
#line 359 
    __retres = tmp;
    
#line 359 
    goto return_label;
  }
  else {
    unsigned long tmp_0;
    
#line 361 
    tmp_0 = __msecs_to_jiffies(m);
    
#line 361 
    __retres = tmp_0;
    
#line 361 
    goto return_label;
  }
  return_label: 
#line 356 
                return __retres;
}


#line 447  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/workqueue.h"
bool cancel_delayed_work(struct delayed_work *);


#line 581  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/slab.h"
static void *kzalloc_1(size_t size, gfp_t flags);


#line 4678  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
void ieee80211_queue_delayed_work(struct ieee80211_hw *, struct delayed_work *, unsigned long);


#line 501  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/wlcore_i.h"
__inline static struct ieee80211_vif *wl12xx_wlvif_to_vif(struct wl12xx_vif *wlvif)
{
  struct ieee80211_vif *tmp;
  {
    
#line 503 
    u8 const (*__mptr)[0U] = (u8 const (*)[0U])wlvif;
    
#line 503 
    tmp = (struct ieee80211_vif *)__mptr + 18446744073709551320U;
  }
  
#line 503 
  return tmp;
}


#line 62  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/cmd.h"
int wl12xx_cmd_build_probe_req(struct wl1271 *, struct wl12xx_vif *, u8, u8, u8 const *, size_t, u8 const *, size_t, u8 const *, size_t, bool);


#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/scan.h"
void wl1271_scan_stm(struct wl1271 *wl, struct wl12xx_vif *wlvif);


#line 37 
int wl1271_scan_sched_scan_config(struct wl1271 *wl, struct wl12xx_vif *wlvif, struct cfg80211_sched_scan_request *req, struct ieee80211_scan_ies *ies);


#line 41 
int wl1271_scan_sched_scan_start(struct wl1271 *wl, struct wl12xx_vif *wlvif);


#line 160 
bool wlcore_set_scan_chan_params(struct wl1271 *, struct wlcore_scan_channels *, struct ieee80211_channel **, u32, u32, int);


#line 168 
int wlcore_scan_sched_scan_ssid_list(struct wl1271 *, struct wl12xx_vif *, struct cfg80211_sched_scan_request *);


#line 252  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/tx.h"
u32 wl1271_tx_min_rate_get(struct wl1271 *, u32);


#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/scan.c"
static int wl1271_get_scan_channels(struct wl1271 *wl, struct cfg80211_scan_request *req, struct basic_scan_channel_params *channels, enum ieee80211_band band, bool passive)
{
  int i;
  int j;
  u32 flags;
  int tmp_1;
  
#line 32 
  struct conf_scan_settings *c = & wl->conf.scan;
  
#line 36 
  i = 0;
  
#line 36 
  j = 0;
  
#line 36 
  goto ldv_51295;
  ldv_51294: 
#line 37 
  ;
  
#line 39 
  flags = (req->channels[i])->flags;
  
#line 41 
  if (0 != 0) {
    int tmp;
    
#line 41 
    tmp = constant_test_bit((long)i,(unsigned long const volatile *)(& wl->scan.scanned_ch));
    
#line 41 
    tmp_1 = tmp == 0;
  }
  else {
    int tmp_0;
    
#line 41 
    tmp_0 = variable_test_bit((long)i,(unsigned long const volatile *)(& wl->scan.scanned_ch));
    
#line 41 
    tmp_1 = tmp_0 == 0;
  }
  
#line 41 
  if (tmp_1) {
    
#line 41 
    if ((flags & 1U) == 0U) {
      
#line 42 
      if ((req->channels[i])->band == band) {
        
#line 43 
        if ((int)passive != 0 || (flags & 2U) == 0U) {
          
#line 51 
          if ((long)((wl12xx_debug_level & 256U) != 0U) != 0L) {
            
#line 51 
            struct _ddebug descriptor = {.modname = "wl12xx", .function = "wl1271_get_scan_channels", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/scan.c", .format = "wlcore", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))53U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
            
#line 51 
            if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 51 
                                                                __dynamic_pr_debug(& descriptor,"wlcore",(unsigned int)(req->channels[i])->band,(int)(req->channels[i])->center_freq); else ;
          }
          else ;
          
#line 54 
          if ((long)((wl12xx_debug_level & 256U) != 0U) != 0L) {
            
#line 54 
            struct _ddebug descriptor_0 = {.modname = "wl12xx", .function = "wl1271_get_scan_channels", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/scan.c", .format = "wlcore", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))56U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
            
#line 54 
            if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) 
#line 54 
                                                                  __dynamic_pr_debug(& descriptor_0,"wlcore",(int)(req->channels[i])->hw_value,(req->channels[i])->flags); else ;
          }
          else ;
          
#line 57 
          if ((long)((wl12xx_debug_level & 256U) != 0U) != 0L) {
            
#line 57 
            struct _ddebug descriptor_1 = {.modname = "wl12xx", .function = "wl1271_get_scan_channels", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/scan.c", .format = "wlcore", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))60U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
            
#line 57 
            if ((long)(((int)descriptor_1.flags & 1) != 0) != 0L) 
#line 57 
                                                                  __dynamic_pr_debug(& descriptor_1,"wlcore",(req->channels[i])->max_antenna_gain,(req->channels[i])->max_power); else ;
          }
          else ;
          
#line 61 
          if ((long)((wl12xx_debug_level & 256U) != 0U) != 0L) {
            
#line 61 
            struct _ddebug descriptor_2 = {.modname = "wl12xx", .function = "wl1271_get_scan_channels", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/scan.c", .format = "wlcore", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))62U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
            
#line 61 
            if ((long)(((int)descriptor_2.flags & 1) != 0) != 0L) 
#line 61 
                                                                  __dynamic_pr_debug(& descriptor_2,"wlcore",(int)(req->channels[i])->beacon_found); else ;
          }
          else ;
          
#line 64 
          if (! passive) {
            
#line 65 
            (channels + j)->min_duration = c->min_dwell_time_active;
            
#line 67 
            (channels + j)->max_duration = c->max_dwell_time_active;
          }
          else {
            
#line 70 
            (channels + j)->min_duration = c->dwell_time_passive;
            
#line 72 
            (channels + j)->max_duration = c->dwell_time_passive;
          }
          
#line 75 
          (channels + j)->early_termination = (unsigned char)0U;
          
#line 76 
          (channels + j)->tx_power_att = (unsigned char)(req->channels[i])->max_power;
          
#line 77 
          (channels + j)->channel = (unsigned char)(req->channels[i])->hw_value;
          
#line 79 
          memset((void *)(& (channels + j)->bssid_lsb),255,4UL);
          
#line 80 
          memset((void *)(& (channels + j)->bssid_msb),255,2UL);
          
#line 83 
          set_bit((long)i,(unsigned long volatile *)(& wl->scan.scanned_ch));
          
#line 85 
          j += 1;
        }
        else ;
      }
      else ;
    }
    else ;
  }
  else ;
  
#line 38 
  i += 1;
  ldv_51295: 
#line 39 
  ;
  
#line 36 
  if (req->n_channels > (unsigned int)i && j <= 23) 
#line 39 
                                                    goto ldv_51294; else 
                                                                    
#line 42 
                                                                    goto ldv_51296;
  ldv_51296: 
#line 43 
  ;
  
#line 89 
  return j;
}


#line 94  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/scan.c"
static int wl1271_scan_send(struct wl1271 *wl, struct wl12xx_vif *wlvif, enum ieee80211_band band, bool passive, u32 basic_rate)
{
  int __retres;
  struct wl1271_cmd_scan *cmd;
  struct wl1271_cmd_trigger_scan_to *trigger;
  int ret;
  int tmp_2;
  int tmp_3;
  
#line 98 
  struct ieee80211_vif *vif = wl12xx_wlvif_to_vif(wlvif);
  
#line 102 
  u16 scan_options = (unsigned short)0U;
  
#line 105 
  if (! passive && (wl->scan.req)->n_ssids == 0) {
    
#line 106 
    __retres = 1;
    
#line 106 
    goto return_label;
  }
  else ;
  
#line 108 
  cmd = (struct wl1271_cmd_scan *)kzalloc_1(540UL,208U);
  
#line 109 
  trigger = (struct wl1271_cmd_trigger_scan_to *)kzalloc_1(8UL,208U);
  
#line 110 
  if (cmd == (struct wl1271_cmd_scan *)0 || trigger == (struct wl1271_cmd_trigger_scan_to *)0) {
    
#line 111 
    ret = -12;
    
#line 112 
    goto out;
  }
  else ;
  
#line 115 
  if (wl->conf.scan.split_scan_timeout != 0U) 
#line 116 
                                              scan_options = (unsigned short)((unsigned int)scan_options | 2U); else ;
  
#line 118 
  if ((int)passive != 0) 
#line 119 
                         scan_options = (unsigned short)((unsigned int)scan_options | 1U); else ;
  
#line 121 
  cmd->params.role_id = wlvif->role_id;
  {
    
#line 123 
    int __ret_warn_on = (unsigned int)cmd->params.role_id == 255U;
    
#line 123 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 123 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/scan.c",123); else ;
    
#line 123 
    tmp_2 = (long)(__ret_warn_on != 0);
  }
  
#line 123 
  if ((long)tmp_2 != 0L) {
    
#line 124 
    ret = -22;
    
#line 125 
    goto out;
  }
  else ;
  
#line 128 
  cmd->params.scan_options = scan_options;
  
#line 130 
  tmp_3 = wl1271_get_scan_channels(wl,wl->scan.req,(struct basic_scan_channel_params *)(& cmd->channels),band,(_Bool)((bool)((int)passive) != 0));
  
#line 130 
  cmd->params.n_ch = (unsigned char)tmp_3;
  
#line 133 
  if ((unsigned int)cmd->params.n_ch == 0U) {
    
#line 134 
    ret = 1;
    
#line 135 
    goto out;
  }
  else ;
  
#line 138 
  cmd->params.tx_rate = basic_rate;
  
#line 139 
  cmd->params.n_probe_reqs = (unsigned char)wl->conf.scan.num_probe_reqs;
  
#line 140 
  cmd->params.tid_trigger = (unsigned char)255U;
  
#line 141 
  cmd->params.scan_tag = (unsigned char)1U;
  
#line 143 
  if (band == (unsigned int)IEEE80211_BAND_2GHZ) 
#line 144 
                                                 cmd->params.band = (unsigned char)0U; else 
                                                                    
#line 146 
                                                                    cmd->params.band = (unsigned char)1U;
  
#line 148 
  if (wl->scan.ssid_len != 0UL && & wl->scan.ssid != (u8 (*)[33U])0) {
    
#line 149 
    cmd->params.ssid_len = (unsigned char)wl->scan.ssid_len;
    
#line 150 
    memcpy((void *)(& cmd->params.ssid),(void const *)(& wl->scan.ssid),wl->scan.ssid_len);
  }
  else ;
  
#line 153 
  memcpy((void *)(& cmd->addr),(void const *)(& vif->addr),6UL);
  
#line 155 
  ret = wl12xx_cmd_build_probe_req(wl,wlvif,(unsigned char)((int)cmd->params.role_id),(unsigned char)((int)((unsigned char)band)),(u8 const *)(& wl->scan.ssid),wl->scan.ssid_len,(wl->scan.req)->ie,(wl->scan.req)->ie_len,(u8 const *)0U,0UL,(_Bool)0);
  
#line 160 
  if (ret < 0) {
    
#line 161 
    printk("\001");
    
#line 162 
    goto out;
  }
  else ;
  
#line 165 
  trigger->timeout = wl->conf.scan.split_scan_timeout;
  
#line 166 
  ret = wl1271_cmd_send(wl,(unsigned short)26,(void *)trigger,8UL,0UL);
  
#line 168 
  if (ret < 0) {
    
#line 169 
    printk("\001");
    
#line 170 
    goto out;
  }
  else ;
  
#line 173 
  if ((wl12xx_debug_level & 256U) != 0U) {
    
#line 173 
    struct _ddebug descriptor = {.modname = "wl12xx", .function = "wl1271_scan_send", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/scan.c", .format = "wlcore", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))173U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 173 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
      size_t tmp_5;
      {
        size_t tmp_4;
        
#line 173 
        size_t __min1 = 540UL;
        
#line 173 
        size_t __min2 = 1024UL;
        
#line 173 
        if (__min1 < __min2) 
#line 173 
                             tmp_4 = __min1; else 
#line 173 
                                                  tmp_4 = __min2;
        
#line 173 
        tmp_5 = tmp_4;
      }
      
#line 173 
      ;
      
#line 173 
      print_hex_dump("\001","wlcore",2,16,1,(void const *)cmd,tmp_5,(_Bool)0);
    }
    else ;
  }
  else ;
  
#line 175 
  ret = wl1271_cmd_send(wl,(unsigned short)7,(void *)cmd,540UL,0UL);
  
#line 176 
  if (ret < 0) {
    
#line 177 
    printk("\001");
    
#line 178 
    goto out;
  }
  else ;
  out: 
#line 181 
  ;
  
#line 182 
  kfree((void const *)cmd);
  
#line 183 
  kfree((void const *)trigger);
  
#line 184 
  __retres = ret;
  return_label: 
#line 184 
                return __retres;
}


#line 187  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/scan.c"
int wl12xx_scan_stop(struct wl1271 *wl, struct wl12xx_vif *wlvif)
{
  int __retres;
  int tmp;
  
#line 189 
  struct wl1271_cmd_header *cmd = (struct wl1271_cmd_header *)0;
  
#line 190 
  int ret = 0;
  {
    
#line 192 
    int __ret_warn_on = (unsigned int)wl->scan.state == 0U;
    
#line 192 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 192 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/scan.c",192); else ;
    
#line 192 
    tmp = (long)(__ret_warn_on != 0);
  }
  
#line 192 
  if ((long)tmp != 0L) {
    
#line 193 
    __retres = -22;
    
#line 193 
    goto return_label;
  }
  else ;
  
#line 195 
  if ((long)((wl12xx_debug_level & 4096U) != 0U) != 0L) {
    
#line 195 
    struct _ddebug descriptor = {.modname = "wl12xx", .function = "wl12xx_scan_stop", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/scan.c", .format = "wlcore", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))195U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 195 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 195 
                                                        __dynamic_pr_debug(& descriptor,"wlcore"); else ;
  }
  else ;
  
#line 197 
  cmd = (struct wl1271_cmd_header *)kzalloc_1(4UL,208U);
  
#line 198 
  if (cmd == (struct wl1271_cmd_header *)0) {
    
#line 199 
    ret = -12;
    
#line 200 
    goto out;
  }
  else ;
  
#line 203 
  ret = wl1271_cmd_send(wl,(unsigned short)8,(void *)cmd,4UL,0UL);
  
#line 205 
  if (ret < 0) {
    
#line 206 
    printk("\001");
    
#line 207 
    goto out;
  }
  else ;
  out: 
#line 209 
  ;
  
#line 210 
  kfree((void const *)cmd);
  
#line 211 
  __retres = ret;
  return_label: 
#line 211 
                return __retres;
}


#line 214  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/scan.c"
void wl1271_scan_stm(struct wl1271 *wl, struct wl12xx_vif *wlvif)
{
  enum ieee80211_band band;
  u32 rate;
  u32 mask;
  
#line 216 
  int ret = 0;
  
#line 220 
  switch ((int)wl->scan.state) {
    unsigned long tmp;
    case 0: 
#line 221 
    ;
    
#line 222 
    goto ldv_51337;
    case 1: 
#line 224 
    ;
    
#line 225 
    band = IEEE80211_BAND_2GHZ;
    
#line 226 
    mask = wlvif->bitrate_masks[(unsigned int)band];
    
#line 227 
    if ((int)(wl->scan.req)->no_cck != 0) {
      
#line 228 
      mask &= 4294967256U;
      
#line 229 
      if (mask == 0U) 
#line 230 
                      mask = 8U; else ;
    }
    else ;
    
#line 232 
    rate = wl1271_tx_min_rate_get(wl,mask);
    
#line 233 
    ret = wl1271_scan_send(wl,wlvif,band,(_Bool)0,rate);
    
#line 234 
    if (ret == 1) {
      
#line 235 
      wl->scan.state = (unsigned char)2U;
      
#line 236 
      wl1271_scan_stm(wl,wlvif);
    }
    else ;
    
#line 239 
    goto ldv_51337;
    case 2: 
#line 241 
    ;
    
#line 242 
    band = IEEE80211_BAND_2GHZ;
    
#line 243 
    mask = wlvif->bitrate_masks[(unsigned int)band];
    
#line 244 
    if ((int)(wl->scan.req)->no_cck != 0) {
      
#line 245 
      mask &= 4294967256U;
      
#line 246 
      if (mask == 0U) 
#line 247 
                      mask = 8U; else ;
    }
    else ;
    
#line 249 
    rate = wl1271_tx_min_rate_get(wl,mask);
    
#line 250 
    ret = wl1271_scan_send(wl,wlvif,band,(_Bool)1,rate);
    
#line 251 
    if (ret == 1) {
      
#line 252 
      if ((int)wl->enable_11a != 0) 
#line 253 
                                    wl->scan.state = (unsigned char)3U; else 
                                                                    
#line 255 
                                                                    wl->scan.state = (unsigned char)5U;
      
#line 256 
      wl1271_scan_stm(wl,wlvif);
    }
    else ;
    
#line 259 
    goto ldv_51337;
    case 3: 
#line 261 
    ;
    
#line 262 
    band = IEEE80211_BAND_5GHZ;
    
#line 263 
    rate = wl1271_tx_min_rate_get(wl,wlvif->bitrate_masks[(unsigned int)band]);
    
#line 264 
    ret = wl1271_scan_send(wl,wlvif,band,(_Bool)0,rate);
    
#line 265 
    if (ret == 1) {
      
#line 266 
      wl->scan.state = (unsigned char)4U;
      
#line 267 
      wl1271_scan_stm(wl,wlvif);
    }
    else ;
    
#line 270 
    goto ldv_51337;
    case 4: 
#line 272 
    ;
    
#line 273 
    band = IEEE80211_BAND_5GHZ;
    
#line 274 
    rate = wl1271_tx_min_rate_get(wl,wlvif->bitrate_masks[(unsigned int)band]);
    
#line 275 
    ret = wl1271_scan_send(wl,wlvif,band,(_Bool)1,rate);
    
#line 276 
    if (ret == 1) {
      
#line 277 
      wl->scan.state = (unsigned char)5U;
      
#line 278 
      wl1271_scan_stm(wl,wlvif);
    }
    else ;
    
#line 281 
    goto ldv_51337;
    case 5: 
#line 283 
    ;
    
#line 284 
    wl->scan.failed = (_Bool)0;
    
#line 285 
    cancel_delayed_work(& wl->scan_complete_work);
    
#line 286 
    tmp = msecs_to_jiffies(0U);
    
#line 286 
    ;
    
#line 286 
    ;
    
#line 286 
    ieee80211_queue_delayed_work(wl->hw,& wl->scan_complete_work,tmp);
    
#line 288 
    goto ldv_51337;
    default: 
#line 290 
    ;
    
#line 291 
    printk("\001");
    
#line 292 
    goto ldv_51337;
  }
  ldv_51337: 
#line 295 
  ;
  
#line 295 
  if (ret < 0) {
    unsigned long tmp_0;
    
#line 296 
    cancel_delayed_work(& wl->scan_complete_work);
    
#line 297 
    tmp_0 = msecs_to_jiffies(0U);
    
#line 297 
    ;
    
#line 297 
    ;
    
#line 297 
    ieee80211_queue_delayed_work(wl->hw,& wl->scan_complete_work,tmp_0);
  }
  else ;
  
#line 300 
  return;
}


#line 302  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/scan.c"
static void wl12xx_adjust_channels(struct wl1271_cmd_sched_scan_config *cmd, struct wlcore_scan_channels *cmd_channels)
{
  
#line 305 
  memcpy((void *)(& cmd->passive),(void const *)(& cmd_channels->passive),3UL);
  
#line 306 
  memcpy((void *)(& cmd->active),(void const *)(& cmd_channels->active),3UL);
  
#line 307 
  cmd->dfs = cmd_channels->dfs;
  
#line 308 
  cmd->n_pactive_ch = cmd_channels->passive_active;
  
#line 310 
  memcpy((void *)(& cmd->channels_2),(void const *)(& cmd_channels->channels_2),168UL);
  
#line 312 
  memcpy((void *)(& cmd->channels_5),(void const *)(& cmd_channels->channels_5),276UL);
  
#line 313 
  return;
}


#line 317  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/scan.c"
int wl1271_scan_sched_scan_config(struct wl1271 *wl, struct wl12xx_vif *wlvif, struct cfg80211_sched_scan_request *req, struct ieee80211_scan_ies *ies)
{
  int __retres;
  int i;
  int ret;
  int tmp_2;
  bool tmp_1;
  
#line 322 
  struct wl1271_cmd_sched_scan_config *cfg = (struct wl1271_cmd_sched_scan_config *)0;
  
#line 323 
  struct wlcore_scan_channels *cfg_channels = (struct wlcore_scan_channels *)0;
  
#line 324 
  struct conf_sched_scan_settings *c = & wl->conf.sched_scan;
  
#line 326 
  bool force_passive = (_Bool)(req->n_ssids == 0);
  
#line 328 
  if ((long)((wl12xx_debug_level & 4096U) != 0U) != 0L) {
    
#line 328 
    struct _ddebug descriptor = {.modname = "wl12xx", .function = "wl1271_scan_sched_scan_config", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/scan.c", .format = "wlcore", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))328U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 328 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 328 
                                                        __dynamic_pr_debug(& descriptor,"wlcore"); else ;
  }
  else ;
  
#line 330 
  cfg = (struct wl1271_cmd_sched_scan_config *)kzalloc_1(612UL,208U);
  
#line 331 
  if (cfg == (struct wl1271_cmd_sched_scan_config *)0) {
    
#line 332 
    __retres = -12;
    
#line 332 
    goto return_label;
  }
  else ;
  
#line 334 
  cfg->role_id = wlvif->role_id;
  
#line 335 
  cfg->rssi_threshold = c->rssi_threshold;
  
#line 336 
  cfg->snr_threshold = c->snr_threshold;
  
#line 337 
  cfg->n_probe_reqs = c->num_probe_reqs;
  
#line 339 
  cfg->cycles = (unsigned char)0U;
  
#line 341 
  cfg->report_after = (unsigned char)1U;
  
#line 343 
  cfg->terminate = (unsigned char)0U;
  
#line 344 
  cfg->tag = (unsigned char)1U;
  
#line 346 
  cfg->bss_type = (unsigned char)2U;
  
#line 348 
  i = 0;
  
#line 348 
  goto ldv_51363;
  ldv_51362: 
#line 349 
  ;
  
#line 349 
  cfg->intervals[i] = req->interval;
  
#line 348 
  i += 1;
  ldv_51363: 
#line 349 
  ;
  
#line 348 
  if (i <= 15) 
#line 350 
               goto ldv_51362; else 
#line 353 
                                    goto ldv_51364;
  ldv_51364: 
#line 354 
  ;
  
#line 351 
  cfg->ssid_len = (unsigned char)0U;
  
#line 352 
  ret = wlcore_scan_sched_scan_ssid_list(wl,wlvif,req);
  
#line 353 
  if (ret < 0) 
#line 354 
               goto out; else ;
  
#line 356 
  cfg->filter_type = (unsigned char)ret;
  
#line 358 
  if ((long)((wl12xx_debug_level & 256U) != 0U) != 0L) {
    
#line 358 
    struct _ddebug descriptor_0 = {.modname = "wl12xx", .function = "wl1271_scan_sched_scan_config", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/scan.c", .format = "wlcore", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))358U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 358 
    if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) 
#line 358 
                                                          __dynamic_pr_debug(& descriptor_0,"wlcore",(int)cfg->filter_type); else ;
  }
  else ;
  
#line 360 
  cfg_channels = (struct wlcore_scan_channels *)kzalloc_1(728UL,208U);
  
#line 361 
  if (cfg_channels == (struct wlcore_scan_channels *)0) {
    
#line 362 
    ret = -12;
    
#line 363 
    goto out;
  }
  else ;
  
#line 366 
  tmp_1 = wlcore_set_scan_chan_params(wl,cfg_channels,(struct ieee80211_channel **)(& req->channels),req->n_channels,(unsigned int)req->n_ssids,1);
  
#line 366 
  if (tmp_1) 
#line 366 
             tmp_2 = 0; else 
#line 366 
                             tmp_2 = 1;
  
#line 366 
  if (tmp_2) {
    
#line 369 
    printk("\001");
    
#line 370 
    ret = -22;
    
#line 371 
    goto out;
  }
  else ;
  
#line 373 
  wl12xx_adjust_channels(cfg,cfg_channels);
  
#line 375 
  if (! force_passive && (unsigned int)cfg->active[0] != 0U) {
    
#line 376 
    u8 band = (unsigned char)0U;
    
#line 377 
    ret = wl12xx_cmd_build_probe_req(wl,wlvif,(unsigned char)((int)wlvif->role_id),(unsigned char)((int)band),(u8 const *)(& (req->ssids)->ssid),(unsigned long)(req->ssids)->ssid_len,ies->ies[(int)band],ies->len[(int)band],ies->common_ies,ies->common_ie_len,(_Bool)1);
    
#line 386 
    if (ret < 0) {
      
#line 387 
      printk("\001");
      
#line 388 
      goto out;
    }
    else ;
  }
  else ;
  
#line 392 
  if (! force_passive && (unsigned int)cfg->active[1] != 0U) {
    
#line 393 
    u8 band_0 = (unsigned char)1U;
    
#line 394 
    ret = wl12xx_cmd_build_probe_req(wl,wlvif,(unsigned char)((int)wlvif->role_id),(unsigned char)((int)band_0),(u8 const *)(& (req->ssids)->ssid),(unsigned long)(req->ssids)->ssid_len,ies->ies[(int)band_0],ies->len[(int)band_0],ies->common_ies,ies->common_ie_len,(_Bool)1);
    
#line 403 
    if (ret < 0) {
      
#line 404 
      printk("\001");
      
#line 405 
      goto out;
    }
    else ;
  }
  else ;
  
#line 409 
  if ((wl12xx_debug_level & 256U) != 0U) {
    
#line 409 
    struct _ddebug descriptor_1 = {.modname = "wl12xx", .function = "wl1271_scan_sched_scan_config", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/scan.c", .format = "wlcore", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))409U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 409 
    if ((long)(((int)descriptor_1.flags & 1) != 0) != 0L) {
      size_t tmp_4;
      {
        size_t tmp_3;
        
#line 409 
        size_t __min1 = 612UL;
        
#line 409 
        size_t __min2 = 1024UL;
        
#line 409 
        if (__min1 < __min2) 
#line 409 
                             tmp_3 = __min1; else 
#line 409 
                                                  tmp_3 = __min2;
        
#line 409 
        tmp_4 = tmp_3;
      }
      
#line 409 
      ;
      
#line 409 
      print_hex_dump("\001","wlcore",2,16,1,(void const *)cfg,tmp_4,(_Bool)0);
    }
    else ;
  }
  else ;
  
#line 411 
  ret = wl1271_cmd_send(wl,(unsigned short)27,(void *)cfg,612UL,0UL);
  
#line 413 
  if (ret < 0) {
    
#line 414 
    printk("\001");
    
#line 415 
    goto out;
  }
  else ;
  out: 
#line 417 
  ;
  
#line 418 
  kfree((void const *)cfg_channels);
  
#line 419 
  kfree((void const *)cfg);
  
#line 420 
  __retres = ret;
  return_label: 
#line 420 
                return __retres;
}


#line 423  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/scan.c"
int wl1271_scan_sched_scan_start(struct wl1271 *wl, struct wl12xx_vif *wlvif)
{
  int __retres;
  struct wl1271_cmd_sched_scan_start *start;
  
#line 426 
  int ret = 0;
  
#line 428 
  if ((long)((wl12xx_debug_level & 4096U) != 0U) != 0L) {
    
#line 428 
    struct _ddebug descriptor = {.modname = "wl12xx", .function = "wl1271_scan_sched_scan_start", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/scan.c", .format = "wlcore", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))428U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 428 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 428 
                                                        __dynamic_pr_debug(& descriptor,"wlcore"); else ;
  }
  else ;
  
#line 430 
  if ((unsigned int)wlvif->bss_type != 2U) {
    
#line 431 
    __retres = -95;
    
#line 431 
    goto return_label;
  }
  else ;
  
#line 433 
  if (((unsigned long)wl->quirks & 512UL) != 0UL) {
    int tmp;
    
#line 433 
    tmp = constant_test_bit(11L,(unsigned long const volatile *)(& wlvif->flags));
    
#line 433 
    if (tmp != 0) {
      
#line 435 
      __retres = -16;
      
#line 435 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 437 
  start = (struct wl1271_cmd_sched_scan_start *)kzalloc_1(8UL,208U);
  
#line 438 
  if (start == (struct wl1271_cmd_sched_scan_start *)0) {
    
#line 439 
    __retres = -12;
    
#line 439 
    goto return_label;
  }
  else ;
  
#line 441 
  start->role_id = wlvif->role_id;
  
#line 442 
  start->tag = (unsigned char)1U;
  
#line 444 
  ret = wl1271_cmd_send(wl,(unsigned short)29,(void *)start,8UL,0UL);
  
#line 446 
  if (ret < 0) {
    
#line 447 
    printk("\001");
    
#line 448 
    goto out_free;
  }
  else ;
  out_free: 
#line 451 
  ;
  
#line 452 
  kfree((void const *)start);
  
#line 453 
  __retres = ret;
  return_label: 
#line 453 
                return __retres;
}


#line 456  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/scan.c"
int wl12xx_sched_scan_start(struct wl1271 *wl, struct wl12xx_vif *wlvif, struct cfg80211_sched_scan_request *req, struct ieee80211_scan_ies *ies)
{
  int __retres;
  int ret;
  int tmp;
  
#line 462 
  ret = wl1271_scan_sched_scan_config(wl,wlvif,req,ies);
  
#line 463 
  if (ret < 0) {
    
#line 464 
    __retres = ret;
    
#line 464 
    goto return_label;
  }
  else ;
  
#line 466 
  tmp = wl1271_scan_sched_scan_start(wl,wlvif);
  
#line 466 
  __retres = tmp;
  return_label: 
#line 466 
                return __retres;
}


#line 469  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/scan.c"
void wl12xx_scan_sched_scan_stop(struct wl1271 *wl, struct wl12xx_vif *wlvif)
{
  struct wl1271_cmd_sched_scan_stop *stop;
  
#line 472 
  int ret = 0;
  
#line 474 
  if ((long)((wl12xx_debug_level & 4096U) != 0U) != 0L) {
    
#line 474 
    struct _ddebug descriptor = {.modname = "wl12xx", .function = "wl12xx_scan_sched_scan_stop", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/scan.c", .format = "wlcore", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))474U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 474 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 474 
                                                        __dynamic_pr_debug(& descriptor,"wlcore"); else ;
  }
  else ;
  
#line 477 
  stop = (struct wl1271_cmd_sched_scan_stop *)kzalloc_1(8UL,208U);
  
#line 478 
  if (stop == (struct wl1271_cmd_sched_scan_stop *)0) {
    
#line 479 
    printk("\001");
    
#line 480 
    goto return_label;
  }
  else ;
  
#line 483 
  stop->role_id = wlvif->role_id;
  
#line 484 
  stop->tag = (unsigned char)1U;
  
#line 486 
  ret = wl1271_cmd_send(wl,(unsigned short)30,(void *)stop,8UL,0UL);
  
#line 488 
  if (ret < 0) {
    
#line 489 
    printk("\001");
    
#line 490 
    goto out_free;
  }
  else ;
  out_free: 
#line 493 
  ;
  
#line 494 
  kfree((void const *)stop);
  return_label: 
#line 495 
                return;
}


#line 497  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/scan.c"
int wl12xx_scan_start(struct wl1271 *wl, struct wl12xx_vif *wlvif, struct cfg80211_scan_request *req)
{
  int __retres;
  
#line 500 
  wl1271_scan_stm(wl,wlvif);
  
#line 501 
  __retres = 0;
  
#line 501 
  return __retres;
}


#line 504  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl12xx/scan.c"
void wl12xx_scan_completed(struct wl1271 *wl, struct wl12xx_vif *wlvif)
{
  
#line 506 
  wl1271_scan_stm(wl,wlvif);
  
#line 507 
  return;
}


#line 414  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/weaver/.tmp_scan.c.aux"
static void *kzalloc_1(size_t size, gfp_t flags)
{
  void *tmp;
  
#line 417 
  tmp = ldv_kzalloc(size,flags);
  
#line 417 
  return tmp;
}


#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
void ldv_atomic_add(int i, atomic_t *v)
{
  
#line 23 
  v->counter += i;
  
#line 24 
  return;
}


#line 27  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
void ldv_atomic_sub(int i, atomic_t *v)
{
  
#line 29 
  v->counter -= i;
  
#line 30 
  return;
}


#line 33  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
int ldv_atomic_sub_and_test(int i, atomic_t *v)
{
  int __retres;
  
#line 35 
  v->counter -= i;
  
#line 36 
  if (v->counter != 0) {
    
#line 37 
    __retres = 0;
    
#line 37 
    goto return_label;
  }
  else ;
  
#line 39 
  __retres = 1;
  return_label: 
#line 39 
                return __retres;
}


#line 43  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
void ldv_atomic_inc(atomic_t *v)
{
  
#line 45 
  v->counter += 1;
  
#line 46 
  return;
}


#line 49  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
void ldv_atomic_dec(atomic_t *v)
{
  
#line 51 
  v->counter -= 1;
  
#line 52 
  return;
}


#line 55  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
int ldv_atomic_dec_and_test(atomic_t *v)
{
  int __retres;
  
#line 57 
  v->counter -= 1;
  
#line 58 
  if (v->counter != 0) {
    
#line 59 
    __retres = 0;
    
#line 59 
    goto return_label;
  }
  else ;
  
#line 61 
  __retres = 1;
  return_label: 
#line 61 
                return __retres;
}


#line 65  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
int ldv_atomic_inc_and_test(atomic_t *v)
{
  int __retres;
  
#line 67 
  v->counter += 1;
  
#line 68 
  if (v->counter != 0) {
    
#line 69 
    __retres = 0;
    
#line 69 
    goto return_label;
  }
  else ;
  
#line 71 
  __retres = 1;
  return_label: 
#line 71 
                return __retres;
}


#line 75  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
int ldv_atomic_add_return(int i, atomic_t *v)
{
  int __retres;
  
#line 77 
  v->counter += i;
  
#line 78 
  __retres = v->counter;
  
#line 78 
  return __retres;
}


#line 82  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
int ldv_atomic_add_negative(int i, atomic_t *v)
{
  int __retres;
  
#line 84 
  v->counter += i;
  
#line 85 
  __retres = v->counter < 0;
  
#line 85 
  return __retres;
}


#line 89  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
int ldv_atomic_inc_short(short *v)
{
  int __retres;
  
#line 91 
  *v = (short)((unsigned int)*v + 1U);
  
#line 92 
  __retres = (int)*v;
  
#line 92 
  return __retres;
}


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/device.h"
void *ldv_dev_get_drvdata(struct device const *dev);


#line 24 
int ldv_dev_set_drvdata(struct device *dev, void *data);


#line 30  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memory.h"
void *ldv_xmalloc(size_t size);


#line 31 
void *ldv_xzalloc(size_t size);


#line 28  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memlist.h"
struct ldv_list_element global_list = {.data = (void *)0, .next = (struct ldv_list_element *)0};

#line 33  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memlist.h"
__inline static ldv_list_ptr ldv_list_create(void *data)
{
  
#line 35 
  ldv_list_ptr list = (struct ldv_list_element *)0;
  
#line 37 
  list = (ldv_list_ptr)ldv_xmalloc(16UL);
  
#line 39 
  list->data = data;
  
#line 40 
  list->next = (struct ldv_list_element *)0;
  
#line 42 
  return list;
}


#line 45  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memlist.h"
__inline static void ldv_save_pointer(void *data)
{
  ldv_list_ptr element;
  ldv_list_ptr cached;
  
#line 50 
  if (global_list.data == (void *)0) {
    
#line 51 
    element = & global_list;
    
#line 52 
    element->data = data;
  }
  else {
    
#line 54 
    element = ldv_list_create(data);
    
#line 55 
    cached = global_list.next;
    
#line 56 
    global_list.next = element;
    
#line 57 
    element->next = cached;
  }
  
#line 60 
  return;
}


#line 28  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/drivers/base/dd.c"
void *ldv_dev_get_drvdata(struct device const *dev)
{
  void *__retres;
  
#line 30 
  if (dev != (struct device const *)0 && dev->p != (struct device_private *)0) {
    
#line 31 
    __retres = (dev->p)->driver_data;
    
#line 31 
    goto return_label;
  }
  else ;
  
#line 33 
  __retres = (void *)0;
  return_label: 
#line 33 
                return __retres;
}


#line 42  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/drivers/base/dd.c"
int ldv_dev_set_drvdata(struct device *dev, void *data)
{
  int __retres;
  
#line 44 
  dev->p = (struct device_private *)ldv_xzalloc(8UL);
  
#line 45 
  ldv_save_pointer((void *)dev->p);
  
#line 46 
  (dev->p)->driver_data = data;
  
#line 48 
  __retres = 0;
  
#line 48 
  return __retres;
}


#line 25  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memory.h"
void *ldv_zalloc(size_t size);


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/drivers/spi.c"
struct spi_master *ldv_spi_alloc_master(struct device *host, unsigned int size)
{
  struct spi_master *__retres;
  struct spi_master *master;
  
#line 27 
  master = (struct spi_master *)ldv_zalloc((unsigned long)size + 2192UL);
  
#line 29 
  if (master == (struct spi_master *)0) {
    
#line 30 
    __retres = (struct spi_master *)0;
    
#line 30 
    goto return_label;
  }
  else ;
  
#line 32 
  ldv_dev_set_drvdata(& master->dev,(void *)(master + 1U));
  
#line 34 
  __retres = master;
  return_label: 
#line 34 
                return __retres;
}


#line 28  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/err.h"
long ldv_is_err_or_null(void const *ptr);


#line 29 
void *ldv_err_ptr(long error);


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/common.h"
void __VERIFIER_assume(int);


#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/err.c"
long ldv_is_err(void const *ptr)
{
  long __retres;
  
#line 23 
  __retres = (long)((unsigned long)ptr > 4294967295UL);
  
#line 23 
  return __retres;
}


#line 26  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/err.c"
void *ldv_err_ptr(long error)
{
  void *__retres;
  
#line 28 
  __VERIFIER_assume(error < 0L);
  
#line 29 
  __retres = (void *)(4294967295L - error);
  
#line 29 
  return __retres;
}


#line 32  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/err.c"
long ldv_ptr_err(void const *ptr)
{
  long __retres;
  
#line 34 
  __VERIFIER_assume((unsigned long)ptr > 4294967295UL);
  
#line 35 
  __retres = (long)(4294967295UL - (unsigned long)ptr);
  
#line 35 
  return __retres;
}


#line 38  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/err.c"
long ldv_is_err_or_null(void const *ptr)
{
  long __retres;
  int tmp_0;
  
#line 40 
  if (ptr == (void const *)0) 
#line 40 
                              tmp_0 = 1;
  else {
    long tmp;
    
#line 40 
    tmp = ldv_is_err(ptr);
    
#line 40 
    if (tmp != 0L) 
#line 40 
                   tmp_0 = 1; else 
#line 40 
                                   tmp_0 = 0;
  }
  
#line 40 
  __retres = (long)tmp_0;
  
#line 40 
  return __retres;
}


#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/panic.h"
void ldv_panic(void);


#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/kernel/panic.c"
void ldv_panic(void)
{
  
#line 23 
  __VERIFIER_assume(0);
  
#line 24 
  return;
}


#line 32  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.h"
void ldv_switch_to_interrupt_context(void);


#line 42 
void ldv_switch_to_process_context(void);


#line 50 
bool ldv_in_interrupt_context(void);


#line 112 
int ldv_post_init(int init_ret_val);


#line 132 
int ldv_post_probe(int probe_ret_val);


#line 133 
void ldv_check_return_value_probe(int);


#line 141 
int ldv_filter_err_code(int ret_val);


#line 25  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
static bool __ldv_in_interrupt_context = (_Bool)0;

#line 28  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
void ldv_switch_to_interrupt_context(void)
{
  
#line 30 
  __ldv_in_interrupt_context = (_Bool)1;
  
#line 31 
  return;
}


#line 34  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
void ldv_switch_to_process_context(void)
{
  
#line 36 
  __ldv_in_interrupt_context = (_Bool)0;
  
#line 37 
  return;
}


#line 39  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
bool ldv_in_interrupt_context(void)
{
  
#line 41 
  return __ldv_in_interrupt_context;
}


#line 44  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
static int ldv_filter_positive_int(int val)
{
  
#line 46 
  __VERIFIER_assume(val <= 0);
  
#line 47 
  return val;
}


#line 54  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
int ldv_post_init(int init_ret_val)
{
  int tmp;
  
#line 56 
  tmp = ldv_filter_positive_int(init_ret_val);
  
#line 56 
  return tmp;
}


#line 60  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
int ldv_post_probe(int probe_ret_val)
{
  int tmp;
  
#line 62 
  ldv_check_return_value_probe(probe_ret_val);
  
#line 63 
  tmp = ldv_filter_positive_int(probe_ret_val);
  
#line 63 
  return tmp;
}


#line 67  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
int ldv_filter_err_code(int ret_val)
{
  int tmp;
  
#line 69 
  tmp = ldv_filter_positive_int(ret_val);
  
#line 69 
  return tmp;
}


#line 25  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/slab.h"
void *ldv_kcalloc(size_t n, size_t size, gfp_t flags);


#line 26 
void *ldv_kmalloc_array(size_t n, size_t size, gfp_t flags);


#line 28 
void ldv_check_alloc_flags(gfp_t);


#line 29 
void ldv_after_alloc(void *);


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memory.h"
void *ldv_malloc(size_t size);


#line 24 
void *ldv_calloc(size_t nmemb, size_t size);


#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kmalloc(size_t size, gfp_t flags)
{
  void *res;
  
#line 25 
  ldv_check_alloc_flags(flags);
  
#line 26 
  res = ldv_malloc(size);
  
#line 27 
  ldv_after_alloc(res);
  
#line 29 
  return res;
}


#line 32  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kcalloc(size_t n, size_t size, gfp_t flags)
{
  void *res;
  
#line 36 
  ldv_check_alloc_flags(flags);
  
#line 37 
  res = ldv_calloc(n,size);
  
#line 38 
  ldv_after_alloc(res);
  
#line 40 
  return res;
}


#line 43  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kzalloc(size_t size, gfp_t flags)
{
  void *res;
  
#line 47 
  ldv_check_alloc_flags(flags);
  
#line 48 
  res = ldv_zalloc(size);
  
#line 49 
  ldv_after_alloc(res);
  
#line 51 
  return res;
}


#line 54  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kmalloc_array(size_t n, size_t size, gfp_t flags)
{
  void *res;
  
#line 58 
  ldv_check_alloc_flags(flags);
  
#line 59 
  res = ldv_malloc(n * size);
  
#line 60 
  ldv_after_alloc(res);
  
#line 62 
  return res;
}


#line 26  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memory.h"
void ldv_free(void *s);


#line 35 
void *ldv_malloc_unknown_size(void);


#line 36 
void *ldv_calloc_unknown_size(void);


#line 37 
void *ldv_zalloc_unknown_size(void);


#line 40 
void *ldv_reference_malloc(size_t size);


#line 41 
void *ldv_reference_calloc(size_t nmemb, size_t size);


#line 42 
void *ldv_reference_zalloc(size_t size);


#line 43 
void ldv_reference_free(void *s);


#line 47 
void *ldv_reference_xmalloc(size_t size);


#line 48 
void *ldv_reference_xzalloc(size_t size);


#line 52 
void *ldv_reference_malloc_unknown_size(void);


#line 53 
void *ldv_reference_calloc_unknown_size(void);


#line 54 
void *ldv_reference_zalloc_unknown_size(void);


#line 61 
void *ldv_xmalloc_unknown_size(size_t size);


#line 32  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_reference_xmalloc_unknown_size(size_t size);


#line 34  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_malloc(size_t size)
{
  void *res;
  
#line 37 
  res = ldv_reference_malloc(size);
  
#line 38 
  if (res != (void *)0) {
    long tmp;
    
#line 39 
    tmp = ldv_is_err((void const *)res);
    
#line 39 
    __VERIFIER_assume(tmp == 0L);
  }
  else ;
  
#line 40 
  return res;
}


#line 43  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_calloc(size_t nmemb, size_t size)
{
  void *res;
  
#line 46 
  res = ldv_reference_calloc(nmemb,size);
  
#line 47 
  if (res != (void *)0) {
    long tmp;
    
#line 48 
    tmp = ldv_is_err((void const *)res);
    
#line 48 
    __VERIFIER_assume(tmp == 0L);
  }
  else ;
  
#line 49 
  return res;
}


#line 52  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_zalloc(size_t size)
{
  void *res;
  
#line 55 
  res = ldv_reference_zalloc(size);
  
#line 56 
  if (res != (void *)0) {
    long tmp;
    
#line 57 
    tmp = ldv_is_err((void const *)res);
    
#line 57 
    __VERIFIER_assume(tmp == 0L);
  }
  else ;
  
#line 58 
  return res;
}


#line 61  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void ldv_free(void *s)
{
  
#line 63 
  ldv_reference_free(s);
  
#line 64 
  return;
}


#line 66  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_xmalloc(size_t size)
{
  void *res;
  long tmp;
  
#line 69 
  res = ldv_reference_xmalloc(size);
  
#line 70 
  tmp = ldv_is_err((void const *)res);
  
#line 70 
  __VERIFIER_assume(tmp == 0L);
  
#line 71 
  return res;
}


#line 74  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_xzalloc(size_t size)
{
  void *res;
  long tmp;
  
#line 77 
  res = ldv_reference_xzalloc(size);
  
#line 78 
  tmp = ldv_is_err((void const *)res);
  
#line 78 
  __VERIFIER_assume(tmp == 0L);
  
#line 79 
  return res;
}


#line 82  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_malloc_unknown_size(void)
{
  void *res;
  
#line 85 
  res = ldv_reference_malloc_unknown_size();
  
#line 86 
  if (res != (void *)0) {
    long tmp;
    
#line 87 
    tmp = ldv_is_err((void const *)res);
    
#line 87 
    __VERIFIER_assume(tmp == 0L);
  }
  else ;
  
#line 88 
  return res;
}


#line 91  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_calloc_unknown_size(void)
{
  void *res;
  
#line 94 
  res = ldv_reference_calloc_unknown_size();
  
#line 95 
  if (res != (void *)0) {
    long tmp;
    
#line 96 
    tmp = ldv_is_err((void const *)res);
    
#line 96 
    __VERIFIER_assume(tmp == 0L);
  }
  else ;
  
#line 97 
  return res;
}


#line 100  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_zalloc_unknown_size(void)
{
  void *res;
  
#line 103 
  res = ldv_reference_zalloc_unknown_size();
  
#line 104 
  if (res != (void *)0) {
    long tmp;
    
#line 105 
    tmp = ldv_is_err((void const *)res);
    
#line 105 
    __VERIFIER_assume(tmp == 0L);
  }
  else ;
  
#line 106 
  return res;
}


#line 109  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_xmalloc_unknown_size(size_t size)
{
  void *res;
  long tmp;
  
#line 112 
  res = ldv_reference_xmalloc_unknown_size(size);
  
#line 113 
  tmp = ldv_is_err((void const *)res);
  
#line 113 
  __VERIFIER_assume(tmp == 0L);
  
#line 114 
  return res;
}

long __builtin_expect(long exp, long c);


#line 22  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/common.h"
void __VERIFIER_error(void);


#line 24  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/gcc.c"
long __builtin_expect(long exp, long c)
{
  
#line 26 
  return exp;
}


#line 35  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/gcc.c"
void __builtin_trap(void)
{
  
#line 37 
  __VERIFIER_error();
  
#line 38 
  return;
}


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.h"
int ldv_undef_int(void);


#line 24 
int ldv_undef_long(void);


#line 25 
unsigned int ldv_undef_uint(void);


#line 26 
unsigned long ldv_undef_ulong(void);


#line 27 
unsigned long long ldv_undef_ulonglong(void);


#line 28 
void *ldv_undef_ptr(void);


#line 31 
int ldv_undef_int_positive(void);


#line 34 
int ldv_undef_int_negative(void);


#line 37 
int ldv_undef_int_nonpositive(void);


#line 40 
void *ldv_undef_ptr_non_null(void);


#line 29  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int __VERIFIER_nondet_int(void);


#line 31 
long __VERIFIER_nondet_long(void);


#line 38 
unsigned int __VERIFIER_nondet_uint(void);


#line 41 
unsigned long __VERIFIER_nondet_ulong(void);


#line 42 
unsigned long long __VERIFIER_nondet_ulonglong(void);


#line 43 
void *__VERIFIER_nondet_pointer(void);


#line 46  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_int(void)
{
  int tmp;
  
#line 48 
  tmp = __VERIFIER_nondet_int();
  
#line 48 
  return tmp;
}


#line 51  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_long(void)
{
  int __retres;
  long tmp;
  
#line 53 
  tmp = __VERIFIER_nondet_long();
  
#line 53 
  __retres = (int)tmp;
  
#line 53 
  return __retres;
}


#line 56  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
unsigned int ldv_undef_uint(void)
{
  unsigned int tmp;
  
#line 58 
  tmp = __VERIFIER_nondet_uint();
  
#line 58 
  return tmp;
}


#line 61  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
void *ldv_undef_ptr(void)
{
  void *tmp;
  
#line 63 
  tmp = __VERIFIER_nondet_pointer();
  
#line 63 
  return tmp;
}


#line 66  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
unsigned long ldv_undef_ulong(void)
{
  unsigned long tmp;
  
#line 68 
  tmp = __VERIFIER_nondet_ulong();
  
#line 68 
  return tmp;
}


#line 71  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
unsigned long long ldv_undef_ulonglong(void)
{
  unsigned long long tmp;
  
#line 73 
  tmp = __VERIFIER_nondet_ulonglong();
  
#line 73 
  return tmp;
}


#line 76  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_int_positive(void)
{
  
#line 78 
  int ret = ldv_undef_int();
  
#line 80 
  __VERIFIER_assume(ret > 0);
  
#line 82 
  return ret;
}


#line 85  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_int_negative(void)
{
  
#line 87 
  int ret = ldv_undef_int();
  
#line 89 
  __VERIFIER_assume(ret < 0);
  
#line 91 
  return ret;
}


#line 94  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_int_nonpositive(void)
{
  
#line 96 
  int ret = ldv_undef_int();
  
#line 98 
  __VERIFIER_assume(ret <= 0);
  
#line 100 
  return ret;
}


#line 103  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
void *ldv_undef_ptr_non_null(void)
{
  
#line 105 
  void *ret = ldv_undef_ptr();
  
#line 107 
  __VERIFIER_assume(ret != (void *)0);
  
#line 109 
  return ret;
}


#line 33  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memory.h"
void *external_allocated_data(void);


#line 45 
void *ldv_reference_realloc(void *ptr, size_t size);


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *malloc(size_t);


#line 24 
void *calloc(size_t, size_t);


#line 25 
void free(void *);


#line 33  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_malloc(size_t size)
{
  void *__retres;
  void *res;
  int tmp;
  
#line 37 
  tmp = ldv_undef_int();
  
#line 37 
  if (tmp != 0) {
    
#line 39 
    res = malloc(size);
    
#line 40 
    __VERIFIER_assume(res != (void *)0);
    
#line 41 
    __retres = res;
    
#line 41 
    goto return_label;
  }
  else {
    
#line 44 
    __retres = (void *)0;
    
#line 44 
    goto return_label;
  }
  return_label: 
#line 37 
                return __retres;
}


#line 47  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_calloc(size_t nmemb, size_t size)
{
  void *tmp;
  
#line 49 
  tmp = calloc(nmemb,size);
  
#line 49 
  return tmp;
}


#line 52  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_zalloc(size_t size)
{
  void *tmp;
  
#line 54 
  tmp = calloc(1UL,size);
  
#line 54 
  return tmp;
}


#line 57  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void ldv_reference_free(void *s)
{
  
#line 59 
  free(s);
  
#line 60 
  return;
}


#line 62  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_realloc(void *ptr, size_t size)
{
  void *__retres;
  void *res;
  int tmp;
  
#line 66 
  if (ptr != (void *)0 && size == 0UL) {
    
#line 67 
    free(ptr);
    
#line 68 
    __retres = (void *)0;
    
#line 68 
    goto return_label;
  }
  else ;
  
#line 71 
  if (ptr == (void *)0) {
    
#line 72 
    res = malloc(size);
    
#line 73 
    __retres = res;
    
#line 73 
    goto return_label;
  }
  else ;
  
#line 76 
  tmp = ldv_undef_int();
  
#line 76 
  if (tmp != 0) {
    
#line 78 
    res = malloc(size);
    
#line 79 
    __VERIFIER_assume(res != (void *)0);
    
#line 81 
    memcpy(res,(void const *)ptr,size);
    
#line 82 
    free(ptr);
    
#line 84 
    __retres = res;
    
#line 84 
    goto return_label;
  }
  else {
    
#line 87 
    __retres = (void *)0;
    
#line 87 
    goto return_label;
  }
  return_label: 
#line 76 
                return __retres;
}


#line 90  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_xmalloc(size_t size)
{
  void *res;
  
#line 94 
  res = malloc(size);
  
#line 95 
  __VERIFIER_assume(res != (void *)0);
  
#line 97 
  return res;
}


#line 100  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_xzalloc(size_t size)
{
  void *res;
  
#line 104 
  res = calloc(1UL,size);
  
#line 105 
  __VERIFIER_assume(res != (void *)0);
  
#line 107 
  return res;
}


#line 110  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_malloc_unknown_size(void)
{
  void *__retres;
  void *res;
  int tmp;
  
#line 114 
  tmp = ldv_undef_int();
  
#line 114 
  if (tmp != 0) {
    
#line 115 
    res = external_allocated_data();
    
#line 116 
    __VERIFIER_assume(res != (void *)0);
    
#line 117 
    __retres = res;
    
#line 117 
    goto return_label;
  }
  else {
    
#line 120 
    __retres = (void *)0;
    
#line 120 
    goto return_label;
  }
  return_label: 
#line 114 
                return __retres;
}


#line 123  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_calloc_unknown_size(void)
{
  void *__retres;
  void *res;
  int tmp;
  
#line 127 
  tmp = ldv_undef_int();
  
#line 127 
  if (tmp != 0) {
    
#line 128 
    res = external_allocated_data();
    
#line 129 
    memset(res,0,8UL);
    
#line 130 
    __VERIFIER_assume(res != (void *)0);
    
#line 131 
    __retres = res;
    
#line 131 
    goto return_label;
  }
  else {
    
#line 134 
    __retres = (void *)0;
    
#line 134 
    goto return_label;
  }
  return_label: 
#line 127 
                return __retres;
}


#line 137  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_zalloc_unknown_size(void)
{
  void *tmp;
  
#line 139 
  tmp = ldv_reference_calloc_unknown_size();
  
#line 139 
  return tmp;
}


#line 142  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_xmalloc_unknown_size(size_t size)
{
  void *res;
  
#line 146 
  res = external_allocated_data();
  
#line 147 
  __VERIFIER_assume(res != (void *)0);
  
#line 149 
  return res;
}


#line 62  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.h"
void ldv_initialize(void);


#line 123 
void ldv_pre_probe(void);


#line 33  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/thread.h"
int pthread_create(pthread_t *, pthread_attr_t const *, void *(*)(void *), void *);


#line 37 
int pthread_join(pthread_t, void **);


#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/err.h"
__inline static void *ERR_PTR(long error)
{
  void *__retres;
  
#line 25 
  __retres = (void *)error;
  
#line 25 
  return __retres;
}


#line 191  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
int main(void);


#line 192 
void *ldv_character_driver_scenario_15(void *arg0);


#line 193 
void *ldv_character_driver_scenario_11(void *arg0);


#line 194 
void *ldv_character_driver_scenario_75(void *arg0);


#line 195 
void *ldv_character_driver_scenario_69(void *arg0);


#line 196 
void *ldv_character_driver_scenario_41(void *arg0);


#line 197 
void *ldv_character_driver_scenario_48(void *arg0);


#line 198 
void *ldv_character_driver_scenario_44(void *arg0);


#line 199 
void *ldv_character_driver_scenario_51(void *arg0);


#line 200 
void *ldv_character_driver_scenario_29(void *arg0);


#line 201 
void *ldv_character_driver_scenario_36(void *arg0);


#line 202 
void *ldv_character_driver_scenario_37(void *arg0);


#line 203 
void *ldv_character_driver_scenario_83(void *arg0);


#line 204 
void *ldv_character_driver_scenario_10(void *arg0);


#line 205 
void *ldv_character_driver_scenario_40(void *arg0);


#line 206 
void *ldv_initialization_1(void *arg0);


#line 207 
void *ldv_character_driver_scenario_65(void *arg0);


#line 208 
void ldv_dispatch_register_2_3(struct platform_driver *arg0);


#line 209 
void *ldv_character_driver_scenario_73(void *arg0);


#line 210 
void *ldv_character_driver_scenario_67(void *arg0);


#line 212 
void *ldv_character_driver_scenario_53(void *arg0);


#line 213 
void ldv_dispatch_register_4_3(struct file_operations *arg0);


#line 214 
void *ldv_character_driver_scenario_12(void *arg0);


#line 215 
void *ldv_character_driver_scenario_25(void *arg0);


#line 216 
void *ldv_character_driver_scenario_49(void *arg0);


#line 217 
void *ldv_character_driver_scenario_55(void *arg0);


#line 218 
void *ldv_character_driver_scenario_35(void *arg0);


#line 219 
void *ldv_character_driver_scenario_84(void *arg0);


#line 220 
void *ldv_character_driver_scenario_26(void *arg0);


#line 221 
void *ldv_pm_ops_scenario_34(void *arg0);


#line 223 
void *ldv_character_driver_scenario_19(void *arg0);


#line 224 
void ldv_dispatch_pm_register_17_13(void);


#line 225 
void *ldv_character_driver_scenario_68(void *arg0);


#line 226 
void *ldv_character_driver_scenario_71(void *arg0);


#line 227 
void *ldv_character_driver_scenario_80(void *arg0);


#line 228 
void *ldv_character_driver_scenario_18(void *arg0);


#line 229 
void *ldv_character_driver_scenario_77(void *arg0);


#line 230 
void *ldv_character_driver_scenario_13(void *arg0);


#line 231 
void *ldv_character_driver_scenario_32(void *arg0);


#line 232 
void *ldv_character_driver_scenario_24(void *arg0);


#line 233 
void *ldv_character_driver_scenario_8(void *arg0);


#line 234 
void *ldv_character_driver_scenario_59(void *arg0);


#line 235 
void *ldv_character_driver_scenario_31(void *arg0);


#line 236 
void *ldv_character_driver_scenario_52(void *arg0);


#line 237 
void *ldv_character_driver_scenario_63(void *arg0);


#line 238 
void ldv_dispatch_deregister_3_1(struct platform_driver *arg0);


#line 239 
void *ldv_character_driver_scenario_5(void *arg0);


#line 240 
void *ldv_character_driver_scenario_79(void *arg0);


#line 241 
void *ldv_character_driver_scenario_22(void *arg0);


#line 242 
void *ldv_character_driver_scenario_82(void *arg0);


#line 243 
void *ldv_character_driver_scenario_43(void *arg0);


#line 244 
void *ldv_character_driver_scenario_72(void *arg0);


#line 245 
void *ldv_character_driver_scenario_20(void *arg0);


#line 246 
void *ldv_character_driver_scenario_42(void *arg0);


#line 247 
void *ldv_character_driver_scenario_64(void *arg0);


#line 248 
void *ldv_character_driver_scenario_16(void *arg0);


#line 249 
void *ldv_character_driver_scenario_46(void *arg0);


#line 250 
void *ldv_character_driver_scenario_14(void *arg0);


#line 251 
void *ldv_character_driver_scenario_47(void *arg0);


#line 252 
void ldv_dispatch_pm_deregister_17_12(void);


#line 253 
void *ldv_character_driver_scenario_58(void *arg0);


#line 254 
void *ldv_character_driver_scenario_9(void *arg0);


#line 255 
void *ldv_character_driver_scenario_61(void *arg0);


#line 256 
void *ldv_character_driver_scenario_76(void *arg0);


#line 257 
void *ldv_character_driver_scenario_21(void *arg0);


#line 259 
void *ldv_character_driver_scenario_6(void *arg0);


#line 260 
void *ldv_character_driver_scenario_50(void *arg0);


#line 261 
void *ldv_character_driver_scenario_74(void *arg0);


#line 262 
void *ldv_character_driver_scenario_30(void *arg0);


#line 263 
void *ldv_character_driver_scenario_39(void *arg0);


#line 264 
void *ldv_character_driver_scenario_62(void *arg0);


#line 265 
void *ldv_character_driver_scenario_45(void *arg0);


#line 266 
void *ldv_platform_instance_17(void *arg0);


#line 267 
void *ldv_character_driver_scenario_81(void *arg0);


#line 268 
void *ldv_character_driver_scenario_38(void *arg0);


#line 269 
void *ldv_character_driver_scenario_66(void *arg0);


#line 270 
void *ldv_character_driver_scenario_7(void *arg0);


#line 271 
void *ldv_character_driver_scenario_54(void *arg0);


#line 272 
void *ldv_character_driver_scenario_28(void *arg0);


#line 273 
void *ldv_character_driver_scenario_56(void *arg0);


#line 274 
void *ldv_character_driver_scenario_23(void *arg0);


#line 275 
void *ldv_character_driver_scenario_27(void *arg0);


#line 276 
void *ldv_character_driver_scenario_33(void *arg0);


#line 277 
void *ldv_character_driver_scenario_78(void *arg0);


#line 278 
void *ldv_character_driver_scenario_57(void *arg0);


#line 279 
void *ldv_character_driver_scenario_60(void *arg0);


#line 280 
void *ldv_character_driver_scenario_70(void *arg0);


#line 283  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_62;

#line 284  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_73;

#line 285  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_33;

#line 286  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_21;

#line 287  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_5;

#line 288  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_6;

#line 289  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_10;

#line 290  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_68;

#line 291  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_42;

#line 292  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_37;

#line 293  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_40;

#line 294  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_49;

#line 295  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_9;

#line 296  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_77;

#line 297  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_51;

#line 298  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_72;

#line 299  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_83;

#line 300  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_31;

#line 301  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_47;

#line 302  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_38;

#line 303  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_57;

#line 304  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_25;

#line 305  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_20;

#line 306  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_66;

#line 307  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_54;

#line 308  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_63;

#line 309  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_64;

#line 310  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_11;

#line 311  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_84;

#line 312  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_19;

#line 313  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_48;

#line 314  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_56;

#line 315  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_15;

#line 316  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_28;

#line 317  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_65;

#line 318  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_18;

#line 319  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_45;

#line 320  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_55;

#line 321  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_58;

#line 322  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_61;

#line 323  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_74;

#line 324  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_52;

#line 325  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_44;

#line 326  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_80;

#line 327  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_76;

#line 328  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_69;

#line 329  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_41;

#line 330  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_36;

#line 331  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_59;

#line 332  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_14;

#line 333  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_78;

#line 334  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_13;

#line 335  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_39;

#line 336  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_16;

#line 337  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_35;

#line 338  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_75;

#line 339  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_50;

#line 340  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_22;

#line 341  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_34;

#line 342  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_79;

#line 343  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_67;

#line 344  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_29;

#line 345  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_24;

#line 346  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_70;

#line 347  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_71;

#line 348  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_30;

#line 349  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_7;

#line 350  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_53;

#line 351  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_23;

#line 352  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_17;

#line 353  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_12;

#line 354  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_60;

#line 355  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_32;

#line 356  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_26;

#line 357  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_82;

#line 358  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_43;

#line 359  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_27;

#line 360  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_8;

#line 361  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_46;

#line 362  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_81;

#line 366  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
int main(void)
{
  int __retres;
  
#line 369 
  ldv_initialize();
  
#line 372 
  ldv_initialization_1((void *)0);
  
#line 374 
  __retres = 0;
  
#line 374 
  return __retres;
}


#line 379  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_15(void *arg0)
{
  void *__retres;
  struct file *ldv_15_resource_1;
  int ldv_15_ldv_param_2_3;
  long long ldv_15_ldv_param_1_2;
  char *ldv_15_ldv_param_1_4;
  struct inode *ldv_15_resource_0;
  unsigned long ldv_15_size_cnt;
  long long *ldv_15_ldv_param_3_5;
  char *ldv_15_ldv_param_1_6;
  long long *ldv_15_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 390 
  struct file_operations *ldv_15_container = ldv_emg_alias_aes_decrypt_fail_ops_2;
  
#line 391 
  int ldv_15_ret = ldv_undef_int();
  
#line 394 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 398 
  ldv_15_ret = ldv_undef_int();
  
#line 401 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 402 
    ldv_15_container = data->arg0;
    
#line 403 
    ldv_free((void *)data);
  }
  else ;
  
#line 408 
  ldv_15_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 409 
  tmp_1 = ldv_undef_int();
  
#line 409 
  ldv_15_size_cnt = (unsigned long)tmp_1;
  
#line 416 
  goto ldv_main_15;
  
#line 418 
  __retres = (void *)0;
  
#line 418 
  goto return_label;
  ldv_main_15: 
#line 421 
  ;
  
#line 424 
  tmp_3 = ldv_undef_int();
  
#line 424 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 427 
    ldv_15_ret = (*ldv_emg_alias_simple_open_5)(ldv_15_resource_0,ldv_15_resource_1);
    
#line 429 
    ldv_15_ret = ldv_filter_err_code(ldv_15_ret);
    
#line 432 
    tmp_2 = ldv_undef_int();
    
#line 432 
    if (tmp_2 != 0) {
      
#line 434 
      __VERIFIER_assume(ldv_15_ret == 0);
      
#line 441 
      goto ldv_call_15;
    }
    else {
      
#line 445 
      __VERIFIER_assume(ldv_15_ret != 0);
      
#line 452 
      goto ldv_main_15;
    }
  }
  else {
    
#line 457 
    ldv_free((void *)ldv_15_resource_0);
    
#line 465 
    __retres = (void *)0;
    
#line 465 
    goto return_label;
  }
  
#line 468 
  __retres = (void *)0;
  
#line 468 
  goto return_label;
  ldv_call_15: 
#line 471 
  ;
  
#line 474 
  tmp_4 = ldv_undef_int();
  
#line 474 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 475 
    ;
    
#line 477 
    ldv_15_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 478 
    ldv_15_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 482 
    if (ldv_15_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 488 
      __VERIFIER_assume(ldv_15_size_cnt <= 2147479552UL);
      
#line 490 
      (*(ldv_15_container->write))(ldv_15_resource_1,(char const *)ldv_15_ldv_param_1_6,ldv_15_size_cnt,ldv_15_ldv_param_3_7);
    }
    else ;
    
#line 495 
    ldv_free((void *)ldv_15_ldv_param_1_6);
    
#line 496 
    ldv_free((void *)ldv_15_ldv_param_3_7);
    
#line 503 
    goto ldv_call_15;
    case 2: 
#line 506 
    ;
    
#line 508 
    if (ldv_15_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 510 
      (*(ldv_15_container->release))(ldv_15_resource_0,ldv_15_resource_1); else ;
    
#line 518 
    goto ldv_main_15;
    case 3: 
#line 521 
    ;
    
#line 525 
    tmp_9 = ldv_undef_int();
    
#line 525 
    if (tmp_9 != 0) 
#line 528 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_15_resource_1,ldv_15_ldv_param_1_2,ldv_15_ldv_param_2_3);
    else {
      
#line 534 
      ldv_15_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 535 
      ldv_15_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 540 
      ldv_emg_wrapper_aes_decrypt_fail_read_4(ldv_15_resource_1,ldv_15_ldv_param_1_4,ldv_15_size_cnt,ldv_15_ldv_param_3_5);
      
#line 544 
      ldv_free((void *)ldv_15_ldv_param_3_5);
      
#line 545 
      ldv_free((void *)ldv_15_ldv_param_1_4);
    }
    
#line 549 
    goto ldv_30249;
    default: 
#line 551 
    ;
    
#line 551 
    __VERIFIER_assume(0);
  }
  ldv_30249: 
#line 560 
  ;
  
#line 560 
  goto ldv_call_15;
  
#line 562 
  __retres = (void *)0;
  return_label: 
#line 562 
                return __retres;
}


#line 567  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_11(void *arg0)
{
  void *__retres;
  struct file *ldv_11_resource_1;
  int ldv_11_ldv_param_2_3;
  long long ldv_11_ldv_param_1_2;
  char *ldv_11_ldv_param_1_4;
  struct inode *ldv_11_resource_0;
  unsigned long ldv_11_size_cnt;
  long long *ldv_11_ldv_param_3_5;
  char *ldv_11_ldv_param_1_6;
  long long *ldv_11_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 578 
  struct file_operations *ldv_11_container = ldv_emg_alias_isr_rx_mem_overflow_ops_2;
  
#line 579 
  int ldv_11_ret = ldv_undef_int();
  
#line 582 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 586 
  ldv_11_ret = ldv_undef_int();
  
#line 589 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 590 
    ldv_11_container = data->arg0;
    
#line 591 
    ldv_free((void *)data);
  }
  else ;
  
#line 596 
  ldv_11_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 597 
  tmp_1 = ldv_undef_int();
  
#line 597 
  ldv_11_size_cnt = (unsigned long)tmp_1;
  
#line 604 
  goto ldv_main_11;
  
#line 606 
  __retres = (void *)0;
  
#line 606 
  goto return_label;
  ldv_main_11: 
#line 609 
  ;
  
#line 612 
  tmp_3 = ldv_undef_int();
  
#line 612 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 615 
    ldv_11_ret = (*ldv_emg_alias_simple_open_5)(ldv_11_resource_0,ldv_11_resource_1);
    
#line 617 
    ldv_11_ret = ldv_filter_err_code(ldv_11_ret);
    
#line 620 
    tmp_2 = ldv_undef_int();
    
#line 620 
    if (tmp_2 != 0) {
      
#line 622 
      __VERIFIER_assume(ldv_11_ret == 0);
      
#line 629 
      goto ldv_call_11;
    }
    else {
      
#line 633 
      __VERIFIER_assume(ldv_11_ret != 0);
      
#line 640 
      goto ldv_main_11;
    }
  }
  else {
    
#line 645 
    ldv_free((void *)ldv_11_resource_0);
    
#line 653 
    __retres = (void *)0;
    
#line 653 
    goto return_label;
  }
  
#line 656 
  __retres = (void *)0;
  
#line 656 
  goto return_label;
  ldv_call_11: 
#line 659 
  ;
  
#line 662 
  tmp_4 = ldv_undef_int();
  
#line 662 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 663 
    ;
    
#line 665 
    ldv_11_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 666 
    ldv_11_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 670 
    if (ldv_11_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 676 
      __VERIFIER_assume(ldv_11_size_cnt <= 2147479552UL);
      
#line 678 
      (*(ldv_11_container->write))(ldv_11_resource_1,(char const *)ldv_11_ldv_param_1_6,ldv_11_size_cnt,ldv_11_ldv_param_3_7);
    }
    else ;
    
#line 683 
    ldv_free((void *)ldv_11_ldv_param_3_7);
    
#line 684 
    ldv_free((void *)ldv_11_ldv_param_1_6);
    
#line 691 
    goto ldv_call_11;
    case 2: 
#line 694 
    ;
    
#line 696 
    if (ldv_11_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 698 
      (*(ldv_11_container->release))(ldv_11_resource_0,ldv_11_resource_1); else ;
    
#line 706 
    goto ldv_main_11;
    case 3: 
#line 709 
    ;
    
#line 713 
    tmp_9 = ldv_undef_int();
    
#line 713 
    if (tmp_9 != 0) 
#line 716 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_11_resource_1,ldv_11_ldv_param_1_2,ldv_11_ldv_param_2_3);
    else {
      
#line 722 
      ldv_11_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 723 
      ldv_11_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 728 
      ldv_emg_wrapper_isr_rx_mem_overflow_read_3(ldv_11_resource_1,ldv_11_ldv_param_1_4,ldv_11_size_cnt,ldv_11_ldv_param_3_5);
      
#line 732 
      ldv_free((void *)ldv_11_ldv_param_1_4);
      
#line 733 
      ldv_free((void *)ldv_11_ldv_param_3_5);
    }
    
#line 737 
    goto ldv_30271;
    default: 
#line 739 
    ;
    
#line 739 
    __VERIFIER_assume(0);
  }
  ldv_30271: 
#line 748 
  ;
  
#line 748 
  goto ldv_call_11;
  
#line 750 
  __retres = (void *)0;
  return_label: 
#line 750 
                return __retres;
}


#line 755  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_75(void *arg0)
{
  void *__retres;
  struct file *ldv_75_resource_1;
  int ldv_75_ldv_param_2_3;
  long long ldv_75_ldv_param_1_2;
  char *ldv_75_ldv_param_1_4;
  struct inode *ldv_75_resource_0;
  unsigned long ldv_75_size_cnt;
  long long *ldv_75_ldv_param_3_5;
  char *ldv_75_ldv_param_1_6;
  long long *ldv_75_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 766 
  struct file_operations *ldv_75_container = ldv_emg_alias_rxpipe_rx_prep_beacon_drop_ops_2;
  
#line 767 
  int ldv_75_ret = ldv_undef_int();
  
#line 770 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 774 
  ldv_75_ret = ldv_undef_int();
  
#line 777 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 778 
    ldv_75_container = data->arg0;
    
#line 779 
    ldv_free((void *)data);
  }
  else ;
  
#line 784 
  ldv_75_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 785 
  tmp_1 = ldv_undef_int();
  
#line 785 
  ldv_75_size_cnt = (unsigned long)tmp_1;
  
#line 792 
  goto ldv_main_75;
  
#line 794 
  __retres = (void *)0;
  
#line 794 
  goto return_label;
  ldv_main_75: 
#line 797 
  ;
  
#line 800 
  tmp_3 = ldv_undef_int();
  
#line 800 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 803 
    ldv_75_ret = (*ldv_emg_alias_simple_open_5)(ldv_75_resource_0,ldv_75_resource_1);
    
#line 805 
    ldv_75_ret = ldv_filter_err_code(ldv_75_ret);
    
#line 808 
    tmp_2 = ldv_undef_int();
    
#line 808 
    if (tmp_2 != 0) {
      
#line 810 
      __VERIFIER_assume(ldv_75_ret == 0);
      
#line 817 
      goto ldv_call_75;
    }
    else {
      
#line 821 
      __VERIFIER_assume(ldv_75_ret != 0);
      
#line 828 
      goto ldv_main_75;
    }
  }
  else {
    
#line 833 
    ldv_free((void *)ldv_75_resource_0);
    
#line 841 
    __retres = (void *)0;
    
#line 841 
    goto return_label;
  }
  
#line 844 
  __retres = (void *)0;
  
#line 844 
  goto return_label;
  ldv_call_75: 
#line 847 
  ;
  
#line 850 
  tmp_4 = ldv_undef_int();
  
#line 850 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 851 
    ;
    
#line 853 
    ldv_75_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 854 
    ldv_75_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 858 
    if (ldv_75_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 864 
      __VERIFIER_assume(ldv_75_size_cnt <= 2147479552UL);
      
#line 866 
      (*(ldv_75_container->write))(ldv_75_resource_1,(char const *)ldv_75_ldv_param_1_6,ldv_75_size_cnt,ldv_75_ldv_param_3_7);
    }
    else ;
    
#line 871 
    ldv_free((void *)ldv_75_ldv_param_1_6);
    
#line 872 
    ldv_free((void *)ldv_75_ldv_param_3_7);
    
#line 879 
    goto ldv_call_75;
    case 2: 
#line 882 
    ;
    
#line 884 
    if (ldv_75_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 886 
      (*(ldv_75_container->release))(ldv_75_resource_0,ldv_75_resource_1); else ;
    
#line 894 
    goto ldv_main_75;
    case 3: 
#line 897 
    ;
    
#line 901 
    tmp_9 = ldv_undef_int();
    
#line 901 
    if (tmp_9 != 0) 
#line 904 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_75_resource_1,ldv_75_ldv_param_1_2,ldv_75_ldv_param_2_3);
    else {
      
#line 910 
      ldv_75_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 911 
      ldv_75_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 916 
      ldv_emg_wrapper_rxpipe_rx_prep_beacon_drop_read_3(ldv_75_resource_1,ldv_75_ldv_param_1_4,ldv_75_size_cnt,ldv_75_ldv_param_3_5);
      
#line 920 
      ldv_free((void *)ldv_75_ldv_param_3_5);
      
#line 921 
      ldv_free((void *)ldv_75_ldv_param_1_4);
    }
    
#line 925 
    goto ldv_30293;
    default: 
#line 927 
    ;
    
#line 927 
    __VERIFIER_assume(0);
  }
  ldv_30293: 
#line 936 
  ;
  
#line 936 
  goto ldv_call_75;
  
#line 938 
  __retres = (void *)0;
  return_label: 
#line 938 
                return __retres;
}


#line 943  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_69(void *arg0)
{
  void *__retres;
  struct file *ldv_69_resource_1;
  int ldv_69_ldv_param_2_3;
  long long ldv_69_ldv_param_1_2;
  char *ldv_69_ldv_param_1_4;
  struct inode *ldv_69_resource_0;
  unsigned long ldv_69_size_cnt;
  long long *ldv_69_ldv_param_3_5;
  char *ldv_69_ldv_param_1_6;
  long long *ldv_69_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 954 
  struct file_operations *ldv_69_container = ldv_emg_alias_rxpipe_descr_host_int_trig_rx_data_ops_2;
  
#line 955 
  int ldv_69_ret = ldv_undef_int();
  
#line 958 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 962 
  ldv_69_ret = ldv_undef_int();
  
#line 965 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 966 
    ldv_69_container = data->arg0;
    
#line 967 
    ldv_free((void *)data);
  }
  else ;
  
#line 972 
  ldv_69_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 973 
  tmp_1 = ldv_undef_int();
  
#line 973 
  ldv_69_size_cnt = (unsigned long)tmp_1;
  
#line 980 
  goto ldv_main_69;
  
#line 982 
  __retres = (void *)0;
  
#line 982 
  goto return_label;
  ldv_main_69: 
#line 985 
  ;
  
#line 988 
  tmp_3 = ldv_undef_int();
  
#line 988 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 991 
    ldv_69_ret = (*ldv_emg_alias_simple_open_5)(ldv_69_resource_0,ldv_69_resource_1);
    
#line 993 
    ldv_69_ret = ldv_filter_err_code(ldv_69_ret);
    
#line 996 
    tmp_2 = ldv_undef_int();
    
#line 996 
    if (tmp_2 != 0) {
      
#line 998 
      __VERIFIER_assume(ldv_69_ret == 0);
      
#line 1005 
      goto ldv_call_69;
    }
    else {
      
#line 1009 
      __VERIFIER_assume(ldv_69_ret != 0);
      
#line 1016 
      goto ldv_main_69;
    }
  }
  else {
    
#line 1021 
    ldv_free((void *)ldv_69_resource_0);
    
#line 1029 
    __retres = (void *)0;
    
#line 1029 
    goto return_label;
  }
  
#line 1032 
  __retres = (void *)0;
  
#line 1032 
  goto return_label;
  ldv_call_69: 
#line 1035 
  ;
  
#line 1038 
  tmp_4 = ldv_undef_int();
  
#line 1038 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 1039 
    ;
    
#line 1041 
    ldv_69_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 1042 
    ldv_69_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 1046 
    if (ldv_69_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 1052 
      __VERIFIER_assume(ldv_69_size_cnt <= 2147479552UL);
      
#line 1054 
      (*(ldv_69_container->write))(ldv_69_resource_1,(char const *)ldv_69_ldv_param_1_6,ldv_69_size_cnt,ldv_69_ldv_param_3_7);
    }
    else ;
    
#line 1059 
    ldv_free((void *)ldv_69_ldv_param_3_7);
    
#line 1060 
    ldv_free((void *)ldv_69_ldv_param_1_6);
    
#line 1067 
    goto ldv_call_69;
    case 2: 
#line 1070 
    ;
    
#line 1072 
    if (ldv_69_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 1074 
      (*(ldv_69_container->release))(ldv_69_resource_0,ldv_69_resource_1); else ;
    
#line 1082 
    goto ldv_main_69;
    case 3: 
#line 1085 
    ;
    
#line 1089 
    tmp_9 = ldv_undef_int();
    
#line 1089 
    if (tmp_9 != 0) 
#line 1092 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_69_resource_1,ldv_69_ldv_param_1_2,ldv_69_ldv_param_2_3);
    else {
      
#line 1098 
      ldv_69_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 1099 
      ldv_69_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 1104 
      ldv_emg_wrapper_rxpipe_descr_host_int_trig_rx_data_read_3(ldv_69_resource_1,ldv_69_ldv_param_1_4,ldv_69_size_cnt,ldv_69_ldv_param_3_5);
      
#line 1108 
      ldv_free((void *)ldv_69_ldv_param_3_5);
      
#line 1109 
      ldv_free((void *)ldv_69_ldv_param_1_4);
    }
    
#line 1113 
    goto ldv_30315;
    default: 
#line 1115 
    ;
    
#line 1115 
    __VERIFIER_assume(0);
  }
  ldv_30315: 
#line 1124 
  ;
  
#line 1124 
  goto ldv_call_69;
  
#line 1126 
  __retres = (void *)0;
  return_label: 
#line 1126 
                return __retres;
}


#line 1131  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_41(void *arg0)
{
  void *__retres;
  struct file *ldv_41_resource_1;
  int ldv_41_ldv_param_2_3;
  long long ldv_41_ldv_param_1_2;
  char *ldv_41_ldv_param_1_4;
  struct inode *ldv_41_resource_0;
  unsigned long ldv_41_size_cnt;
  long long *ldv_41_ldv_param_3_5;
  char *ldv_41_ldv_param_1_6;
  long long *ldv_41_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 1142 
  struct file_operations *ldv_41_container = ldv_emg_alias_tx_internal_desc_overflow_ops_2;
  
#line 1143 
  int ldv_41_ret = ldv_undef_int();
  
#line 1146 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 1150 
  ldv_41_ret = ldv_undef_int();
  
#line 1153 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 1154 
    ldv_41_container = data->arg0;
    
#line 1155 
    ldv_free((void *)data);
  }
  else ;
  
#line 1160 
  ldv_41_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 1161 
  tmp_1 = ldv_undef_int();
  
#line 1161 
  ldv_41_size_cnt = (unsigned long)tmp_1;
  
#line 1168 
  goto ldv_main_41;
  
#line 1170 
  __retres = (void *)0;
  
#line 1170 
  goto return_label;
  ldv_main_41: 
#line 1173 
  ;
  
#line 1176 
  tmp_3 = ldv_undef_int();
  
#line 1176 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 1179 
    ldv_41_ret = (*ldv_emg_alias_simple_open_5)(ldv_41_resource_0,ldv_41_resource_1);
    
#line 1181 
    ldv_41_ret = ldv_filter_err_code(ldv_41_ret);
    
#line 1184 
    tmp_2 = ldv_undef_int();
    
#line 1184 
    if (tmp_2 != 0) {
      
#line 1186 
      __VERIFIER_assume(ldv_41_ret == 0);
      
#line 1193 
      goto ldv_call_41;
    }
    else {
      
#line 1197 
      __VERIFIER_assume(ldv_41_ret != 0);
      
#line 1204 
      goto ldv_main_41;
    }
  }
  else {
    
#line 1209 
    ldv_free((void *)ldv_41_resource_0);
    
#line 1217 
    __retres = (void *)0;
    
#line 1217 
    goto return_label;
  }
  
#line 1220 
  __retres = (void *)0;
  
#line 1220 
  goto return_label;
  ldv_call_41: 
#line 1223 
  ;
  
#line 1226 
  tmp_4 = ldv_undef_int();
  
#line 1226 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 1227 
    ;
    
#line 1229 
    ldv_41_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 1230 
    ldv_41_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 1234 
    if (ldv_41_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 1240 
      __VERIFIER_assume(ldv_41_size_cnt <= 2147479552UL);
      
#line 1242 
      (*(ldv_41_container->write))(ldv_41_resource_1,(char const *)ldv_41_ldv_param_1_6,ldv_41_size_cnt,ldv_41_ldv_param_3_7);
    }
    else ;
    
#line 1247 
    ldv_free((void *)ldv_41_ldv_param_3_7);
    
#line 1248 
    ldv_free((void *)ldv_41_ldv_param_1_6);
    
#line 1255 
    goto ldv_call_41;
    case 2: 
#line 1258 
    ;
    
#line 1260 
    if (ldv_41_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 1262 
      (*(ldv_41_container->release))(ldv_41_resource_0,ldv_41_resource_1); else ;
    
#line 1270 
    goto ldv_main_41;
    case 3: 
#line 1273 
    ;
    
#line 1277 
    tmp_9 = ldv_undef_int();
    
#line 1277 
    if (tmp_9 != 0) 
#line 1280 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_41_resource_1,ldv_41_ldv_param_1_2,ldv_41_ldv_param_2_3);
    else {
      
#line 1286 
      ldv_41_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 1287 
      ldv_41_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 1292 
      ldv_emg_wrapper_tx_internal_desc_overflow_read_3(ldv_41_resource_1,ldv_41_ldv_param_1_4,ldv_41_size_cnt,ldv_41_ldv_param_3_5);
      
#line 1296 
      ldv_free((void *)ldv_41_ldv_param_3_5);
      
#line 1297 
      ldv_free((void *)ldv_41_ldv_param_1_4);
    }
    
#line 1301 
    goto ldv_30337;
    default: 
#line 1303 
    ;
    
#line 1303 
    __VERIFIER_assume(0);
  }
  ldv_30337: 
#line 1312 
  ;
  
#line 1312 
  goto ldv_call_41;
  
#line 1314 
  __retres = (void *)0;
  return_label: 
#line 1314 
                return __retres;
}


#line 1319  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_48(void *arg0)
{
  void *__retres;
  struct file *ldv_48_resource_1;
  int ldv_48_ldv_param_2_3;
  long long ldv_48_ldv_param_1_2;
  char *ldv_48_ldv_param_1_4;
  struct inode *ldv_48_resource_0;
  unsigned long ldv_48_size_cnt;
  long long *ldv_48_ldv_param_3_5;
  char *ldv_48_ldv_param_1_6;
  long long *ldv_48_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 1330 
  struct file_operations *ldv_48_container = ldv_emg_alias_wep_interrupt_ops_2;
  
#line 1331 
  int ldv_48_ret = ldv_undef_int();
  
#line 1334 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 1338 
  ldv_48_ret = ldv_undef_int();
  
#line 1341 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 1342 
    ldv_48_container = data->arg0;
    
#line 1343 
    ldv_free((void *)data);
  }
  else ;
  
#line 1348 
  ldv_48_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 1349 
  tmp_1 = ldv_undef_int();
  
#line 1349 
  ldv_48_size_cnt = (unsigned long)tmp_1;
  
#line 1356 
  goto ldv_main_48;
  
#line 1358 
  __retres = (void *)0;
  
#line 1358 
  goto return_label;
  ldv_main_48: 
#line 1361 
  ;
  
#line 1364 
  tmp_3 = ldv_undef_int();
  
#line 1364 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 1367 
    ldv_48_ret = (*ldv_emg_alias_simple_open_5)(ldv_48_resource_0,ldv_48_resource_1);
    
#line 1369 
    ldv_48_ret = ldv_filter_err_code(ldv_48_ret);
    
#line 1372 
    tmp_2 = ldv_undef_int();
    
#line 1372 
    if (tmp_2 != 0) {
      
#line 1374 
      __VERIFIER_assume(ldv_48_ret == 0);
      
#line 1381 
      goto ldv_call_48;
    }
    else {
      
#line 1385 
      __VERIFIER_assume(ldv_48_ret != 0);
      
#line 1392 
      goto ldv_main_48;
    }
  }
  else {
    
#line 1397 
    ldv_free((void *)ldv_48_resource_0);
    
#line 1405 
    __retres = (void *)0;
    
#line 1405 
    goto return_label;
  }
  
#line 1408 
  __retres = (void *)0;
  
#line 1408 
  goto return_label;
  ldv_call_48: 
#line 1411 
  ;
  
#line 1414 
  tmp_4 = ldv_undef_int();
  
#line 1414 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 1415 
    ;
    
#line 1417 
    ldv_48_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 1418 
    ldv_48_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 1422 
    if (ldv_48_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 1428 
      __VERIFIER_assume(ldv_48_size_cnt <= 2147479552UL);
      
#line 1430 
      (*(ldv_48_container->write))(ldv_48_resource_1,(char const *)ldv_48_ldv_param_1_6,ldv_48_size_cnt,ldv_48_ldv_param_3_7);
    }
    else ;
    
#line 1435 
    ldv_free((void *)ldv_48_ldv_param_3_7);
    
#line 1436 
    ldv_free((void *)ldv_48_ldv_param_1_6);
    
#line 1443 
    goto ldv_call_48;
    case 2: 
#line 1446 
    ;
    
#line 1448 
    if (ldv_48_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 1450 
      (*(ldv_48_container->release))(ldv_48_resource_0,ldv_48_resource_1); else ;
    
#line 1458 
    goto ldv_main_48;
    case 3: 
#line 1461 
    ;
    
#line 1465 
    tmp_9 = ldv_undef_int();
    
#line 1465 
    if (tmp_9 != 0) 
#line 1468 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_48_resource_1,ldv_48_ldv_param_1_2,ldv_48_ldv_param_2_3);
    else {
      
#line 1474 
      ldv_48_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 1475 
      ldv_48_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 1480 
      ldv_emg_wrapper_wep_interrupt_read_3(ldv_48_resource_1,ldv_48_ldv_param_1_4,ldv_48_size_cnt,ldv_48_ldv_param_3_5);
      
#line 1484 
      ldv_free((void *)ldv_48_ldv_param_1_4);
      
#line 1485 
      ldv_free((void *)ldv_48_ldv_param_3_5);
    }
    
#line 1489 
    goto ldv_30359;
    default: 
#line 1491 
    ;
    
#line 1491 
    __VERIFIER_assume(0);
  }
  ldv_30359: 
#line 1500 
  ;
  
#line 1500 
  goto ldv_call_48;
  
#line 1502 
  __retres = (void *)0;
  return_label: 
#line 1502 
                return __retres;
}


#line 1507  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_44(void *arg0)
{
  void *__retres;
  struct file *ldv_44_resource_1;
  int ldv_44_ldv_param_2_3;
  long long ldv_44_ldv_param_1_2;
  char *ldv_44_ldv_param_1_4;
  struct inode *ldv_44_resource_0;
  unsigned long ldv_44_size_cnt;
  long long *ldv_44_ldv_param_3_5;
  char *ldv_44_ldv_param_1_6;
  long long *ldv_44_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 1518 
  struct file_operations *ldv_44_container = ldv_emg_alias_pwr_tx_with_ps_ops_2;
  
#line 1519 
  int ldv_44_ret = ldv_undef_int();
  
#line 1522 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 1526 
  ldv_44_ret = ldv_undef_int();
  
#line 1529 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 1530 
    ldv_44_container = data->arg0;
    
#line 1531 
    ldv_free((void *)data);
  }
  else ;
  
#line 1536 
  ldv_44_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 1537 
  tmp_1 = ldv_undef_int();
  
#line 1537 
  ldv_44_size_cnt = (unsigned long)tmp_1;
  
#line 1544 
  goto ldv_main_44;
  
#line 1546 
  __retres = (void *)0;
  
#line 1546 
  goto return_label;
  ldv_main_44: 
#line 1549 
  ;
  
#line 1552 
  tmp_3 = ldv_undef_int();
  
#line 1552 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 1555 
    ldv_44_ret = (*ldv_emg_alias_simple_open_5)(ldv_44_resource_0,ldv_44_resource_1);
    
#line 1557 
    ldv_44_ret = ldv_filter_err_code(ldv_44_ret);
    
#line 1560 
    tmp_2 = ldv_undef_int();
    
#line 1560 
    if (tmp_2 != 0) {
      
#line 1562 
      __VERIFIER_assume(ldv_44_ret == 0);
      
#line 1569 
      goto ldv_call_44;
    }
    else {
      
#line 1573 
      __VERIFIER_assume(ldv_44_ret != 0);
      
#line 1580 
      goto ldv_main_44;
    }
  }
  else {
    
#line 1585 
    ldv_free((void *)ldv_44_resource_0);
    
#line 1593 
    __retres = (void *)0;
    
#line 1593 
    goto return_label;
  }
  
#line 1596 
  __retres = (void *)0;
  
#line 1596 
  goto return_label;
  ldv_call_44: 
#line 1599 
  ;
  
#line 1602 
  tmp_4 = ldv_undef_int();
  
#line 1602 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 1603 
    ;
    
#line 1605 
    ldv_44_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 1606 
    ldv_44_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 1610 
    if (ldv_44_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 1616 
      __VERIFIER_assume(ldv_44_size_cnt <= 2147479552UL);
      
#line 1618 
      (*(ldv_44_container->write))(ldv_44_resource_1,(char const *)ldv_44_ldv_param_1_6,ldv_44_size_cnt,ldv_44_ldv_param_3_7);
    }
    else ;
    
#line 1623 
    ldv_free((void *)ldv_44_ldv_param_3_7);
    
#line 1624 
    ldv_free((void *)ldv_44_ldv_param_1_6);
    
#line 1631 
    goto ldv_call_44;
    case 2: 
#line 1634 
    ;
    
#line 1636 
    if (ldv_44_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 1638 
      (*(ldv_44_container->release))(ldv_44_resource_0,ldv_44_resource_1); else ;
    
#line 1646 
    goto ldv_main_44;
    case 3: 
#line 1649 
    ;
    
#line 1653 
    tmp_9 = ldv_undef_int();
    
#line 1653 
    if (tmp_9 != 0) 
#line 1656 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_44_resource_1,ldv_44_ldv_param_1_2,ldv_44_ldv_param_2_3);
    else {
      
#line 1662 
      ldv_44_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 1663 
      ldv_44_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 1668 
      ldv_emg_wrapper_pwr_tx_with_ps_read_3(ldv_44_resource_1,ldv_44_ldv_param_1_4,ldv_44_size_cnt,ldv_44_ldv_param_3_5);
      
#line 1672 
      ldv_free((void *)ldv_44_ldv_param_3_5);
      
#line 1673 
      ldv_free((void *)ldv_44_ldv_param_1_4);
    }
    
#line 1677 
    goto ldv_30381;
    default: 
#line 1679 
    ;
    
#line 1679 
    __VERIFIER_assume(0);
  }
  ldv_30381: 
#line 1688 
  ;
  
#line 1688 
  goto ldv_call_44;
  
#line 1690 
  __retres = (void *)0;
  return_label: 
#line 1690 
                return __retres;
}


#line 1695  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_51(void *arg0)
{
  void *__retres;
  struct file *ldv_51_resource_1;
  int ldv_51_ldv_param_2_3;
  long long ldv_51_ldv_param_1_2;
  char *ldv_51_ldv_param_1_4;
  struct inode *ldv_51_resource_0;
  unsigned long ldv_51_size_cnt;
  long long *ldv_51_ldv_param_3_5;
  char *ldv_51_ldv_param_1_6;
  long long *ldv_51_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 1706 
  struct file_operations *ldv_51_container = ldv_emg_alias_ps_pspoll_utilization_ops_2;
  
#line 1707 
  int ldv_51_ret = ldv_undef_int();
  
#line 1710 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 1714 
  ldv_51_ret = ldv_undef_int();
  
#line 1717 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 1718 
    ldv_51_container = data->arg0;
    
#line 1719 
    ldv_free((void *)data);
  }
  else ;
  
#line 1724 
  ldv_51_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 1725 
  tmp_1 = ldv_undef_int();
  
#line 1725 
  ldv_51_size_cnt = (unsigned long)tmp_1;
  
#line 1732 
  goto ldv_main_51;
  
#line 1734 
  __retres = (void *)0;
  
#line 1734 
  goto return_label;
  ldv_main_51: 
#line 1737 
  ;
  
#line 1740 
  tmp_3 = ldv_undef_int();
  
#line 1740 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 1743 
    ldv_51_ret = (*ldv_emg_alias_simple_open_5)(ldv_51_resource_0,ldv_51_resource_1);
    
#line 1745 
    ldv_51_ret = ldv_filter_err_code(ldv_51_ret);
    
#line 1748 
    tmp_2 = ldv_undef_int();
    
#line 1748 
    if (tmp_2 != 0) {
      
#line 1750 
      __VERIFIER_assume(ldv_51_ret == 0);
      
#line 1757 
      goto ldv_call_51;
    }
    else {
      
#line 1761 
      __VERIFIER_assume(ldv_51_ret != 0);
      
#line 1768 
      goto ldv_main_51;
    }
  }
  else {
    
#line 1773 
    ldv_free((void *)ldv_51_resource_0);
    
#line 1781 
    __retres = (void *)0;
    
#line 1781 
    goto return_label;
  }
  
#line 1784 
  __retres = (void *)0;
  
#line 1784 
  goto return_label;
  ldv_call_51: 
#line 1787 
  ;
  
#line 1790 
  tmp_4 = ldv_undef_int();
  
#line 1790 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 1791 
    ;
    
#line 1793 
    ldv_51_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 1794 
    ldv_51_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 1798 
    if (ldv_51_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 1804 
      __VERIFIER_assume(ldv_51_size_cnt <= 2147479552UL);
      
#line 1806 
      (*(ldv_51_container->write))(ldv_51_resource_1,(char const *)ldv_51_ldv_param_1_6,ldv_51_size_cnt,ldv_51_ldv_param_3_7);
    }
    else ;
    
#line 1811 
    ldv_free((void *)ldv_51_ldv_param_3_7);
    
#line 1812 
    ldv_free((void *)ldv_51_ldv_param_1_6);
    
#line 1819 
    goto ldv_call_51;
    case 2: 
#line 1822 
    ;
    
#line 1824 
    if (ldv_51_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 1826 
      (*(ldv_51_container->release))(ldv_51_resource_0,ldv_51_resource_1); else ;
    
#line 1834 
    goto ldv_main_51;
    case 3: 
#line 1837 
    ;
    
#line 1841 
    tmp_9 = ldv_undef_int();
    
#line 1841 
    if (tmp_9 != 0) 
#line 1844 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_51_resource_1,ldv_51_ldv_param_1_2,ldv_51_ldv_param_2_3);
    else {
      
#line 1850 
      ldv_51_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 1851 
      ldv_51_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 1856 
      ldv_emg_wrapper_ps_pspoll_utilization_read_3(ldv_51_resource_1,ldv_51_ldv_param_1_4,ldv_51_size_cnt,ldv_51_ldv_param_3_5);
      
#line 1860 
      ldv_free((void *)ldv_51_ldv_param_3_5);
      
#line 1861 
      ldv_free((void *)ldv_51_ldv_param_1_4);
    }
    
#line 1865 
    goto ldv_30403;
    default: 
#line 1867 
    ;
    
#line 1867 
    __VERIFIER_assume(0);
  }
  ldv_30403: 
#line 1876 
  ;
  
#line 1876 
  goto ldv_call_51;
  
#line 1878 
  __retres = (void *)0;
  return_label: 
#line 1878 
                return __retres;
}


#line 1883  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_29(void *arg0)
{
  void *__retres;
  struct file *ldv_29_resource_1;
  int ldv_29_ldv_param_2_3;
  long long ldv_29_ldv_param_1_2;
  char *ldv_29_ldv_param_1_4;
  struct inode *ldv_29_resource_0;
  unsigned long ldv_29_size_cnt;
  long long *ldv_29_ldv_param_3_5;
  char *ldv_29_ldv_param_1_6;
  long long *ldv_29_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 1894 
  struct file_operations *ldv_29_container = ldv_emg_alias_wep_key_not_found_ops_2;
  
#line 1895 
  int ldv_29_ret = ldv_undef_int();
  
#line 1898 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 1902 
  ldv_29_ret = ldv_undef_int();
  
#line 1905 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 1906 
    ldv_29_container = data->arg0;
    
#line 1907 
    ldv_free((void *)data);
  }
  else ;
  
#line 1912 
  ldv_29_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 1913 
  tmp_1 = ldv_undef_int();
  
#line 1913 
  ldv_29_size_cnt = (unsigned long)tmp_1;
  
#line 1920 
  goto ldv_main_29;
  
#line 1922 
  __retres = (void *)0;
  
#line 1922 
  goto return_label;
  ldv_main_29: 
#line 1925 
  ;
  
#line 1928 
  tmp_3 = ldv_undef_int();
  
#line 1928 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 1931 
    ldv_29_ret = (*ldv_emg_alias_simple_open_5)(ldv_29_resource_0,ldv_29_resource_1);
    
#line 1933 
    ldv_29_ret = ldv_filter_err_code(ldv_29_ret);
    
#line 1936 
    tmp_2 = ldv_undef_int();
    
#line 1936 
    if (tmp_2 != 0) {
      
#line 1938 
      __VERIFIER_assume(ldv_29_ret == 0);
      
#line 1945 
      goto ldv_call_29;
    }
    else {
      
#line 1949 
      __VERIFIER_assume(ldv_29_ret != 0);
      
#line 1956 
      goto ldv_main_29;
    }
  }
  else {
    
#line 1961 
    ldv_free((void *)ldv_29_resource_0);
    
#line 1969 
    __retres = (void *)0;
    
#line 1969 
    goto return_label;
  }
  
#line 1972 
  __retres = (void *)0;
  
#line 1972 
  goto return_label;
  ldv_call_29: 
#line 1975 
  ;
  
#line 1978 
  tmp_4 = ldv_undef_int();
  
#line 1978 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 1979 
    ;
    
#line 1981 
    ldv_29_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 1982 
    ldv_29_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 1986 
    if (ldv_29_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 1992 
      __VERIFIER_assume(ldv_29_size_cnt <= 2147479552UL);
      
#line 1994 
      (*(ldv_29_container->write))(ldv_29_resource_1,(char const *)ldv_29_ldv_param_1_6,ldv_29_size_cnt,ldv_29_ldv_param_3_7);
    }
    else ;
    
#line 1999 
    ldv_free((void *)ldv_29_ldv_param_3_7);
    
#line 2000 
    ldv_free((void *)ldv_29_ldv_param_1_6);
    
#line 2007 
    goto ldv_call_29;
    case 2: 
#line 2010 
    ;
    
#line 2012 
    if (ldv_29_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 2014 
      (*(ldv_29_container->release))(ldv_29_resource_0,ldv_29_resource_1); else ;
    
#line 2022 
    goto ldv_main_29;
    case 3: 
#line 2025 
    ;
    
#line 2029 
    tmp_9 = ldv_undef_int();
    
#line 2029 
    if (tmp_9 != 0) 
#line 2032 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_29_resource_1,ldv_29_ldv_param_1_2,ldv_29_ldv_param_2_3);
    else {
      
#line 2038 
      ldv_29_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 2039 
      ldv_29_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 2044 
      ldv_emg_wrapper_wep_key_not_found_read_3(ldv_29_resource_1,ldv_29_ldv_param_1_4,ldv_29_size_cnt,ldv_29_ldv_param_3_5);
      
#line 2048 
      ldv_free((void *)ldv_29_ldv_param_3_5);
      
#line 2049 
      ldv_free((void *)ldv_29_ldv_param_1_4);
    }
    
#line 2053 
    goto ldv_30425;
    default: 
#line 2055 
    ;
    
#line 2055 
    __VERIFIER_assume(0);
  }
  ldv_30425: 
#line 2064 
  ;
  
#line 2064 
  goto ldv_call_29;
  
#line 2066 
  __retres = (void *)0;
  return_label: 
#line 2066 
                return __retres;
}


#line 2071  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_36(void *arg0)
{
  void *__retres;
  struct file *ldv_36_resource_1;
  int ldv_36_ldv_param_2_3;
  long long ldv_36_ldv_param_1_2;
  char *ldv_36_ldv_param_1_4;
  struct inode *ldv_36_resource_0;
  unsigned long ldv_36_size_cnt;
  long long *ldv_36_ldv_param_3_5;
  char *ldv_36_ldv_param_1_6;
  long long *ldv_36_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 2082 
  struct file_operations *ldv_36_container = ldv_emg_alias_rx_reset_counter_ops_2;
  
#line 2083 
  int ldv_36_ret = ldv_undef_int();
  
#line 2086 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 2090 
  ldv_36_ret = ldv_undef_int();
  
#line 2093 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 2094 
    ldv_36_container = data->arg0;
    
#line 2095 
    ldv_free((void *)data);
  }
  else ;
  
#line 2100 
  ldv_36_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 2101 
  tmp_1 = ldv_undef_int();
  
#line 2101 
  ldv_36_size_cnt = (unsigned long)tmp_1;
  
#line 2108 
  goto ldv_main_36;
  
#line 2110 
  __retres = (void *)0;
  
#line 2110 
  goto return_label;
  ldv_main_36: 
#line 2113 
  ;
  
#line 2116 
  tmp_3 = ldv_undef_int();
  
#line 2116 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 2119 
    ldv_36_ret = (*ldv_emg_alias_simple_open_5)(ldv_36_resource_0,ldv_36_resource_1);
    
#line 2121 
    ldv_36_ret = ldv_filter_err_code(ldv_36_ret);
    
#line 2124 
    tmp_2 = ldv_undef_int();
    
#line 2124 
    if (tmp_2 != 0) {
      
#line 2126 
      __VERIFIER_assume(ldv_36_ret == 0);
      
#line 2133 
      goto ldv_call_36;
    }
    else {
      
#line 2137 
      __VERIFIER_assume(ldv_36_ret != 0);
      
#line 2144 
      goto ldv_main_36;
    }
  }
  else {
    
#line 2149 
    ldv_free((void *)ldv_36_resource_0);
    
#line 2157 
    __retres = (void *)0;
    
#line 2157 
    goto return_label;
  }
  
#line 2160 
  __retres = (void *)0;
  
#line 2160 
  goto return_label;
  ldv_call_36: 
#line 2163 
  ;
  
#line 2166 
  tmp_4 = ldv_undef_int();
  
#line 2166 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 2167 
    ;
    
#line 2169 
    ldv_36_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 2170 
    ldv_36_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 2174 
    if (ldv_36_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 2180 
      __VERIFIER_assume(ldv_36_size_cnt <= 2147479552UL);
      
#line 2182 
      (*(ldv_36_container->write))(ldv_36_resource_1,(char const *)ldv_36_ldv_param_1_6,ldv_36_size_cnt,ldv_36_ldv_param_3_7);
    }
    else ;
    
#line 2187 
    ldv_free((void *)ldv_36_ldv_param_3_7);
    
#line 2188 
    ldv_free((void *)ldv_36_ldv_param_1_6);
    
#line 2195 
    goto ldv_call_36;
    case 2: 
#line 2198 
    ;
    
#line 2200 
    if (ldv_36_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 2202 
      (*(ldv_36_container->release))(ldv_36_resource_0,ldv_36_resource_1); else ;
    
#line 2210 
    goto ldv_main_36;
    case 3: 
#line 2213 
    ;
    
#line 2217 
    tmp_9 = ldv_undef_int();
    
#line 2217 
    if (tmp_9 != 0) 
#line 2220 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_36_resource_1,ldv_36_ldv_param_1_2,ldv_36_ldv_param_2_3);
    else {
      
#line 2226 
      ldv_36_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 2227 
      ldv_36_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 2232 
      ldv_emg_wrapper_rx_reset_counter_read_3(ldv_36_resource_1,ldv_36_ldv_param_1_4,ldv_36_size_cnt,ldv_36_ldv_param_3_5);
      
#line 2236 
      ldv_free((void *)ldv_36_ldv_param_1_4);
      
#line 2237 
      ldv_free((void *)ldv_36_ldv_param_3_5);
    }
    
#line 2241 
    goto ldv_30447;
    default: 
#line 2243 
    ;
    
#line 2243 
    __VERIFIER_assume(0);
  }
  ldv_30447: 
#line 2252 
  ;
  
#line 2252 
  goto ldv_call_36;
  
#line 2254 
  __retres = (void *)0;
  return_label: 
#line 2254 
                return __retres;
}


#line 2259  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_37(void *arg0)
{
  void *__retres;
  struct file *ldv_37_resource_1;
  int ldv_37_ldv_param_2_3;
  long long ldv_37_ldv_param_1_2;
  char *ldv_37_ldv_param_1_4;
  struct inode *ldv_37_resource_0;
  unsigned long ldv_37_size_cnt;
  long long *ldv_37_ldv_param_3_5;
  char *ldv_37_ldv_param_1_6;
  long long *ldv_37_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 2270 
  struct file_operations *ldv_37_container = ldv_emg_alias_isr_tx_exch_complete_ops_2;
  
#line 2271 
  int ldv_37_ret = ldv_undef_int();
  
#line 2274 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 2278 
  ldv_37_ret = ldv_undef_int();
  
#line 2281 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 2282 
    ldv_37_container = data->arg0;
    
#line 2283 
    ldv_free((void *)data);
  }
  else ;
  
#line 2288 
  ldv_37_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 2289 
  tmp_1 = ldv_undef_int();
  
#line 2289 
  ldv_37_size_cnt = (unsigned long)tmp_1;
  
#line 2296 
  goto ldv_main_37;
  
#line 2298 
  __retres = (void *)0;
  
#line 2298 
  goto return_label;
  ldv_main_37: 
#line 2301 
  ;
  
#line 2304 
  tmp_3 = ldv_undef_int();
  
#line 2304 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 2307 
    ldv_37_ret = (*ldv_emg_alias_simple_open_5)(ldv_37_resource_0,ldv_37_resource_1);
    
#line 2309 
    ldv_37_ret = ldv_filter_err_code(ldv_37_ret);
    
#line 2312 
    tmp_2 = ldv_undef_int();
    
#line 2312 
    if (tmp_2 != 0) {
      
#line 2314 
      __VERIFIER_assume(ldv_37_ret == 0);
      
#line 2321 
      goto ldv_call_37;
    }
    else {
      
#line 2325 
      __VERIFIER_assume(ldv_37_ret != 0);
      
#line 2332 
      goto ldv_main_37;
    }
  }
  else {
    
#line 2337 
    ldv_free((void *)ldv_37_resource_0);
    
#line 2345 
    __retres = (void *)0;
    
#line 2345 
    goto return_label;
  }
  
#line 2348 
  __retres = (void *)0;
  
#line 2348 
  goto return_label;
  ldv_call_37: 
#line 2351 
  ;
  
#line 2354 
  tmp_4 = ldv_undef_int();
  
#line 2354 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 2355 
    ;
    
#line 2357 
    ldv_37_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 2358 
    ldv_37_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 2362 
    if (ldv_37_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 2368 
      __VERIFIER_assume(ldv_37_size_cnt <= 2147479552UL);
      
#line 2370 
      (*(ldv_37_container->write))(ldv_37_resource_1,(char const *)ldv_37_ldv_param_1_6,ldv_37_size_cnt,ldv_37_ldv_param_3_7);
    }
    else ;
    
#line 2375 
    ldv_free((void *)ldv_37_ldv_param_1_6);
    
#line 2376 
    ldv_free((void *)ldv_37_ldv_param_3_7);
    
#line 2383 
    goto ldv_call_37;
    case 2: 
#line 2386 
    ;
    
#line 2388 
    if (ldv_37_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 2390 
      (*(ldv_37_container->release))(ldv_37_resource_0,ldv_37_resource_1); else ;
    
#line 2398 
    goto ldv_main_37;
    case 3: 
#line 2401 
    ;
    
#line 2405 
    tmp_9 = ldv_undef_int();
    
#line 2405 
    if (tmp_9 != 0) 
#line 2408 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_37_resource_1,ldv_37_ldv_param_1_2,ldv_37_ldv_param_2_3);
    else {
      
#line 2414 
      ldv_37_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 2415 
      ldv_37_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 2420 
      ldv_emg_wrapper_isr_tx_exch_complete_read_3(ldv_37_resource_1,ldv_37_ldv_param_1_4,ldv_37_size_cnt,ldv_37_ldv_param_3_5);
      
#line 2424 
      ldv_free((void *)ldv_37_ldv_param_3_5);
      
#line 2425 
      ldv_free((void *)ldv_37_ldv_param_1_4);
    }
    
#line 2429 
    goto ldv_30469;
    default: 
#line 2431 
    ;
    
#line 2431 
    __VERIFIER_assume(0);
  }
  ldv_30469: 
#line 2440 
  ;
  
#line 2440 
  goto ldv_call_37;
  
#line 2442 
  __retres = (void *)0;
  return_label: 
#line 2442 
                return __retres;
}


#line 2447  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_83(void *arg0)
{
  void *__retres;
  struct file *ldv_83_resource_1;
  int ldv_83_ldv_param_2_3;
  long long ldv_83_ldv_param_1_2;
  char *ldv_83_ldv_param_1_4;
  struct inode *ldv_83_resource_0;
  unsigned long ldv_83_size_cnt;
  long long *ldv_83_ldv_param_3_5;
  char *ldv_83_ldv_param_1_6;
  long long *ldv_83_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 2458 
  struct file_operations *ldv_83_container = ldv_emg_alias_dma_tx_errors_ops_2;
  
#line 2459 
  int ldv_83_ret = ldv_undef_int();
  
#line 2462 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 2466 
  ldv_83_ret = ldv_undef_int();
  
#line 2469 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 2470 
    ldv_83_container = data->arg0;
    
#line 2471 
    ldv_free((void *)data);
  }
  else ;
  
#line 2476 
  ldv_83_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 2477 
  tmp_1 = ldv_undef_int();
  
#line 2477 
  ldv_83_size_cnt = (unsigned long)tmp_1;
  
#line 2484 
  goto ldv_main_83;
  
#line 2486 
  __retres = (void *)0;
  
#line 2486 
  goto return_label;
  ldv_main_83: 
#line 2489 
  ;
  
#line 2492 
  tmp_3 = ldv_undef_int();
  
#line 2492 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 2495 
    ldv_83_ret = (*ldv_emg_alias_simple_open_5)(ldv_83_resource_0,ldv_83_resource_1);
    
#line 2497 
    ldv_83_ret = ldv_filter_err_code(ldv_83_ret);
    
#line 2500 
    tmp_2 = ldv_undef_int();
    
#line 2500 
    if (tmp_2 != 0) {
      
#line 2502 
      __VERIFIER_assume(ldv_83_ret == 0);
      
#line 2509 
      goto ldv_call_83;
    }
    else {
      
#line 2513 
      __VERIFIER_assume(ldv_83_ret != 0);
      
#line 2520 
      goto ldv_main_83;
    }
  }
  else {
    
#line 2525 
    ldv_free((void *)ldv_83_resource_0);
    
#line 2533 
    __retres = (void *)0;
    
#line 2533 
    goto return_label;
  }
  
#line 2536 
  __retres = (void *)0;
  
#line 2536 
  goto return_label;
  ldv_call_83: 
#line 2539 
  ;
  
#line 2542 
  tmp_4 = ldv_undef_int();
  
#line 2542 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 2543 
    ;
    
#line 2545 
    ldv_83_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 2546 
    ldv_83_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 2550 
    if (ldv_83_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 2556 
      __VERIFIER_assume(ldv_83_size_cnt <= 2147479552UL);
      
#line 2558 
      (*(ldv_83_container->write))(ldv_83_resource_1,(char const *)ldv_83_ldv_param_1_6,ldv_83_size_cnt,ldv_83_ldv_param_3_7);
    }
    else ;
    
#line 2563 
    ldv_free((void *)ldv_83_ldv_param_3_7);
    
#line 2564 
    ldv_free((void *)ldv_83_ldv_param_1_6);
    
#line 2571 
    goto ldv_call_83;
    case 2: 
#line 2574 
    ;
    
#line 2576 
    if (ldv_83_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 2578 
      (*(ldv_83_container->release))(ldv_83_resource_0,ldv_83_resource_1); else ;
    
#line 2586 
    goto ldv_main_83;
    case 3: 
#line 2589 
    ;
    
#line 2593 
    tmp_9 = ldv_undef_int();
    
#line 2593 
    if (tmp_9 != 0) 
#line 2596 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_83_resource_1,ldv_83_ldv_param_1_2,ldv_83_ldv_param_2_3);
    else {
      
#line 2602 
      ldv_83_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 2603 
      ldv_83_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 2608 
      ldv_emg_wrapper_dma_tx_errors_read_3(ldv_83_resource_1,ldv_83_ldv_param_1_4,ldv_83_size_cnt,ldv_83_ldv_param_3_5);
      
#line 2612 
      ldv_free((void *)ldv_83_ldv_param_3_5);
      
#line 2613 
      ldv_free((void *)ldv_83_ldv_param_1_4);
    }
    
#line 2617 
    goto ldv_30491;
    default: 
#line 2619 
    ;
    
#line 2619 
    __VERIFIER_assume(0);
  }
  ldv_30491: 
#line 2628 
  ;
  
#line 2628 
  goto ldv_call_83;
  
#line 2630 
  __retres = (void *)0;
  return_label: 
#line 2630 
                return __retres;
}


#line 2635  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_10(void *arg0)
{
  void *__retres;
  struct file *ldv_10_resource_1;
  int ldv_10_ldv_param_2_3;
  long long ldv_10_ldv_param_1_2;
  char *ldv_10_ldv_param_1_4;
  struct inode *ldv_10_resource_0;
  unsigned long ldv_10_size_cnt;
  long long *ldv_10_ldv_param_3_5;
  char *ldv_10_ldv_param_1_6;
  long long *ldv_10_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 2646 
  struct file_operations *ldv_10_container = ldv_emg_alias_aes_encrypt_fail_ops_2;
  
#line 2647 
  int ldv_10_ret = ldv_undef_int();
  
#line 2650 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 2654 
  ldv_10_ret = ldv_undef_int();
  
#line 2657 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 2658 
    ldv_10_container = data->arg0;
    
#line 2659 
    ldv_free((void *)data);
  }
  else ;
  
#line 2664 
  ldv_10_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 2665 
  tmp_1 = ldv_undef_int();
  
#line 2665 
  ldv_10_size_cnt = (unsigned long)tmp_1;
  
#line 2672 
  goto ldv_main_10;
  
#line 2674 
  __retres = (void *)0;
  
#line 2674 
  goto return_label;
  ldv_main_10: 
#line 2677 
  ;
  
#line 2680 
  tmp_3 = ldv_undef_int();
  
#line 2680 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 2683 
    ldv_10_ret = (*ldv_emg_alias_simple_open_5)(ldv_10_resource_0,ldv_10_resource_1);
    
#line 2685 
    ldv_10_ret = ldv_filter_err_code(ldv_10_ret);
    
#line 2688 
    tmp_2 = ldv_undef_int();
    
#line 2688 
    if (tmp_2 != 0) {
      
#line 2690 
      __VERIFIER_assume(ldv_10_ret == 0);
      
#line 2697 
      goto ldv_call_10;
    }
    else {
      
#line 2701 
      __VERIFIER_assume(ldv_10_ret != 0);
      
#line 2708 
      goto ldv_main_10;
    }
  }
  else {
    
#line 2713 
    ldv_free((void *)ldv_10_resource_0);
    
#line 2721 
    __retres = (void *)0;
    
#line 2721 
    goto return_label;
  }
  
#line 2724 
  __retres = (void *)0;
  
#line 2724 
  goto return_label;
  ldv_call_10: 
#line 2727 
  ;
  
#line 2730 
  tmp_4 = ldv_undef_int();
  
#line 2730 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 2731 
    ;
    
#line 2733 
    ldv_10_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 2734 
    ldv_10_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 2738 
    if (ldv_10_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 2744 
      __VERIFIER_assume(ldv_10_size_cnt <= 2147479552UL);
      
#line 2746 
      (*(ldv_10_container->write))(ldv_10_resource_1,(char const *)ldv_10_ldv_param_1_6,ldv_10_size_cnt,ldv_10_ldv_param_3_7);
    }
    else ;
    
#line 2751 
    ldv_free((void *)ldv_10_ldv_param_3_7);
    
#line 2752 
    ldv_free((void *)ldv_10_ldv_param_1_6);
    
#line 2759 
    goto ldv_call_10;
    case 2: 
#line 2762 
    ;
    
#line 2764 
    if (ldv_10_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 2766 
      (*(ldv_10_container->release))(ldv_10_resource_0,ldv_10_resource_1); else ;
    
#line 2774 
    goto ldv_main_10;
    case 3: 
#line 2777 
    ;
    
#line 2781 
    tmp_9 = ldv_undef_int();
    
#line 2781 
    if (tmp_9 != 0) 
#line 2784 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_10_resource_1,ldv_10_ldv_param_1_2,ldv_10_ldv_param_2_3);
    else {
      
#line 2790 
      ldv_10_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 2791 
      ldv_10_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 2796 
      ldv_emg_wrapper_aes_encrypt_fail_read_3(ldv_10_resource_1,ldv_10_ldv_param_1_4,ldv_10_size_cnt,ldv_10_ldv_param_3_5);
      
#line 2800 
      ldv_free((void *)ldv_10_ldv_param_1_4);
      
#line 2801 
      ldv_free((void *)ldv_10_ldv_param_3_5);
    }
    
#line 2805 
    goto ldv_30513;
    default: 
#line 2807 
    ;
    
#line 2807 
    __VERIFIER_assume(0);
  }
  ldv_30513: 
#line 2816 
  ;
  
#line 2816 
  goto ldv_call_10;
  
#line 2818 
  __retres = (void *)0;
  return_label: 
#line 2818 
                return __retres;
}


#line 2823  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_40(void *arg0)
{
  void *__retres;
  struct file *ldv_40_resource_1;
  int ldv_40_ldv_param_2_3;
  long long ldv_40_ldv_param_1_2;
  char *ldv_40_ldv_param_1_4;
  struct inode *ldv_40_resource_0;
  unsigned long ldv_40_size_cnt;
  long long *ldv_40_ldv_param_3_5;
  char *ldv_40_ldv_param_1_6;
  long long *ldv_40_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 2834 
  struct file_operations *ldv_40_container = ldv_emg_alias_ps_pspoll_timeouts_ops_2;
  
#line 2835 
  int ldv_40_ret = ldv_undef_int();
  
#line 2838 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 2842 
  ldv_40_ret = ldv_undef_int();
  
#line 2845 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 2846 
    ldv_40_container = data->arg0;
    
#line 2847 
    ldv_free((void *)data);
  }
  else ;
  
#line 2852 
  ldv_40_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 2853 
  tmp_1 = ldv_undef_int();
  
#line 2853 
  ldv_40_size_cnt = (unsigned long)tmp_1;
  
#line 2860 
  goto ldv_main_40;
  
#line 2862 
  __retres = (void *)0;
  
#line 2862 
  goto return_label;
  ldv_main_40: 
#line 2865 
  ;
  
#line 2868 
  tmp_3 = ldv_undef_int();
  
#line 2868 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 2871 
    ldv_40_ret = (*ldv_emg_alias_simple_open_5)(ldv_40_resource_0,ldv_40_resource_1);
    
#line 2873 
    ldv_40_ret = ldv_filter_err_code(ldv_40_ret);
    
#line 2876 
    tmp_2 = ldv_undef_int();
    
#line 2876 
    if (tmp_2 != 0) {
      
#line 2878 
      __VERIFIER_assume(ldv_40_ret == 0);
      
#line 2885 
      goto ldv_call_40;
    }
    else {
      
#line 2889 
      __VERIFIER_assume(ldv_40_ret != 0);
      
#line 2896 
      goto ldv_main_40;
    }
  }
  else {
    
#line 2901 
    ldv_free((void *)ldv_40_resource_0);
    
#line 2909 
    __retres = (void *)0;
    
#line 2909 
    goto return_label;
  }
  
#line 2912 
  __retres = (void *)0;
  
#line 2912 
  goto return_label;
  ldv_call_40: 
#line 2915 
  ;
  
#line 2918 
  tmp_4 = ldv_undef_int();
  
#line 2918 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 2919 
    ;
    
#line 2921 
    ldv_40_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 2922 
    ldv_40_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 2926 
    if (ldv_40_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 2932 
      __VERIFIER_assume(ldv_40_size_cnt <= 2147479552UL);
      
#line 2934 
      (*(ldv_40_container->write))(ldv_40_resource_1,(char const *)ldv_40_ldv_param_1_6,ldv_40_size_cnt,ldv_40_ldv_param_3_7);
    }
    else ;
    
#line 2939 
    ldv_free((void *)ldv_40_ldv_param_3_7);
    
#line 2940 
    ldv_free((void *)ldv_40_ldv_param_1_6);
    
#line 2947 
    goto ldv_call_40;
    case 2: 
#line 2950 
    ;
    
#line 2952 
    if (ldv_40_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 2954 
      (*(ldv_40_container->release))(ldv_40_resource_0,ldv_40_resource_1); else ;
    
#line 2962 
    goto ldv_main_40;
    case 3: 
#line 2965 
    ;
    
#line 2969 
    tmp_9 = ldv_undef_int();
    
#line 2969 
    if (tmp_9 != 0) 
#line 2972 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_40_resource_1,ldv_40_ldv_param_1_2,ldv_40_ldv_param_2_3);
    else {
      
#line 2978 
      ldv_40_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 2979 
      ldv_40_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 2984 
      ldv_emg_wrapper_ps_pspoll_timeouts_read_3(ldv_40_resource_1,ldv_40_ldv_param_1_4,ldv_40_size_cnt,ldv_40_ldv_param_3_5);
      
#line 2988 
      ldv_free((void *)ldv_40_ldv_param_1_4);
      
#line 2989 
      ldv_free((void *)ldv_40_ldv_param_3_5);
    }
    
#line 2993 
    goto ldv_30535;
    default: 
#line 2995 
    ;
    
#line 2995 
    __VERIFIER_assume(0);
  }
  ldv_30535: 
#line 3004 
  ;
  
#line 3004 
  goto ldv_call_40;
  
#line 3006 
  __retres = (void *)0;
  return_label: 
#line 3006 
                return __retres;
}


#line 3011  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_initialization_1(void *arg0)
{
  void *__retres;
  int ldv_1_ret;
  int tmp;
  
#line 3018 
  ldv_1_ret = ldv_emg_wl12xx_driver_init();
  
#line 3019 
  ldv_1_ret = ldv_post_init(ldv_1_ret);
  
#line 3022 
  tmp = ldv_undef_int();
  
#line 3022 
  if (tmp != 0) {
    
#line 3024 
    __VERIFIER_assume(ldv_1_ret != 0);
    
#line 3028 
    __retres = (void *)0;
    
#line 3028 
    goto return_label;
  }
  else {
    
#line 3032 
    __VERIFIER_assume(ldv_1_ret == 0);
    
#line 3037 
    ldv_emg_wl12xx_driver_exit();
    
#line 3041 
    __retres = (void *)0;
    
#line 3041 
    goto return_label;
  }
  
#line 3044 
  __retres = (void *)0;
  return_label: 
#line 3044 
                return __retres;
}


#line 3049  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_65(void *arg0)
{
  void *__retres;
  struct file *ldv_65_resource_1;
  int ldv_65_ldv_param_2_3;
  long long ldv_65_ldv_param_1_2;
  char *ldv_65_ldv_param_1_4;
  struct inode *ldv_65_resource_0;
  unsigned long ldv_65_size_cnt;
  long long *ldv_65_ldv_param_3_5;
  char *ldv_65_ldv_param_1_6;
  long long *ldv_65_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 3060 
  struct file_operations *ldv_65_container = ldv_emg_alias_rx_hw_stuck_ops_2;
  
#line 3061 
  int ldv_65_ret = ldv_undef_int();
  
#line 3064 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 3068 
  ldv_65_ret = ldv_undef_int();
  
#line 3071 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 3072 
    ldv_65_container = data->arg0;
    
#line 3073 
    ldv_free((void *)data);
  }
  else ;
  
#line 3078 
  ldv_65_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 3079 
  tmp_1 = ldv_undef_int();
  
#line 3079 
  ldv_65_size_cnt = (unsigned long)tmp_1;
  
#line 3086 
  goto ldv_main_65;
  
#line 3088 
  __retres = (void *)0;
  
#line 3088 
  goto return_label;
  ldv_main_65: 
#line 3091 
  ;
  
#line 3094 
  tmp_3 = ldv_undef_int();
  
#line 3094 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 3097 
    ldv_65_ret = (*ldv_emg_alias_simple_open_5)(ldv_65_resource_0,ldv_65_resource_1);
    
#line 3099 
    ldv_65_ret = ldv_filter_err_code(ldv_65_ret);
    
#line 3102 
    tmp_2 = ldv_undef_int();
    
#line 3102 
    if (tmp_2 != 0) {
      
#line 3104 
      __VERIFIER_assume(ldv_65_ret == 0);
      
#line 3111 
      goto ldv_call_65;
    }
    else {
      
#line 3115 
      __VERIFIER_assume(ldv_65_ret != 0);
      
#line 3122 
      goto ldv_main_65;
    }
  }
  else {
    
#line 3127 
    ldv_free((void *)ldv_65_resource_0);
    
#line 3135 
    __retres = (void *)0;
    
#line 3135 
    goto return_label;
  }
  
#line 3138 
  __retres = (void *)0;
  
#line 3138 
  goto return_label;
  ldv_call_65: 
#line 3141 
  ;
  
#line 3144 
  tmp_4 = ldv_undef_int();
  
#line 3144 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 3145 
    ;
    
#line 3147 
    ldv_65_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 3148 
    ldv_65_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 3152 
    if (ldv_65_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 3158 
      __VERIFIER_assume(ldv_65_size_cnt <= 2147479552UL);
      
#line 3160 
      (*(ldv_65_container->write))(ldv_65_resource_1,(char const *)ldv_65_ldv_param_1_6,ldv_65_size_cnt,ldv_65_ldv_param_3_7);
    }
    else ;
    
#line 3165 
    ldv_free((void *)ldv_65_ldv_param_3_7);
    
#line 3166 
    ldv_free((void *)ldv_65_ldv_param_1_6);
    
#line 3173 
    goto ldv_call_65;
    case 2: 
#line 3176 
    ;
    
#line 3178 
    if (ldv_65_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 3180 
      (*(ldv_65_container->release))(ldv_65_resource_0,ldv_65_resource_1); else ;
    
#line 3188 
    goto ldv_main_65;
    case 3: 
#line 3191 
    ;
    
#line 3195 
    tmp_9 = ldv_undef_int();
    
#line 3195 
    if (tmp_9 != 0) 
#line 3198 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_65_resource_1,ldv_65_ldv_param_1_2,ldv_65_ldv_param_2_3);
    else {
      
#line 3204 
      ldv_65_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 3205 
      ldv_65_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 3210 
      ldv_emg_wrapper_rx_hw_stuck_read_3(ldv_65_resource_1,ldv_65_ldv_param_1_4,ldv_65_size_cnt,ldv_65_ldv_param_3_5);
      
#line 3214 
      ldv_free((void *)ldv_65_ldv_param_3_5);
      
#line 3215 
      ldv_free((void *)ldv_65_ldv_param_1_4);
    }
    
#line 3219 
    goto ldv_30561;
    default: 
#line 3221 
    ;
    
#line 3221 
    __VERIFIER_assume(0);
  }
  ldv_30561: 
#line 3230 
  ;
  
#line 3230 
  goto ldv_call_65;
  
#line 3232 
  __retres = (void *)0;
  return_label: 
#line 3232 
                return __retres;
}


#line 3237  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_register_2_3(struct platform_driver *arg0)
{
  int ret;
  struct ldv_struct_platform_instance_17 *cf_arg_17;
  int tmp;
  
#line 3240 
  tmp = ldv_undef_int();
  
#line 3240 
  switch (tmp) {
    case 0: 
#line 3241 
    ;
    
#line 3242 
    cf_arg_17 = (struct ldv_struct_platform_instance_17 *)ldv_xmalloc(16UL);
    
#line 3243 
    cf_arg_17->arg0 = arg0;
    
#line 3244 
    ret = pthread_create(& ldv_thread_17,(pthread_attr_t const *)0,& ldv_platform_instance_17,(void *)cf_arg_17);
    
#line 3245 
    __VERIFIER_assume(ret == 0);
    
#line 3246 
    goto ldv_30569;
    default: 
#line 3248 
    ;
    
#line 3248 
    __VERIFIER_assume(0);
  }
  ldv_30569: 
#line 3249 
  ;
  
#line 3250 
  return;
}


#line 3254  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_73(void *arg0)
{
  void *__retres;
  struct file *ldv_73_resource_1;
  int ldv_73_ldv_param_2_3;
  long long ldv_73_ldv_param_1_2;
  char *ldv_73_ldv_param_1_4;
  struct inode *ldv_73_resource_0;
  unsigned long ldv_73_size_cnt;
  long long *ldv_73_ldv_param_3_5;
  char *ldv_73_ldv_param_1_6;
  long long *ldv_73_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 3265 
  struct file_operations *ldv_73_container = ldv_emg_alias_isr_rx_procs_ops_2;
  
#line 3266 
  int ldv_73_ret = ldv_undef_int();
  
#line 3269 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 3273 
  ldv_73_ret = ldv_undef_int();
  
#line 3276 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 3277 
    ldv_73_container = data->arg0;
    
#line 3278 
    ldv_free((void *)data);
  }
  else ;
  
#line 3283 
  ldv_73_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 3284 
  tmp_1 = ldv_undef_int();
  
#line 3284 
  ldv_73_size_cnt = (unsigned long)tmp_1;
  
#line 3291 
  goto ldv_main_73;
  
#line 3293 
  __retres = (void *)0;
  
#line 3293 
  goto return_label;
  ldv_main_73: 
#line 3296 
  ;
  
#line 3299 
  tmp_3 = ldv_undef_int();
  
#line 3299 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 3302 
    ldv_73_ret = (*ldv_emg_alias_simple_open_5)(ldv_73_resource_0,ldv_73_resource_1);
    
#line 3304 
    ldv_73_ret = ldv_filter_err_code(ldv_73_ret);
    
#line 3307 
    tmp_2 = ldv_undef_int();
    
#line 3307 
    if (tmp_2 != 0) {
      
#line 3309 
      __VERIFIER_assume(ldv_73_ret == 0);
      
#line 3316 
      goto ldv_call_73;
    }
    else {
      
#line 3320 
      __VERIFIER_assume(ldv_73_ret != 0);
      
#line 3327 
      goto ldv_main_73;
    }
  }
  else {
    
#line 3332 
    ldv_free((void *)ldv_73_resource_0);
    
#line 3340 
    __retres = (void *)0;
    
#line 3340 
    goto return_label;
  }
  
#line 3343 
  __retres = (void *)0;
  
#line 3343 
  goto return_label;
  ldv_call_73: 
#line 3346 
  ;
  
#line 3349 
  tmp_4 = ldv_undef_int();
  
#line 3349 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 3350 
    ;
    
#line 3352 
    ldv_73_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 3353 
    ldv_73_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 3357 
    if (ldv_73_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 3363 
      __VERIFIER_assume(ldv_73_size_cnt <= 2147479552UL);
      
#line 3365 
      (*(ldv_73_container->write))(ldv_73_resource_1,(char const *)ldv_73_ldv_param_1_6,ldv_73_size_cnt,ldv_73_ldv_param_3_7);
    }
    else ;
    
#line 3370 
    ldv_free((void *)ldv_73_ldv_param_3_7);
    
#line 3371 
    ldv_free((void *)ldv_73_ldv_param_1_6);
    
#line 3378 
    goto ldv_call_73;
    case 2: 
#line 3381 
    ;
    
#line 3383 
    if (ldv_73_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 3385 
      (*(ldv_73_container->release))(ldv_73_resource_0,ldv_73_resource_1); else ;
    
#line 3393 
    goto ldv_main_73;
    case 3: 
#line 3396 
    ;
    
#line 3400 
    tmp_9 = ldv_undef_int();
    
#line 3400 
    if (tmp_9 != 0) 
#line 3403 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_73_resource_1,ldv_73_ldv_param_1_2,ldv_73_ldv_param_2_3);
    else {
      
#line 3409 
      ldv_73_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 3410 
      ldv_73_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 3415 
      ldv_emg_wrapper_isr_rx_procs_read_3(ldv_73_resource_1,ldv_73_ldv_param_1_4,ldv_73_size_cnt,ldv_73_ldv_param_3_5);
      
#line 3419 
      ldv_free((void *)ldv_73_ldv_param_3_5);
      
#line 3420 
      ldv_free((void *)ldv_73_ldv_param_1_4);
    }
    
#line 3424 
    goto ldv_30591;
    default: 
#line 3426 
    ;
    
#line 3426 
    __VERIFIER_assume(0);
  }
  ldv_30591: 
#line 3435 
  ;
  
#line 3435 
  goto ldv_call_73;
  
#line 3437 
  __retres = (void *)0;
  return_label: 
#line 3437 
                return __retres;
}


#line 3442  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_67(void *arg0)
{
  void *__retres;
  struct file *ldv_67_resource_1;
  int ldv_67_ldv_param_2_3;
  long long ldv_67_ldv_param_1_2;
  char *ldv_67_ldv_param_1_4;
  struct inode *ldv_67_resource_0;
  unsigned long ldv_67_size_cnt;
  long long *ldv_67_ldv_param_3_5;
  char *ldv_67_ldv_param_1_6;
  long long *ldv_67_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 3453 
  struct file_operations *ldv_67_container = ldv_emg_alias_pwr_ps_enter_ops_2;
  
#line 3454 
  int ldv_67_ret = ldv_undef_int();
  
#line 3457 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 3461 
  ldv_67_ret = ldv_undef_int();
  
#line 3464 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 3465 
    ldv_67_container = data->arg0;
    
#line 3466 
    ldv_free((void *)data);
  }
  else ;
  
#line 3471 
  ldv_67_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 3472 
  tmp_1 = ldv_undef_int();
  
#line 3472 
  ldv_67_size_cnt = (unsigned long)tmp_1;
  
#line 3479 
  goto ldv_main_67;
  
#line 3481 
  __retres = (void *)0;
  
#line 3481 
  goto return_label;
  ldv_main_67: 
#line 3484 
  ;
  
#line 3487 
  tmp_3 = ldv_undef_int();
  
#line 3487 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 3490 
    ldv_67_ret = (*ldv_emg_alias_simple_open_5)(ldv_67_resource_0,ldv_67_resource_1);
    
#line 3492 
    ldv_67_ret = ldv_filter_err_code(ldv_67_ret);
    
#line 3495 
    tmp_2 = ldv_undef_int();
    
#line 3495 
    if (tmp_2 != 0) {
      
#line 3497 
      __VERIFIER_assume(ldv_67_ret == 0);
      
#line 3504 
      goto ldv_call_67;
    }
    else {
      
#line 3508 
      __VERIFIER_assume(ldv_67_ret != 0);
      
#line 3515 
      goto ldv_main_67;
    }
  }
  else {
    
#line 3520 
    ldv_free((void *)ldv_67_resource_0);
    
#line 3528 
    __retres = (void *)0;
    
#line 3528 
    goto return_label;
  }
  
#line 3531 
  __retres = (void *)0;
  
#line 3531 
  goto return_label;
  ldv_call_67: 
#line 3534 
  ;
  
#line 3537 
  tmp_4 = ldv_undef_int();
  
#line 3537 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 3538 
    ;
    
#line 3540 
    ldv_67_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 3541 
    ldv_67_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 3545 
    if (ldv_67_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 3551 
      __VERIFIER_assume(ldv_67_size_cnt <= 2147479552UL);
      
#line 3553 
      (*(ldv_67_container->write))(ldv_67_resource_1,(char const *)ldv_67_ldv_param_1_6,ldv_67_size_cnt,ldv_67_ldv_param_3_7);
    }
    else ;
    
#line 3558 
    ldv_free((void *)ldv_67_ldv_param_1_6);
    
#line 3559 
    ldv_free((void *)ldv_67_ldv_param_3_7);
    
#line 3566 
    goto ldv_call_67;
    case 2: 
#line 3569 
    ;
    
#line 3571 
    if (ldv_67_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 3573 
      (*(ldv_67_container->release))(ldv_67_resource_0,ldv_67_resource_1); else ;
    
#line 3581 
    goto ldv_main_67;
    case 3: 
#line 3584 
    ;
    
#line 3588 
    tmp_9 = ldv_undef_int();
    
#line 3588 
    if (tmp_9 != 0) 
#line 3591 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_67_resource_1,ldv_67_ldv_param_1_2,ldv_67_ldv_param_2_3);
    else {
      
#line 3597 
      ldv_67_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 3598 
      ldv_67_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 3603 
      ldv_emg_wrapper_pwr_ps_enter_read_3(ldv_67_resource_1,ldv_67_ldv_param_1_4,ldv_67_size_cnt,ldv_67_ldv_param_3_5);
      
#line 3607 
      ldv_free((void *)ldv_67_ldv_param_3_5);
      
#line 3608 
      ldv_free((void *)ldv_67_ldv_param_1_4);
    }
    
#line 3612 
    goto ldv_30613;
    default: 
#line 3614 
    ;
    
#line 3614 
    __VERIFIER_assume(0);
  }
  ldv_30613: 
#line 3623 
  ;
  
#line 3623 
  goto ldv_call_67;
  
#line 3625 
  __retres = (void *)0;
  return_label: 
#line 3625 
                return __retres;
}


#line 3630  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
int ldv_emg___platform_driver_register(struct platform_driver *arg0, struct module *arg1)
{
  int __retres;
  int tmp_0;
  
#line 3633 
  struct platform_driver *ldv_2_platform_driver = ldv_emg_alias_wl12xx_driver_2;
  
#line 3637 
  tmp_0 = ldv_undef_int();
  
#line 3637 
  if (tmp_0 != 0) {
    
#line 3639 
    ldv_2_platform_driver = arg0;
    
#line 3643 
    ldv_dispatch_register_2_3(ldv_2_platform_driver);
    
#line 3647 
    __retres = 0;
    
#line 3647 
    goto return_label;
  }
  else {
    int tmp;
    
#line 3654 
    tmp = ldv_undef_int_negative();
    
#line 3654 
    __retres = tmp;
    
#line 3654 
    goto return_label;
  }
  return_label: 
#line 3637 
                return __retres;
}


#line 3664  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_53(void *arg0)
{
  void *__retres;
  struct file *ldv_53_resource_1;
  int ldv_53_ldv_param_2_3;
  long long ldv_53_ldv_param_1_2;
  char *ldv_53_ldv_param_1_4;
  struct inode *ldv_53_resource_0;
  unsigned long ldv_53_size_cnt;
  long long *ldv_53_ldv_param_3_5;
  char *ldv_53_ldv_param_1_6;
  long long *ldv_53_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 3675 
  struct file_operations *ldv_53_container = ldv_emg_alias_event_rx_mem_empty_ops_2;
  
#line 3676 
  int ldv_53_ret = ldv_undef_int();
  
#line 3679 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 3683 
  ldv_53_ret = ldv_undef_int();
  
#line 3686 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 3687 
    ldv_53_container = data->arg0;
    
#line 3688 
    ldv_free((void *)data);
  }
  else ;
  
#line 3693 
  ldv_53_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 3694 
  tmp_1 = ldv_undef_int();
  
#line 3694 
  ldv_53_size_cnt = (unsigned long)tmp_1;
  
#line 3701 
  goto ldv_main_53;
  
#line 3703 
  __retres = (void *)0;
  
#line 3703 
  goto return_label;
  ldv_main_53: 
#line 3706 
  ;
  
#line 3709 
  tmp_3 = ldv_undef_int();
  
#line 3709 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 3712 
    ldv_53_ret = (*ldv_emg_alias_simple_open_5)(ldv_53_resource_0,ldv_53_resource_1);
    
#line 3714 
    ldv_53_ret = ldv_filter_err_code(ldv_53_ret);
    
#line 3717 
    tmp_2 = ldv_undef_int();
    
#line 3717 
    if (tmp_2 != 0) {
      
#line 3719 
      __VERIFIER_assume(ldv_53_ret == 0);
      
#line 3726 
      goto ldv_call_53;
    }
    else {
      
#line 3730 
      __VERIFIER_assume(ldv_53_ret != 0);
      
#line 3737 
      goto ldv_main_53;
    }
  }
  else {
    
#line 3742 
    ldv_free((void *)ldv_53_resource_0);
    
#line 3750 
    __retres = (void *)0;
    
#line 3750 
    goto return_label;
  }
  
#line 3753 
  __retres = (void *)0;
  
#line 3753 
  goto return_label;
  ldv_call_53: 
#line 3756 
  ;
  
#line 3759 
  tmp_4 = ldv_undef_int();
  
#line 3759 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 3760 
    ;
    
#line 3762 
    ldv_53_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 3763 
    ldv_53_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 3767 
    if (ldv_53_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 3773 
      __VERIFIER_assume(ldv_53_size_cnt <= 2147479552UL);
      
#line 3775 
      (*(ldv_53_container->write))(ldv_53_resource_1,(char const *)ldv_53_ldv_param_1_6,ldv_53_size_cnt,ldv_53_ldv_param_3_7);
    }
    else ;
    
#line 3780 
    ldv_free((void *)ldv_53_ldv_param_1_6);
    
#line 3781 
    ldv_free((void *)ldv_53_ldv_param_3_7);
    
#line 3788 
    goto ldv_call_53;
    case 2: 
#line 3791 
    ;
    
#line 3793 
    if (ldv_53_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 3795 
      (*(ldv_53_container->release))(ldv_53_resource_0,ldv_53_resource_1); else ;
    
#line 3803 
    goto ldv_main_53;
    case 3: 
#line 3806 
    ;
    
#line 3810 
    tmp_9 = ldv_undef_int();
    
#line 3810 
    if (tmp_9 != 0) 
#line 3813 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_53_resource_1,ldv_53_ldv_param_1_2,ldv_53_ldv_param_2_3);
    else {
      
#line 3819 
      ldv_53_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 3820 
      ldv_53_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 3825 
      ldv_emg_wrapper_event_rx_mem_empty_read_3(ldv_53_resource_1,ldv_53_ldv_param_1_4,ldv_53_size_cnt,ldv_53_ldv_param_3_5);
      
#line 3829 
      ldv_free((void *)ldv_53_ldv_param_3_5);
      
#line 3830 
      ldv_free((void *)ldv_53_ldv_param_1_4);
    }
    
#line 3834 
    goto ldv_30640;
    default: 
#line 3836 
    ;
    
#line 3836 
    __VERIFIER_assume(0);
  }
  ldv_30640: 
#line 3845 
  ;
  
#line 3845 
  goto ldv_call_53;
  
#line 3847 
  __retres = (void *)0;
  return_label: 
#line 3847 
                return __retres;
}


#line 3852  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_register_4_3(struct file_operations *arg0)
{
  int ret;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_5;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_6;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_7;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_8;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_9;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_10;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_11;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_12;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_13;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_14;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_15;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_16;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_18;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_19;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_20;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_21;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_22;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_23;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_24;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_25;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_26;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_27;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_28;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_29;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_30;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_31;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_32;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_33;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_35;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_36;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_37;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_38;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_39;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_40;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_41;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_42;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_43;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_44;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_45;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_46;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_47;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_48;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_49;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_50;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_51;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_52;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_53;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_54;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_55;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_56;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_57;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_58;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_59;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_60;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_61;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_62;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_63;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_64;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_65;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_66;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_67;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_68;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_69;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_70;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_71;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_72;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_73;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_74;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_75;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_76;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_77;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_78;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_79;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_80;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_81;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_82;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_83;
  struct ldv_struct_character_driver_scenario_5 *cf_arg_84;
  int tmp;
  
#line 3932 
  tmp = ldv_undef_int();
  
#line 3932 
  switch (tmp) {
    case 0: 
#line 3933 
    ;
    
#line 3934 
    cf_arg_5 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 3935 
    cf_arg_5->arg0 = arg0;
    
#line 3936 
    ret = pthread_create(& ldv_thread_5,(pthread_attr_t const *)0,& ldv_character_driver_scenario_5,(void *)cf_arg_5);
    
#line 3937 
    __VERIFIER_assume(ret == 0);
    
#line 3938 
    goto ldv_30725;
    case 1: 
#line 3940 
    ;
    
#line 3941 
    cf_arg_6 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 3942 
    cf_arg_6->arg0 = arg0;
    
#line 3943 
    ret = pthread_create(& ldv_thread_6,(pthread_attr_t const *)0,& ldv_character_driver_scenario_6,(void *)cf_arg_6);
    
#line 3944 
    __VERIFIER_assume(ret == 0);
    
#line 3945 
    goto ldv_30725;
    case 2: 
#line 3947 
    ;
    
#line 3948 
    cf_arg_7 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 3949 
    cf_arg_7->arg0 = arg0;
    
#line 3950 
    ret = pthread_create(& ldv_thread_7,(pthread_attr_t const *)0,& ldv_character_driver_scenario_7,(void *)cf_arg_7);
    
#line 3951 
    __VERIFIER_assume(ret == 0);
    
#line 3952 
    goto ldv_30725;
    case 3: 
#line 3954 
    ;
    
#line 3955 
    cf_arg_8 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 3956 
    cf_arg_8->arg0 = arg0;
    
#line 3957 
    ret = pthread_create(& ldv_thread_8,(pthread_attr_t const *)0,& ldv_character_driver_scenario_8,(void *)cf_arg_8);
    
#line 3958 
    __VERIFIER_assume(ret == 0);
    
#line 3959 
    goto ldv_30725;
    case 4: 
#line 3961 
    ;
    
#line 3962 
    cf_arg_9 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 3963 
    cf_arg_9->arg0 = arg0;
    
#line 3964 
    ret = pthread_create(& ldv_thread_9,(pthread_attr_t const *)0,& ldv_character_driver_scenario_9,(void *)cf_arg_9);
    
#line 3965 
    __VERIFIER_assume(ret == 0);
    
#line 3966 
    goto ldv_30725;
    case 5: 
#line 3968 
    ;
    
#line 3969 
    cf_arg_10 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 3970 
    cf_arg_10->arg0 = arg0;
    
#line 3971 
    ret = pthread_create(& ldv_thread_10,(pthread_attr_t const *)0,& ldv_character_driver_scenario_10,(void *)cf_arg_10);
    
#line 3972 
    __VERIFIER_assume(ret == 0);
    
#line 3973 
    goto ldv_30725;
    case 6: 
#line 3975 
    ;
    
#line 3976 
    cf_arg_11 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 3977 
    cf_arg_11->arg0 = arg0;
    
#line 3978 
    ret = pthread_create(& ldv_thread_11,(pthread_attr_t const *)0,& ldv_character_driver_scenario_11,(void *)cf_arg_11);
    
#line 3979 
    __VERIFIER_assume(ret == 0);
    
#line 3980 
    goto ldv_30725;
    case 7: 
#line 3982 
    ;
    
#line 3983 
    cf_arg_12 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 3984 
    cf_arg_12->arg0 = arg0;
    
#line 3985 
    ret = pthread_create(& ldv_thread_12,(pthread_attr_t const *)0,& ldv_character_driver_scenario_12,(void *)cf_arg_12);
    
#line 3986 
    __VERIFIER_assume(ret == 0);
    
#line 3987 
    goto ldv_30725;
    case 8: 
#line 3989 
    ;
    
#line 3990 
    cf_arg_13 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 3991 
    cf_arg_13->arg0 = arg0;
    
#line 3992 
    ret = pthread_create(& ldv_thread_13,(pthread_attr_t const *)0,& ldv_character_driver_scenario_13,(void *)cf_arg_13);
    
#line 3993 
    __VERIFIER_assume(ret == 0);
    
#line 3994 
    goto ldv_30725;
    case 9: 
#line 3996 
    ;
    
#line 3997 
    cf_arg_14 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 3998 
    cf_arg_14->arg0 = arg0;
    
#line 3999 
    ret = pthread_create(& ldv_thread_14,(pthread_attr_t const *)0,& ldv_character_driver_scenario_14,(void *)cf_arg_14);
    
#line 4000 
    __VERIFIER_assume(ret == 0);
    
#line 4001 
    goto ldv_30725;
    case 10: 
#line 4003 
    ;
    
#line 4004 
    cf_arg_15 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 4005 
    cf_arg_15->arg0 = arg0;
    
#line 4006 
    ret = pthread_create(& ldv_thread_15,(pthread_attr_t const *)0,& ldv_character_driver_scenario_15,(void *)cf_arg_15);
    
#line 4007 
    __VERIFIER_assume(ret == 0);
    
#line 4008 
    goto ldv_30725;
    case 11: 
#line 4010 
    ;
    
#line 4011 
    cf_arg_16 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 4012 
    cf_arg_16->arg0 = arg0;
    
#line 4013 
    ret = pthread_create(& ldv_thread_16,(pthread_attr_t const *)0,& ldv_character_driver_scenario_16,(void *)cf_arg_16);
    
#line 4014 
    __VERIFIER_assume(ret == 0);
    
#line 4015 
    goto ldv_30725;
    case 12: 
#line 4017 
    ;
    
#line 4018 
    cf_arg_18 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 4019 
    cf_arg_18->arg0 = arg0;
    
#line 4020 
    ret = pthread_create(& ldv_thread_18,(pthread_attr_t const *)0,& ldv_character_driver_scenario_18,(void *)cf_arg_18);
    
#line 4021 
    __VERIFIER_assume(ret == 0);
    
#line 4022 
    goto ldv_30725;
    case 13: 
#line 4024 
    ;
    
#line 4025 
    cf_arg_19 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 4026 
    cf_arg_19->arg0 = arg0;
    
#line 4027 
    ret = pthread_create(& ldv_thread_19,(pthread_attr_t const *)0,& ldv_character_driver_scenario_19,(void *)cf_arg_19);
    
#line 4028 
    __VERIFIER_assume(ret == 0);
    
#line 4029 
    goto ldv_30725;
    case 14: 
#line 4031 
    ;
    
#line 4032 
    cf_arg_20 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 4033 
    cf_arg_20->arg0 = arg0;
    
#line 4034 
    ret = pthread_create(& ldv_thread_20,(pthread_attr_t const *)0,& ldv_character_driver_scenario_20,(void *)cf_arg_20);
    
#line 4035 
    __VERIFIER_assume(ret == 0);
    
#line 4036 
    goto ldv_30725;
    case 15: 
#line 4038 
    ;
    
#line 4039 
    cf_arg_21 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 4040 
    cf_arg_21->arg0 = arg0;
    
#line 4041 
    ret = pthread_create(& ldv_thread_21,(pthread_attr_t const *)0,& ldv_character_driver_scenario_21,(void *)cf_arg_21);
    
#line 4042 
    __VERIFIER_assume(ret == 0);
    
#line 4043 
    goto ldv_30725;
    case 16: 
#line 4045 
    ;
    
#line 4046 
    cf_arg_22 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 4047 
    cf_arg_22->arg0 = arg0;
    
#line 4048 
    ret = pthread_create(& ldv_thread_22,(pthread_attr_t const *)0,& ldv_character_driver_scenario_22,(void *)cf_arg_22);
    
#line 4049 
    __VERIFIER_assume(ret == 0);
    
#line 4050 
    goto ldv_30725;
    case 17: 
#line 4052 
    ;
    
#line 4053 
    cf_arg_23 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 4054 
    cf_arg_23->arg0 = arg0;
    
#line 4055 
    ret = pthread_create(& ldv_thread_23,(pthread_attr_t const *)0,& ldv_character_driver_scenario_23,(void *)cf_arg_23);
    
#line 4056 
    __VERIFIER_assume(ret == 0);
    
#line 4057 
    goto ldv_30725;
    case 18: 
#line 4059 
    ;
    
#line 4060 
    cf_arg_24 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 4061 
    cf_arg_24->arg0 = arg0;
    
#line 4062 
    ret = pthread_create(& ldv_thread_24,(pthread_attr_t const *)0,& ldv_character_driver_scenario_24,(void *)cf_arg_24);
    
#line 4063 
    __VERIFIER_assume(ret == 0);
    
#line 4064 
    goto ldv_30725;
    case 19: 
#line 4066 
    ;
    
#line 4067 
    cf_arg_25 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 4068 
    cf_arg_25->arg0 = arg0;
    
#line 4069 
    ret = pthread_create(& ldv_thread_25,(pthread_attr_t const *)0,& ldv_character_driver_scenario_25,(void *)cf_arg_25);
    
#line 4070 
    __VERIFIER_assume(ret == 0);
    
#line 4071 
    goto ldv_30725;
    case 20: 
#line 4073 
    ;
    
#line 4074 
    cf_arg_26 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 4075 
    cf_arg_26->arg0 = arg0;
    
#line 4076 
    ret = pthread_create(& ldv_thread_26,(pthread_attr_t const *)0,& ldv_character_driver_scenario_26,(void *)cf_arg_26);
    
#line 4077 
    __VERIFIER_assume(ret == 0);
    
#line 4078 
    goto ldv_30725;
    case 21: 
#line 4080 
    ;
    
#line 4081 
    cf_arg_27 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 4082 
    cf_arg_27->arg0 = arg0;
    
#line 4083 
    ret = pthread_create(& ldv_thread_27,(pthread_attr_t const *)0,& ldv_character_driver_scenario_27,(void *)cf_arg_27);
    
#line 4084 
    __VERIFIER_assume(ret == 0);
    
#line 4085 
    goto ldv_30725;
    case 22: 
#line 4087 
    ;
    
#line 4088 
    cf_arg_28 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 4089 
    cf_arg_28->arg0 = arg0;
    
#line 4090 
    ret = pthread_create(& ldv_thread_28,(pthread_attr_t const *)0,& ldv_character_driver_scenario_28,(void *)cf_arg_28);
    
#line 4091 
    __VERIFIER_assume(ret == 0);
    
#line 4092 
    goto ldv_30725;
    case 23: 
#line 4094 
    ;
    
#line 4095 
    cf_arg_29 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 4096 
    cf_arg_29->arg0 = arg0;
    
#line 4097 
    ret = pthread_create(& ldv_thread_29,(pthread_attr_t const *)0,& ldv_character_driver_scenario_29,(void *)cf_arg_29);
    
#line 4098 
    __VERIFIER_assume(ret == 0);
    
#line 4099 
    goto ldv_30725;
    case 24: 
#line 4101 
    ;
    
#line 4102 
    cf_arg_30 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 4103 
    cf_arg_30->arg0 = arg0;
    
#line 4104 
    ret = pthread_create(& ldv_thread_30,(pthread_attr_t const *)0,& ldv_character_driver_scenario_30,(void *)cf_arg_30);
    
#line 4105 
    __VERIFIER_assume(ret == 0);
    
#line 4106 
    goto ldv_30725;
    case 25: 
#line 4108 
    ;
    
#line 4109 
    cf_arg_31 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 4110 
    cf_arg_31->arg0 = arg0;
    
#line 4111 
    ret = pthread_create(& ldv_thread_31,(pthread_attr_t const *)0,& ldv_character_driver_scenario_31,(void *)cf_arg_31);
    
#line 4112 
    __VERIFIER_assume(ret == 0);
    
#line 4113 
    goto ldv_30725;
    case 26: 
#line 4115 
    ;
    
#line 4116 
    cf_arg_32 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 4117 
    cf_arg_32->arg0 = arg0;
    
#line 4118 
    ret = pthread_create(& ldv_thread_32,(pthread_attr_t const *)0,& ldv_character_driver_scenario_32,(void *)cf_arg_32);
    
#line 4119 
    __VERIFIER_assume(ret == 0);
    
#line 4120 
    goto ldv_30725;
    case 27: 
#line 4122 
    ;
    
#line 4123 
    cf_arg_33 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 4124 
    cf_arg_33->arg0 = arg0;
    
#line 4125 
    ret = pthread_create(& ldv_thread_33,(pthread_attr_t const *)0,& ldv_character_driver_scenario_33,(void *)cf_arg_33);
    
#line 4126 
    __VERIFIER_assume(ret == 0);
    
#line 4127 
    goto ldv_30725;
    case 28: 
#line 4129 
    ;
    
#line 4130 
    cf_arg_35 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 4131 
    cf_arg_35->arg0 = arg0;
    
#line 4132 
    ret = pthread_create(& ldv_thread_35,(pthread_attr_t const *)0,& ldv_character_driver_scenario_35,(void *)cf_arg_35);
    
#line 4133 
    __VERIFIER_assume(ret == 0);
    
#line 4134 
    goto ldv_30725;
    case 29: 
#line 4136 
    ;
    
#line 4137 
    cf_arg_36 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 4138 
    cf_arg_36->arg0 = arg0;
    
#line 4139 
    ret = pthread_create(& ldv_thread_36,(pthread_attr_t const *)0,& ldv_character_driver_scenario_36,(void *)cf_arg_36);
    
#line 4140 
    __VERIFIER_assume(ret == 0);
    
#line 4141 
    goto ldv_30725;
    case 30: 
#line 4143 
    ;
    
#line 4144 
    cf_arg_37 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 4145 
    cf_arg_37->arg0 = arg0;
    
#line 4146 
    ret = pthread_create(& ldv_thread_37,(pthread_attr_t const *)0,& ldv_character_driver_scenario_37,(void *)cf_arg_37);
    
#line 4147 
    __VERIFIER_assume(ret == 0);
    
#line 4148 
    goto ldv_30725;
    case 31: 
#line 4150 
    ;
    
#line 4151 
    cf_arg_38 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 4152 
    cf_arg_38->arg0 = arg0;
    
#line 4153 
    ret = pthread_create(& ldv_thread_38,(pthread_attr_t const *)0,& ldv_character_driver_scenario_38,(void *)cf_arg_38);
    
#line 4154 
    __VERIFIER_assume(ret == 0);
    
#line 4155 
    goto ldv_30725;
    case 32: 
#line 4157 
    ;
    
#line 4158 
    cf_arg_39 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 4159 
    cf_arg_39->arg0 = arg0;
    
#line 4160 
    ret = pthread_create(& ldv_thread_39,(pthread_attr_t const *)0,& ldv_character_driver_scenario_39,(void *)cf_arg_39);
    
#line 4161 
    __VERIFIER_assume(ret == 0);
    
#line 4162 
    goto ldv_30725;
    case 33: 
#line 4164 
    ;
    
#line 4165 
    cf_arg_40 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 4166 
    cf_arg_40->arg0 = arg0;
    
#line 4167 
    ret = pthread_create(& ldv_thread_40,(pthread_attr_t const *)0,& ldv_character_driver_scenario_40,(void *)cf_arg_40);
    
#line 4168 
    __VERIFIER_assume(ret == 0);
    
#line 4169 
    goto ldv_30725;
    case 34: 
#line 4171 
    ;
    
#line 4172 
    cf_arg_41 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 4173 
    cf_arg_41->arg0 = arg0;
    
#line 4174 
    ret = pthread_create(& ldv_thread_41,(pthread_attr_t const *)0,& ldv_character_driver_scenario_41,(void *)cf_arg_41);
    
#line 4175 
    __VERIFIER_assume(ret == 0);
    
#line 4176 
    goto ldv_30725;
    case 35: 
#line 4178 
    ;
    
#line 4179 
    cf_arg_42 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 4180 
    cf_arg_42->arg0 = arg0;
    
#line 4181 
    ret = pthread_create(& ldv_thread_42,(pthread_attr_t const *)0,& ldv_character_driver_scenario_42,(void *)cf_arg_42);
    
#line 4182 
    __VERIFIER_assume(ret == 0);
    
#line 4183 
    goto ldv_30725;
    case 36: 
#line 4185 
    ;
    
#line 4186 
    cf_arg_43 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 4187 
    cf_arg_43->arg0 = arg0;
    
#line 4188 
    ret = pthread_create(& ldv_thread_43,(pthread_attr_t const *)0,& ldv_character_driver_scenario_43,(void *)cf_arg_43);
    
#line 4189 
    __VERIFIER_assume(ret == 0);
    
#line 4190 
    goto ldv_30725;
    case 37: 
#line 4192 
    ;
    
#line 4193 
    cf_arg_44 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 4194 
    cf_arg_44->arg0 = arg0;
    
#line 4195 
    ret = pthread_create(& ldv_thread_44,(pthread_attr_t const *)0,& ldv_character_driver_scenario_44,(void *)cf_arg_44);
    
#line 4196 
    __VERIFIER_assume(ret == 0);
    
#line 4197 
    goto ldv_30725;
    case 38: 
#line 4199 
    ;
    
#line 4200 
    cf_arg_45 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 4201 
    cf_arg_45->arg0 = arg0;
    
#line 4202 
    ret = pthread_create(& ldv_thread_45,(pthread_attr_t const *)0,& ldv_character_driver_scenario_45,(void *)cf_arg_45);
    
#line 4203 
    __VERIFIER_assume(ret == 0);
    
#line 4204 
    goto ldv_30725;
    case 39: 
#line 4206 
    ;
    
#line 4207 
    cf_arg_46 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 4208 
    cf_arg_46->arg0 = arg0;
    
#line 4209 
    ret = pthread_create(& ldv_thread_46,(pthread_attr_t const *)0,& ldv_character_driver_scenario_46,(void *)cf_arg_46);
    
#line 4210 
    __VERIFIER_assume(ret == 0);
    
#line 4211 
    goto ldv_30725;
    case 40: 
#line 4213 
    ;
    
#line 4214 
    cf_arg_47 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 4215 
    cf_arg_47->arg0 = arg0;
    
#line 4216 
    ret = pthread_create(& ldv_thread_47,(pthread_attr_t const *)0,& ldv_character_driver_scenario_47,(void *)cf_arg_47);
    
#line 4217 
    __VERIFIER_assume(ret == 0);
    
#line 4218 
    goto ldv_30725;
    case 41: 
#line 4220 
    ;
    
#line 4221 
    cf_arg_48 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 4222 
    cf_arg_48->arg0 = arg0;
    
#line 4223 
    ret = pthread_create(& ldv_thread_48,(pthread_attr_t const *)0,& ldv_character_driver_scenario_48,(void *)cf_arg_48);
    
#line 4224 
    __VERIFIER_assume(ret == 0);
    
#line 4225 
    goto ldv_30725;
    case 42: 
#line 4227 
    ;
    
#line 4228 
    cf_arg_49 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 4229 
    cf_arg_49->arg0 = arg0;
    
#line 4230 
    ret = pthread_create(& ldv_thread_49,(pthread_attr_t const *)0,& ldv_character_driver_scenario_49,(void *)cf_arg_49);
    
#line 4231 
    __VERIFIER_assume(ret == 0);
    
#line 4232 
    goto ldv_30725;
    case 43: 
#line 4234 
    ;
    
#line 4235 
    cf_arg_50 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 4236 
    cf_arg_50->arg0 = arg0;
    
#line 4237 
    ret = pthread_create(& ldv_thread_50,(pthread_attr_t const *)0,& ldv_character_driver_scenario_50,(void *)cf_arg_50);
    
#line 4238 
    __VERIFIER_assume(ret == 0);
    
#line 4239 
    goto ldv_30725;
    case 44: 
#line 4241 
    ;
    
#line 4242 
    cf_arg_51 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 4243 
    cf_arg_51->arg0 = arg0;
    
#line 4244 
    ret = pthread_create(& ldv_thread_51,(pthread_attr_t const *)0,& ldv_character_driver_scenario_51,(void *)cf_arg_51);
    
#line 4245 
    __VERIFIER_assume(ret == 0);
    
#line 4246 
    goto ldv_30725;
    case 45: 
#line 4248 
    ;
    
#line 4249 
    cf_arg_52 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 4250 
    cf_arg_52->arg0 = arg0;
    
#line 4251 
    ret = pthread_create(& ldv_thread_52,(pthread_attr_t const *)0,& ldv_character_driver_scenario_52,(void *)cf_arg_52);
    
#line 4252 
    __VERIFIER_assume(ret == 0);
    
#line 4253 
    goto ldv_30725;
    case 46: 
#line 4255 
    ;
    
#line 4256 
    cf_arg_53 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 4257 
    cf_arg_53->arg0 = arg0;
    
#line 4258 
    ret = pthread_create(& ldv_thread_53,(pthread_attr_t const *)0,& ldv_character_driver_scenario_53,(void *)cf_arg_53);
    
#line 4259 
    __VERIFIER_assume(ret == 0);
    
#line 4260 
    goto ldv_30725;
    case 47: 
#line 4262 
    ;
    
#line 4263 
    cf_arg_54 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 4264 
    cf_arg_54->arg0 = arg0;
    
#line 4265 
    ret = pthread_create(& ldv_thread_54,(pthread_attr_t const *)0,& ldv_character_driver_scenario_54,(void *)cf_arg_54);
    
#line 4266 
    __VERIFIER_assume(ret == 0);
    
#line 4267 
    goto ldv_30725;
    case 48: 
#line 4269 
    ;
    
#line 4270 
    cf_arg_55 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 4271 
    cf_arg_55->arg0 = arg0;
    
#line 4272 
    ret = pthread_create(& ldv_thread_55,(pthread_attr_t const *)0,& ldv_character_driver_scenario_55,(void *)cf_arg_55);
    
#line 4273 
    __VERIFIER_assume(ret == 0);
    
#line 4274 
    goto ldv_30725;
    case 49: 
#line 4276 
    ;
    
#line 4277 
    cf_arg_56 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 4278 
    cf_arg_56->arg0 = arg0;
    
#line 4279 
    ret = pthread_create(& ldv_thread_56,(pthread_attr_t const *)0,& ldv_character_driver_scenario_56,(void *)cf_arg_56);
    
#line 4280 
    __VERIFIER_assume(ret == 0);
    
#line 4281 
    goto ldv_30725;
    case 50: 
#line 4283 
    ;
    
#line 4284 
    cf_arg_57 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 4285 
    cf_arg_57->arg0 = arg0;
    
#line 4286 
    ret = pthread_create(& ldv_thread_57,(pthread_attr_t const *)0,& ldv_character_driver_scenario_57,(void *)cf_arg_57);
    
#line 4287 
    __VERIFIER_assume(ret == 0);
    
#line 4288 
    goto ldv_30725;
    case 51: 
#line 4290 
    ;
    
#line 4291 
    cf_arg_58 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 4292 
    cf_arg_58->arg0 = arg0;
    
#line 4293 
    ret = pthread_create(& ldv_thread_58,(pthread_attr_t const *)0,& ldv_character_driver_scenario_58,(void *)cf_arg_58);
    
#line 4294 
    __VERIFIER_assume(ret == 0);
    
#line 4295 
    goto ldv_30725;
    case 52: 
#line 4297 
    ;
    
#line 4298 
    cf_arg_59 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 4299 
    cf_arg_59->arg0 = arg0;
    
#line 4300 
    ret = pthread_create(& ldv_thread_59,(pthread_attr_t const *)0,& ldv_character_driver_scenario_59,(void *)cf_arg_59);
    
#line 4301 
    __VERIFIER_assume(ret == 0);
    
#line 4302 
    goto ldv_30725;
    case 53: 
#line 4304 
    ;
    
#line 4305 
    cf_arg_60 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 4306 
    cf_arg_60->arg0 = arg0;
    
#line 4307 
    ret = pthread_create(& ldv_thread_60,(pthread_attr_t const *)0,& ldv_character_driver_scenario_60,(void *)cf_arg_60);
    
#line 4308 
    __VERIFIER_assume(ret == 0);
    
#line 4309 
    goto ldv_30725;
    case 54: 
#line 4311 
    ;
    
#line 4312 
    cf_arg_61 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 4313 
    cf_arg_61->arg0 = arg0;
    
#line 4314 
    ret = pthread_create(& ldv_thread_61,(pthread_attr_t const *)0,& ldv_character_driver_scenario_61,(void *)cf_arg_61);
    
#line 4315 
    __VERIFIER_assume(ret == 0);
    
#line 4316 
    goto ldv_30725;
    case 55: 
#line 4318 
    ;
    
#line 4319 
    cf_arg_62 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 4320 
    cf_arg_62->arg0 = arg0;
    
#line 4321 
    ret = pthread_create(& ldv_thread_62,(pthread_attr_t const *)0,& ldv_character_driver_scenario_62,(void *)cf_arg_62);
    
#line 4322 
    __VERIFIER_assume(ret == 0);
    
#line 4323 
    goto ldv_30725;
    case 56: 
#line 4325 
    ;
    
#line 4326 
    cf_arg_63 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 4327 
    cf_arg_63->arg0 = arg0;
    
#line 4328 
    ret = pthread_create(& ldv_thread_63,(pthread_attr_t const *)0,& ldv_character_driver_scenario_63,(void *)cf_arg_63);
    
#line 4329 
    __VERIFIER_assume(ret == 0);
    
#line 4330 
    goto ldv_30725;
    case 57: 
#line 4332 
    ;
    
#line 4333 
    cf_arg_64 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 4334 
    cf_arg_64->arg0 = arg0;
    
#line 4335 
    ret = pthread_create(& ldv_thread_64,(pthread_attr_t const *)0,& ldv_character_driver_scenario_64,(void *)cf_arg_64);
    
#line 4336 
    __VERIFIER_assume(ret == 0);
    
#line 4337 
    goto ldv_30725;
    case 58: 
#line 4339 
    ;
    
#line 4340 
    cf_arg_65 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 4341 
    cf_arg_65->arg0 = arg0;
    
#line 4342 
    ret = pthread_create(& ldv_thread_65,(pthread_attr_t const *)0,& ldv_character_driver_scenario_65,(void *)cf_arg_65);
    
#line 4343 
    __VERIFIER_assume(ret == 0);
    
#line 4344 
    goto ldv_30725;
    case 59: 
#line 4346 
    ;
    
#line 4347 
    cf_arg_66 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 4348 
    cf_arg_66->arg0 = arg0;
    
#line 4349 
    ret = pthread_create(& ldv_thread_66,(pthread_attr_t const *)0,& ldv_character_driver_scenario_66,(void *)cf_arg_66);
    
#line 4350 
    __VERIFIER_assume(ret == 0);
    
#line 4351 
    goto ldv_30725;
    case 60: 
#line 4353 
    ;
    
#line 4354 
    cf_arg_67 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 4355 
    cf_arg_67->arg0 = arg0;
    
#line 4356 
    ret = pthread_create(& ldv_thread_67,(pthread_attr_t const *)0,& ldv_character_driver_scenario_67,(void *)cf_arg_67);
    
#line 4357 
    __VERIFIER_assume(ret == 0);
    
#line 4358 
    goto ldv_30725;
    case 61: 
#line 4360 
    ;
    
#line 4361 
    cf_arg_68 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 4362 
    cf_arg_68->arg0 = arg0;
    
#line 4363 
    ret = pthread_create(& ldv_thread_68,(pthread_attr_t const *)0,& ldv_character_driver_scenario_68,(void *)cf_arg_68);
    
#line 4364 
    __VERIFIER_assume(ret == 0);
    
#line 4365 
    goto ldv_30725;
    case 62: 
#line 4367 
    ;
    
#line 4368 
    cf_arg_69 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 4369 
    cf_arg_69->arg0 = arg0;
    
#line 4370 
    ret = pthread_create(& ldv_thread_69,(pthread_attr_t const *)0,& ldv_character_driver_scenario_69,(void *)cf_arg_69);
    
#line 4371 
    __VERIFIER_assume(ret == 0);
    
#line 4372 
    goto ldv_30725;
    case 63: 
#line 4374 
    ;
    
#line 4375 
    cf_arg_70 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 4376 
    cf_arg_70->arg0 = arg0;
    
#line 4377 
    ret = pthread_create(& ldv_thread_70,(pthread_attr_t const *)0,& ldv_character_driver_scenario_70,(void *)cf_arg_70);
    
#line 4378 
    __VERIFIER_assume(ret == 0);
    
#line 4379 
    goto ldv_30725;
    case 64: 
#line 4381 
    ;
    
#line 4382 
    cf_arg_71 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 4383 
    cf_arg_71->arg0 = arg0;
    
#line 4384 
    ret = pthread_create(& ldv_thread_71,(pthread_attr_t const *)0,& ldv_character_driver_scenario_71,(void *)cf_arg_71);
    
#line 4385 
    __VERIFIER_assume(ret == 0);
    
#line 4386 
    goto ldv_30725;
    case 65: 
#line 4388 
    ;
    
#line 4389 
    cf_arg_72 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 4390 
    cf_arg_72->arg0 = arg0;
    
#line 4391 
    ret = pthread_create(& ldv_thread_72,(pthread_attr_t const *)0,& ldv_character_driver_scenario_72,(void *)cf_arg_72);
    
#line 4392 
    __VERIFIER_assume(ret == 0);
    
#line 4393 
    goto ldv_30725;
    case 66: 
#line 4395 
    ;
    
#line 4396 
    cf_arg_73 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 4397 
    cf_arg_73->arg0 = arg0;
    
#line 4398 
    ret = pthread_create(& ldv_thread_73,(pthread_attr_t const *)0,& ldv_character_driver_scenario_73,(void *)cf_arg_73);
    
#line 4399 
    __VERIFIER_assume(ret == 0);
    
#line 4400 
    goto ldv_30725;
    case 67: 
#line 4402 
    ;
    
#line 4403 
    cf_arg_74 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 4404 
    cf_arg_74->arg0 = arg0;
    
#line 4405 
    ret = pthread_create(& ldv_thread_74,(pthread_attr_t const *)0,& ldv_character_driver_scenario_74,(void *)cf_arg_74);
    
#line 4406 
    __VERIFIER_assume(ret == 0);
    
#line 4407 
    goto ldv_30725;
    case 68: 
#line 4409 
    ;
    
#line 4410 
    cf_arg_75 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 4411 
    cf_arg_75->arg0 = arg0;
    
#line 4412 
    ret = pthread_create(& ldv_thread_75,(pthread_attr_t const *)0,& ldv_character_driver_scenario_75,(void *)cf_arg_75);
    
#line 4413 
    __VERIFIER_assume(ret == 0);
    
#line 4414 
    goto ldv_30725;
    case 69: 
#line 4416 
    ;
    
#line 4417 
    cf_arg_76 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 4418 
    cf_arg_76->arg0 = arg0;
    
#line 4419 
    ret = pthread_create(& ldv_thread_76,(pthread_attr_t const *)0,& ldv_character_driver_scenario_76,(void *)cf_arg_76);
    
#line 4420 
    __VERIFIER_assume(ret == 0);
    
#line 4421 
    goto ldv_30725;
    case 70: 
#line 4423 
    ;
    
#line 4424 
    cf_arg_77 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 4425 
    cf_arg_77->arg0 = arg0;
    
#line 4426 
    ret = pthread_create(& ldv_thread_77,(pthread_attr_t const *)0,& ldv_character_driver_scenario_77,(void *)cf_arg_77);
    
#line 4427 
    __VERIFIER_assume(ret == 0);
    
#line 4428 
    goto ldv_30725;
    case 71: 
#line 4430 
    ;
    
#line 4431 
    cf_arg_78 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 4432 
    cf_arg_78->arg0 = arg0;
    
#line 4433 
    ret = pthread_create(& ldv_thread_78,(pthread_attr_t const *)0,& ldv_character_driver_scenario_78,(void *)cf_arg_78);
    
#line 4434 
    __VERIFIER_assume(ret == 0);
    
#line 4435 
    goto ldv_30725;
    case 72: 
#line 4437 
    ;
    
#line 4438 
    cf_arg_79 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 4439 
    cf_arg_79->arg0 = arg0;
    
#line 4440 
    ret = pthread_create(& ldv_thread_79,(pthread_attr_t const *)0,& ldv_character_driver_scenario_79,(void *)cf_arg_79);
    
#line 4441 
    __VERIFIER_assume(ret == 0);
    
#line 4442 
    goto ldv_30725;
    case 73: 
#line 4444 
    ;
    
#line 4445 
    cf_arg_80 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 4446 
    cf_arg_80->arg0 = arg0;
    
#line 4447 
    ret = pthread_create(& ldv_thread_80,(pthread_attr_t const *)0,& ldv_character_driver_scenario_80,(void *)cf_arg_80);
    
#line 4448 
    __VERIFIER_assume(ret == 0);
    
#line 4449 
    goto ldv_30725;
    case 74: 
#line 4451 
    ;
    
#line 4452 
    cf_arg_81 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 4453 
    cf_arg_81->arg0 = arg0;
    
#line 4454 
    ret = pthread_create(& ldv_thread_81,(pthread_attr_t const *)0,& ldv_character_driver_scenario_81,(void *)cf_arg_81);
    
#line 4455 
    __VERIFIER_assume(ret == 0);
    
#line 4456 
    goto ldv_30725;
    case 75: 
#line 4458 
    ;
    
#line 4459 
    cf_arg_82 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 4460 
    cf_arg_82->arg0 = arg0;
    
#line 4461 
    ret = pthread_create(& ldv_thread_82,(pthread_attr_t const *)0,& ldv_character_driver_scenario_82,(void *)cf_arg_82);
    
#line 4462 
    __VERIFIER_assume(ret == 0);
    
#line 4463 
    goto ldv_30725;
    case 76: 
#line 4465 
    ;
    
#line 4466 
    cf_arg_83 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 4467 
    cf_arg_83->arg0 = arg0;
    
#line 4468 
    ret = pthread_create(& ldv_thread_83,(pthread_attr_t const *)0,& ldv_character_driver_scenario_83,(void *)cf_arg_83);
    
#line 4469 
    __VERIFIER_assume(ret == 0);
    
#line 4470 
    goto ldv_30725;
    case 77: 
#line 4472 
    ;
    
#line 4473 
    cf_arg_84 = (struct ldv_struct_character_driver_scenario_5 *)ldv_xmalloc(16UL);
    
#line 4474 
    cf_arg_84->arg0 = arg0;
    
#line 4475 
    ret = pthread_create(& ldv_thread_84,(pthread_attr_t const *)0,& ldv_character_driver_scenario_84,(void *)cf_arg_84);
    
#line 4476 
    __VERIFIER_assume(ret == 0);
    
#line 4477 
    goto ldv_30725;
    default: 
#line 4479 
    ;
    
#line 4479 
    __VERIFIER_assume(0);
  }
  ldv_30725: 
#line 4480 
  ;
  
#line 4481 
  return;
}


#line 4485  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_12(void *arg0)
{
  void *__retres;
  struct file *ldv_12_resource_1;
  int ldv_12_ldv_param_2_3;
  long long ldv_12_ldv_param_1_2;
  char *ldv_12_ldv_param_1_4;
  struct inode *ldv_12_resource_0;
  unsigned long ldv_12_size_cnt;
  long long *ldv_12_ldv_param_3_5;
  char *ldv_12_ldv_param_1_6;
  long long *ldv_12_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 4496 
  struct file_operations *ldv_12_container = ldv_emg_alias_wep_decrypt_fail_ops_2;
  
#line 4497 
  int ldv_12_ret = ldv_undef_int();
  
#line 4500 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 4504 
  ldv_12_ret = ldv_undef_int();
  
#line 4507 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 4508 
    ldv_12_container = data->arg0;
    
#line 4509 
    ldv_free((void *)data);
  }
  else ;
  
#line 4514 
  ldv_12_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 4515 
  tmp_1 = ldv_undef_int();
  
#line 4515 
  ldv_12_size_cnt = (unsigned long)tmp_1;
  
#line 4522 
  goto ldv_main_12;
  
#line 4524 
  __retres = (void *)0;
  
#line 4524 
  goto return_label;
  ldv_main_12: 
#line 4527 
  ;
  
#line 4530 
  tmp_3 = ldv_undef_int();
  
#line 4530 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 4533 
    ldv_12_ret = (*ldv_emg_alias_simple_open_5)(ldv_12_resource_0,ldv_12_resource_1);
    
#line 4535 
    ldv_12_ret = ldv_filter_err_code(ldv_12_ret);
    
#line 4538 
    tmp_2 = ldv_undef_int();
    
#line 4538 
    if (tmp_2 != 0) {
      
#line 4540 
      __VERIFIER_assume(ldv_12_ret == 0);
      
#line 4547 
      goto ldv_call_12;
    }
    else {
      
#line 4551 
      __VERIFIER_assume(ldv_12_ret != 0);
      
#line 4558 
      goto ldv_main_12;
    }
  }
  else {
    
#line 4563 
    ldv_free((void *)ldv_12_resource_0);
    
#line 4571 
    __retres = (void *)0;
    
#line 4571 
    goto return_label;
  }
  
#line 4574 
  __retres = (void *)0;
  
#line 4574 
  goto return_label;
  ldv_call_12: 
#line 4577 
  ;
  
#line 4580 
  tmp_4 = ldv_undef_int();
  
#line 4580 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 4581 
    ;
    
#line 4583 
    ldv_12_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 4584 
    ldv_12_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 4588 
    if (ldv_12_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 4594 
      __VERIFIER_assume(ldv_12_size_cnt <= 2147479552UL);
      
#line 4596 
      (*(ldv_12_container->write))(ldv_12_resource_1,(char const *)ldv_12_ldv_param_1_6,ldv_12_size_cnt,ldv_12_ldv_param_3_7);
    }
    else ;
    
#line 4601 
    ldv_free((void *)ldv_12_ldv_param_3_7);
    
#line 4602 
    ldv_free((void *)ldv_12_ldv_param_1_6);
    
#line 4609 
    goto ldv_call_12;
    case 2: 
#line 4612 
    ;
    
#line 4614 
    if (ldv_12_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 4616 
      (*(ldv_12_container->release))(ldv_12_resource_0,ldv_12_resource_1); else ;
    
#line 4624 
    goto ldv_main_12;
    case 3: 
#line 4627 
    ;
    
#line 4631 
    tmp_9 = ldv_undef_int();
    
#line 4631 
    if (tmp_9 != 0) 
#line 4634 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_12_resource_1,ldv_12_ldv_param_1_2,ldv_12_ldv_param_2_3);
    else {
      
#line 4640 
      ldv_12_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 4641 
      ldv_12_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 4646 
      ldv_emg_wrapper_wep_decrypt_fail_read_3(ldv_12_resource_1,ldv_12_ldv_param_1_4,ldv_12_size_cnt,ldv_12_ldv_param_3_5);
      
#line 4650 
      ldv_free((void *)ldv_12_ldv_param_3_5);
      
#line 4651 
      ldv_free((void *)ldv_12_ldv_param_1_4);
    }
    
#line 4655 
    goto ldv_30824;
    default: 
#line 4657 
    ;
    
#line 4657 
    __VERIFIER_assume(0);
  }
  ldv_30824: 
#line 4666 
  ;
  
#line 4666 
  goto ldv_call_12;
  
#line 4668 
  __retres = (void *)0;
  return_label: 
#line 4668 
                return __retres;
}


#line 4673  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_25(void *arg0)
{
  void *__retres;
  struct file *ldv_25_resource_1;
  int ldv_25_ldv_param_2_3;
  long long ldv_25_ldv_param_1_2;
  char *ldv_25_ldv_param_1_4;
  struct inode *ldv_25_resource_0;
  unsigned long ldv_25_size_cnt;
  long long *ldv_25_ldv_param_3_5;
  char *ldv_25_ldv_param_1_6;
  long long *ldv_25_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 4684 
  struct file_operations *ldv_25_container = ldv_emg_alias_ps_upsd_timeouts_ops_2;
  
#line 4685 
  int ldv_25_ret = ldv_undef_int();
  
#line 4688 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 4692 
  ldv_25_ret = ldv_undef_int();
  
#line 4695 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 4696 
    ldv_25_container = data->arg0;
    
#line 4697 
    ldv_free((void *)data);
  }
  else ;
  
#line 4702 
  ldv_25_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 4703 
  tmp_1 = ldv_undef_int();
  
#line 4703 
  ldv_25_size_cnt = (unsigned long)tmp_1;
  
#line 4710 
  goto ldv_main_25;
  
#line 4712 
  __retres = (void *)0;
  
#line 4712 
  goto return_label;
  ldv_main_25: 
#line 4715 
  ;
  
#line 4718 
  tmp_3 = ldv_undef_int();
  
#line 4718 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 4721 
    ldv_25_ret = (*ldv_emg_alias_simple_open_5)(ldv_25_resource_0,ldv_25_resource_1);
    
#line 4723 
    ldv_25_ret = ldv_filter_err_code(ldv_25_ret);
    
#line 4726 
    tmp_2 = ldv_undef_int();
    
#line 4726 
    if (tmp_2 != 0) {
      
#line 4728 
      __VERIFIER_assume(ldv_25_ret == 0);
      
#line 4735 
      goto ldv_call_25;
    }
    else {
      
#line 4739 
      __VERIFIER_assume(ldv_25_ret != 0);
      
#line 4746 
      goto ldv_main_25;
    }
  }
  else {
    
#line 4751 
    ldv_free((void *)ldv_25_resource_0);
    
#line 4759 
    __retres = (void *)0;
    
#line 4759 
    goto return_label;
  }
  
#line 4762 
  __retres = (void *)0;
  
#line 4762 
  goto return_label;
  ldv_call_25: 
#line 4765 
  ;
  
#line 4768 
  tmp_4 = ldv_undef_int();
  
#line 4768 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 4769 
    ;
    
#line 4771 
    ldv_25_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 4772 
    ldv_25_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 4776 
    if (ldv_25_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 4782 
      __VERIFIER_assume(ldv_25_size_cnt <= 2147479552UL);
      
#line 4784 
      (*(ldv_25_container->write))(ldv_25_resource_1,(char const *)ldv_25_ldv_param_1_6,ldv_25_size_cnt,ldv_25_ldv_param_3_7);
    }
    else ;
    
#line 4789 
    ldv_free((void *)ldv_25_ldv_param_3_7);
    
#line 4790 
    ldv_free((void *)ldv_25_ldv_param_1_6);
    
#line 4797 
    goto ldv_call_25;
    case 2: 
#line 4800 
    ;
    
#line 4802 
    if (ldv_25_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 4804 
      (*(ldv_25_container->release))(ldv_25_resource_0,ldv_25_resource_1); else ;
    
#line 4812 
    goto ldv_main_25;
    case 3: 
#line 4815 
    ;
    
#line 4819 
    tmp_9 = ldv_undef_int();
    
#line 4819 
    if (tmp_9 != 0) 
#line 4822 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_25_resource_1,ldv_25_ldv_param_1_2,ldv_25_ldv_param_2_3);
    else {
      
#line 4828 
      ldv_25_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 4829 
      ldv_25_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 4834 
      ldv_emg_wrapper_ps_upsd_timeouts_read_3(ldv_25_resource_1,ldv_25_ldv_param_1_4,ldv_25_size_cnt,ldv_25_ldv_param_3_5);
      
#line 4838 
      ldv_free((void *)ldv_25_ldv_param_3_5);
      
#line 4839 
      ldv_free((void *)ldv_25_ldv_param_1_4);
    }
    
#line 4843 
    goto ldv_30846;
    default: 
#line 4845 
    ;
    
#line 4845 
    __VERIFIER_assume(0);
  }
  ldv_30846: 
#line 4854 
  ;
  
#line 4854 
  goto ldv_call_25;
  
#line 4856 
  __retres = (void *)0;
  return_label: 
#line 4856 
                return __retres;
}


#line 4861  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_49(void *arg0)
{
  void *__retres;
  struct file *ldv_49_resource_1;
  int ldv_49_ldv_param_2_3;
  long long ldv_49_ldv_param_1_2;
  char *ldv_49_ldv_param_1_4;
  struct inode *ldv_49_resource_0;
  unsigned long ldv_49_size_cnt;
  long long *ldv_49_ldv_param_3_5;
  char *ldv_49_ldv_param_1_6;
  long long *ldv_49_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 4872 
  struct file_operations *ldv_49_container = ldv_emg_alias_rxpipe_missed_beacon_host_int_trig_rx_data_ops_2;
  
#line 4873 
  int ldv_49_ret = ldv_undef_int();
  
#line 4876 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 4880 
  ldv_49_ret = ldv_undef_int();
  
#line 4883 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 4884 
    ldv_49_container = data->arg0;
    
#line 4885 
    ldv_free((void *)data);
  }
  else ;
  
#line 4890 
  ldv_49_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 4891 
  tmp_1 = ldv_undef_int();
  
#line 4891 
  ldv_49_size_cnt = (unsigned long)tmp_1;
  
#line 4898 
  goto ldv_main_49;
  
#line 4900 
  __retres = (void *)0;
  
#line 4900 
  goto return_label;
  ldv_main_49: 
#line 4903 
  ;
  
#line 4906 
  tmp_3 = ldv_undef_int();
  
#line 4906 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 4909 
    ldv_49_ret = (*ldv_emg_alias_simple_open_5)(ldv_49_resource_0,ldv_49_resource_1);
    
#line 4911 
    ldv_49_ret = ldv_filter_err_code(ldv_49_ret);
    
#line 4914 
    tmp_2 = ldv_undef_int();
    
#line 4914 
    if (tmp_2 != 0) {
      
#line 4916 
      __VERIFIER_assume(ldv_49_ret == 0);
      
#line 4923 
      goto ldv_call_49;
    }
    else {
      
#line 4927 
      __VERIFIER_assume(ldv_49_ret != 0);
      
#line 4934 
      goto ldv_main_49;
    }
  }
  else {
    
#line 4939 
    ldv_free((void *)ldv_49_resource_0);
    
#line 4947 
    __retres = (void *)0;
    
#line 4947 
    goto return_label;
  }
  
#line 4950 
  __retres = (void *)0;
  
#line 4950 
  goto return_label;
  ldv_call_49: 
#line 4953 
  ;
  
#line 4956 
  tmp_4 = ldv_undef_int();
  
#line 4956 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 4957 
    ;
    
#line 4959 
    ldv_49_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 4960 
    ldv_49_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 4964 
    if (ldv_49_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 4970 
      __VERIFIER_assume(ldv_49_size_cnt <= 2147479552UL);
      
#line 4972 
      (*(ldv_49_container->write))(ldv_49_resource_1,(char const *)ldv_49_ldv_param_1_6,ldv_49_size_cnt,ldv_49_ldv_param_3_7);
    }
    else ;
    
#line 4977 
    ldv_free((void *)ldv_49_ldv_param_1_6);
    
#line 4978 
    ldv_free((void *)ldv_49_ldv_param_3_7);
    
#line 4985 
    goto ldv_call_49;
    case 2: 
#line 4988 
    ;
    
#line 4990 
    if (ldv_49_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 4992 
      (*(ldv_49_container->release))(ldv_49_resource_0,ldv_49_resource_1); else ;
    
#line 5000 
    goto ldv_main_49;
    case 3: 
#line 5003 
    ;
    
#line 5007 
    tmp_9 = ldv_undef_int();
    
#line 5007 
    if (tmp_9 != 0) 
#line 5010 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_49_resource_1,ldv_49_ldv_param_1_2,ldv_49_ldv_param_2_3);
    else {
      
#line 5016 
      ldv_49_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 5017 
      ldv_49_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 5022 
      ldv_emg_wrapper_rxpipe_missed_beacon_host_int_trig_rx_data_read_3(ldv_49_resource_1,ldv_49_ldv_param_1_4,ldv_49_size_cnt,ldv_49_ldv_param_3_5);
      
#line 5026 
      ldv_free((void *)ldv_49_ldv_param_3_5);
      
#line 5027 
      ldv_free((void *)ldv_49_ldv_param_1_4);
    }
    
#line 5031 
    goto ldv_30868;
    default: 
#line 5033 
    ;
    
#line 5033 
    __VERIFIER_assume(0);
  }
  ldv_30868: 
#line 5042 
  ;
  
#line 5042 
  goto ldv_call_49;
  
#line 5044 
  __retres = (void *)0;
  return_label: 
#line 5044 
                return __retres;
}


#line 5049  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_55(void *arg0)
{
  void *__retres;
  struct file *ldv_55_resource_1;
  int ldv_55_ldv_param_2_3;
  long long ldv_55_ldv_param_1_2;
  char *ldv_55_ldv_param_1_4;
  struct inode *ldv_55_resource_0;
  unsigned long ldv_55_size_cnt;
  long long *ldv_55_ldv_param_3_5;
  char *ldv_55_ldv_param_1_6;
  long long *ldv_55_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 5060 
  struct file_operations *ldv_55_container = ldv_emg_alias_wep_packets_ops_2;
  
#line 5061 
  int ldv_55_ret = ldv_undef_int();
  
#line 5064 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 5068 
  ldv_55_ret = ldv_undef_int();
  
#line 5071 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 5072 
    ldv_55_container = data->arg0;
    
#line 5073 
    ldv_free((void *)data);
  }
  else ;
  
#line 5078 
  ldv_55_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 5079 
  tmp_1 = ldv_undef_int();
  
#line 5079 
  ldv_55_size_cnt = (unsigned long)tmp_1;
  
#line 5086 
  goto ldv_main_55;
  
#line 5088 
  __retres = (void *)0;
  
#line 5088 
  goto return_label;
  ldv_main_55: 
#line 5091 
  ;
  
#line 5094 
  tmp_3 = ldv_undef_int();
  
#line 5094 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 5097 
    ldv_55_ret = (*ldv_emg_alias_simple_open_5)(ldv_55_resource_0,ldv_55_resource_1);
    
#line 5099 
    ldv_55_ret = ldv_filter_err_code(ldv_55_ret);
    
#line 5102 
    tmp_2 = ldv_undef_int();
    
#line 5102 
    if (tmp_2 != 0) {
      
#line 5104 
      __VERIFIER_assume(ldv_55_ret == 0);
      
#line 5111 
      goto ldv_call_55;
    }
    else {
      
#line 5115 
      __VERIFIER_assume(ldv_55_ret != 0);
      
#line 5122 
      goto ldv_main_55;
    }
  }
  else {
    
#line 5127 
    ldv_free((void *)ldv_55_resource_0);
    
#line 5135 
    __retres = (void *)0;
    
#line 5135 
    goto return_label;
  }
  
#line 5138 
  __retres = (void *)0;
  
#line 5138 
  goto return_label;
  ldv_call_55: 
#line 5141 
  ;
  
#line 5144 
  tmp_4 = ldv_undef_int();
  
#line 5144 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 5145 
    ;
    
#line 5147 
    ldv_55_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 5148 
    ldv_55_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 5152 
    if (ldv_55_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 5158 
      __VERIFIER_assume(ldv_55_size_cnt <= 2147479552UL);
      
#line 5160 
      (*(ldv_55_container->write))(ldv_55_resource_1,(char const *)ldv_55_ldv_param_1_6,ldv_55_size_cnt,ldv_55_ldv_param_3_7);
    }
    else ;
    
#line 5165 
    ldv_free((void *)ldv_55_ldv_param_1_6);
    
#line 5166 
    ldv_free((void *)ldv_55_ldv_param_3_7);
    
#line 5173 
    goto ldv_call_55;
    case 2: 
#line 5176 
    ;
    
#line 5178 
    if (ldv_55_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 5180 
      (*(ldv_55_container->release))(ldv_55_resource_0,ldv_55_resource_1); else ;
    
#line 5188 
    goto ldv_main_55;
    case 3: 
#line 5191 
    ;
    
#line 5195 
    tmp_9 = ldv_undef_int();
    
#line 5195 
    if (tmp_9 != 0) 
#line 5198 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_55_resource_1,ldv_55_ldv_param_1_2,ldv_55_ldv_param_2_3);
    else {
      
#line 5204 
      ldv_55_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 5205 
      ldv_55_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 5210 
      ldv_emg_wrapper_wep_packets_read_3(ldv_55_resource_1,ldv_55_ldv_param_1_4,ldv_55_size_cnt,ldv_55_ldv_param_3_5);
      
#line 5214 
      ldv_free((void *)ldv_55_ldv_param_3_5);
      
#line 5215 
      ldv_free((void *)ldv_55_ldv_param_1_4);
    }
    
#line 5219 
    goto ldv_30890;
    default: 
#line 5221 
    ;
    
#line 5221 
    __VERIFIER_assume(0);
  }
  ldv_30890: 
#line 5230 
  ;
  
#line 5230 
  goto ldv_call_55;
  
#line 5232 
  __retres = (void *)0;
  return_label: 
#line 5232 
                return __retres;
}


#line 5237  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_35(void *arg0)
{
  void *__retres;
  struct file *ldv_35_resource_1;
  int ldv_35_ldv_param_2_3;
  long long ldv_35_ldv_param_1_2;
  char *ldv_35_ldv_param_1_4;
  struct inode *ldv_35_resource_0;
  unsigned long ldv_35_size_cnt;
  long long *ldv_35_ldv_param_3_5;
  char *ldv_35_ldv_param_1_6;
  long long *ldv_35_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 5248 
  struct file_operations *ldv_35_container = ldv_emg_alias_isr_low_rssi_ops_2;
  
#line 5249 
  int ldv_35_ret = ldv_undef_int();
  
#line 5252 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 5256 
  ldv_35_ret = ldv_undef_int();
  
#line 5259 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 5260 
    ldv_35_container = data->arg0;
    
#line 5261 
    ldv_free((void *)data);
  }
  else ;
  
#line 5266 
  ldv_35_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 5267 
  tmp_1 = ldv_undef_int();
  
#line 5267 
  ldv_35_size_cnt = (unsigned long)tmp_1;
  
#line 5274 
  goto ldv_main_35;
  
#line 5276 
  __retres = (void *)0;
  
#line 5276 
  goto return_label;
  ldv_main_35: 
#line 5279 
  ;
  
#line 5282 
  tmp_3 = ldv_undef_int();
  
#line 5282 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 5285 
    ldv_35_ret = (*ldv_emg_alias_simple_open_5)(ldv_35_resource_0,ldv_35_resource_1);
    
#line 5287 
    ldv_35_ret = ldv_filter_err_code(ldv_35_ret);
    
#line 5290 
    tmp_2 = ldv_undef_int();
    
#line 5290 
    if (tmp_2 != 0) {
      
#line 5292 
      __VERIFIER_assume(ldv_35_ret == 0);
      
#line 5299 
      goto ldv_call_35;
    }
    else {
      
#line 5303 
      __VERIFIER_assume(ldv_35_ret != 0);
      
#line 5310 
      goto ldv_main_35;
    }
  }
  else {
    
#line 5315 
    ldv_free((void *)ldv_35_resource_0);
    
#line 5323 
    __retres = (void *)0;
    
#line 5323 
    goto return_label;
  }
  
#line 5326 
  __retres = (void *)0;
  
#line 5326 
  goto return_label;
  ldv_call_35: 
#line 5329 
  ;
  
#line 5332 
  tmp_4 = ldv_undef_int();
  
#line 5332 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 5333 
    ;
    
#line 5335 
    ldv_35_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 5336 
    ldv_35_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 5340 
    if (ldv_35_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 5346 
      __VERIFIER_assume(ldv_35_size_cnt <= 2147479552UL);
      
#line 5348 
      (*(ldv_35_container->write))(ldv_35_resource_1,(char const *)ldv_35_ldv_param_1_6,ldv_35_size_cnt,ldv_35_ldv_param_3_7);
    }
    else ;
    
#line 5353 
    ldv_free((void *)ldv_35_ldv_param_3_7);
    
#line 5354 
    ldv_free((void *)ldv_35_ldv_param_1_6);
    
#line 5361 
    goto ldv_call_35;
    case 2: 
#line 5364 
    ;
    
#line 5366 
    if (ldv_35_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 5368 
      (*(ldv_35_container->release))(ldv_35_resource_0,ldv_35_resource_1); else ;
    
#line 5376 
    goto ldv_main_35;
    case 3: 
#line 5379 
    ;
    
#line 5383 
    tmp_9 = ldv_undef_int();
    
#line 5383 
    if (tmp_9 != 0) 
#line 5386 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_35_resource_1,ldv_35_ldv_param_1_2,ldv_35_ldv_param_2_3);
    else {
      
#line 5392 
      ldv_35_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 5393 
      ldv_35_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 5398 
      ldv_emg_wrapper_isr_low_rssi_read_3(ldv_35_resource_1,ldv_35_ldv_param_1_4,ldv_35_size_cnt,ldv_35_ldv_param_3_5);
      
#line 5402 
      ldv_free((void *)ldv_35_ldv_param_3_5);
      
#line 5403 
      ldv_free((void *)ldv_35_ldv_param_1_4);
    }
    
#line 5407 
    goto ldv_30912;
    default: 
#line 5409 
    ;
    
#line 5409 
    __VERIFIER_assume(0);
  }
  ldv_30912: 
#line 5418 
  ;
  
#line 5418 
  goto ldv_call_35;
  
#line 5420 
  __retres = (void *)0;
  return_label: 
#line 5420 
                return __retres;
}


#line 5425  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_84(void *arg0)
{
  void *__retres;
  struct file *ldv_84_resource_1;
  int ldv_84_ldv_param_2_3;
  long long ldv_84_ldv_param_1_2;
  char *ldv_84_ldv_param_1_4;
  struct inode *ldv_84_resource_0;
  unsigned long ldv_84_size_cnt;
  long long *ldv_84_ldv_param_3_5;
  char *ldv_84_ldv_param_1_6;
  long long *ldv_84_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 5436 
  struct file_operations *ldv_84_container = ldv_emg_alias_event_rx_pool_ops_2;
  
#line 5437 
  int ldv_84_ret = ldv_undef_int();
  
#line 5440 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 5444 
  ldv_84_ret = ldv_undef_int();
  
#line 5447 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 5448 
    ldv_84_container = data->arg0;
    
#line 5449 
    ldv_free((void *)data);
  }
  else ;
  
#line 5454 
  ldv_84_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 5455 
  tmp_1 = ldv_undef_int();
  
#line 5455 
  ldv_84_size_cnt = (unsigned long)tmp_1;
  
#line 5462 
  goto ldv_main_84;
  
#line 5464 
  __retres = (void *)0;
  
#line 5464 
  goto return_label;
  ldv_main_84: 
#line 5467 
  ;
  
#line 5470 
  tmp_3 = ldv_undef_int();
  
#line 5470 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 5473 
    ldv_84_ret = (*ldv_emg_alias_simple_open_5)(ldv_84_resource_0,ldv_84_resource_1);
    
#line 5475 
    ldv_84_ret = ldv_filter_err_code(ldv_84_ret);
    
#line 5478 
    tmp_2 = ldv_undef_int();
    
#line 5478 
    if (tmp_2 != 0) {
      
#line 5480 
      __VERIFIER_assume(ldv_84_ret == 0);
      
#line 5487 
      goto ldv_call_84;
    }
    else {
      
#line 5491 
      __VERIFIER_assume(ldv_84_ret != 0);
      
#line 5498 
      goto ldv_main_84;
    }
  }
  else {
    
#line 5503 
    ldv_free((void *)ldv_84_resource_0);
    
#line 5511 
    __retres = (void *)0;
    
#line 5511 
    goto return_label;
  }
  
#line 5514 
  __retres = (void *)0;
  
#line 5514 
  goto return_label;
  ldv_call_84: 
#line 5517 
  ;
  
#line 5520 
  tmp_4 = ldv_undef_int();
  
#line 5520 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 5521 
    ;
    
#line 5523 
    ldv_84_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 5524 
    ldv_84_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 5528 
    if (ldv_84_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 5534 
      __VERIFIER_assume(ldv_84_size_cnt <= 2147479552UL);
      
#line 5536 
      (*(ldv_84_container->write))(ldv_84_resource_1,(char const *)ldv_84_ldv_param_1_6,ldv_84_size_cnt,ldv_84_ldv_param_3_7);
    }
    else ;
    
#line 5541 
    ldv_free((void *)ldv_84_ldv_param_3_7);
    
#line 5542 
    ldv_free((void *)ldv_84_ldv_param_1_6);
    
#line 5549 
    goto ldv_call_84;
    case 2: 
#line 5552 
    ;
    
#line 5554 
    if (ldv_84_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 5556 
      (*(ldv_84_container->release))(ldv_84_resource_0,ldv_84_resource_1); else ;
    
#line 5564 
    goto ldv_main_84;
    case 3: 
#line 5567 
    ;
    
#line 5571 
    tmp_9 = ldv_undef_int();
    
#line 5571 
    if (tmp_9 != 0) 
#line 5574 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_84_resource_1,ldv_84_ldv_param_1_2,ldv_84_ldv_param_2_3);
    else {
      
#line 5580 
      ldv_84_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 5581 
      ldv_84_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 5586 
      ldv_emg_wrapper_event_rx_pool_read_3(ldv_84_resource_1,ldv_84_ldv_param_1_4,ldv_84_size_cnt,ldv_84_ldv_param_3_5);
      
#line 5590 
      ldv_free((void *)ldv_84_ldv_param_3_5);
      
#line 5591 
      ldv_free((void *)ldv_84_ldv_param_1_4);
    }
    
#line 5595 
    goto ldv_30934;
    default: 
#line 5597 
    ;
    
#line 5597 
    __VERIFIER_assume(0);
  }
  ldv_30934: 
#line 5606 
  ;
  
#line 5606 
  goto ldv_call_84;
  
#line 5608 
  __retres = (void *)0;
  return_label: 
#line 5608 
                return __retres;
}


#line 5613  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_26(void *arg0)
{
  void *__retres;
  struct file *ldv_26_resource_1;
  int ldv_26_ldv_param_2_3;
  long long ldv_26_ldv_param_1_2;
  char *ldv_26_ldv_param_1_4;
  struct inode *ldv_26_resource_0;
  unsigned long ldv_26_size_cnt;
  long long *ldv_26_ldv_param_3_5;
  char *ldv_26_ldv_param_1_6;
  long long *ldv_26_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 5624 
  struct file_operations *ldv_26_container = ldv_emg_alias_isr_dma0_done_ops_2;
  
#line 5625 
  int ldv_26_ret = ldv_undef_int();
  
#line 5628 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 5632 
  ldv_26_ret = ldv_undef_int();
  
#line 5635 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 5636 
    ldv_26_container = data->arg0;
    
#line 5637 
    ldv_free((void *)data);
  }
  else ;
  
#line 5642 
  ldv_26_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 5643 
  tmp_1 = ldv_undef_int();
  
#line 5643 
  ldv_26_size_cnt = (unsigned long)tmp_1;
  
#line 5650 
  goto ldv_main_26;
  
#line 5652 
  __retres = (void *)0;
  
#line 5652 
  goto return_label;
  ldv_main_26: 
#line 5655 
  ;
  
#line 5658 
  tmp_3 = ldv_undef_int();
  
#line 5658 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 5661 
    ldv_26_ret = (*ldv_emg_alias_simple_open_5)(ldv_26_resource_0,ldv_26_resource_1);
    
#line 5663 
    ldv_26_ret = ldv_filter_err_code(ldv_26_ret);
    
#line 5666 
    tmp_2 = ldv_undef_int();
    
#line 5666 
    if (tmp_2 != 0) {
      
#line 5668 
      __VERIFIER_assume(ldv_26_ret == 0);
      
#line 5675 
      goto ldv_call_26;
    }
    else {
      
#line 5679 
      __VERIFIER_assume(ldv_26_ret != 0);
      
#line 5686 
      goto ldv_main_26;
    }
  }
  else {
    
#line 5691 
    ldv_free((void *)ldv_26_resource_0);
    
#line 5699 
    __retres = (void *)0;
    
#line 5699 
    goto return_label;
  }
  
#line 5702 
  __retres = (void *)0;
  
#line 5702 
  goto return_label;
  ldv_call_26: 
#line 5705 
  ;
  
#line 5708 
  tmp_4 = ldv_undef_int();
  
#line 5708 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 5709 
    ;
    
#line 5711 
    ldv_26_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 5712 
    ldv_26_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 5716 
    if (ldv_26_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 5722 
      __VERIFIER_assume(ldv_26_size_cnt <= 2147479552UL);
      
#line 5724 
      (*(ldv_26_container->write))(ldv_26_resource_1,(char const *)ldv_26_ldv_param_1_6,ldv_26_size_cnt,ldv_26_ldv_param_3_7);
    }
    else ;
    
#line 5729 
    ldv_free((void *)ldv_26_ldv_param_3_7);
    
#line 5730 
    ldv_free((void *)ldv_26_ldv_param_1_6);
    
#line 5737 
    goto ldv_call_26;
    case 2: 
#line 5740 
    ;
    
#line 5742 
    if (ldv_26_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 5744 
      (*(ldv_26_container->release))(ldv_26_resource_0,ldv_26_resource_1); else ;
    
#line 5752 
    goto ldv_main_26;
    case 3: 
#line 5755 
    ;
    
#line 5759 
    tmp_9 = ldv_undef_int();
    
#line 5759 
    if (tmp_9 != 0) 
#line 5762 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_26_resource_1,ldv_26_ldv_param_1_2,ldv_26_ldv_param_2_3);
    else {
      
#line 5768 
      ldv_26_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 5769 
      ldv_26_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 5774 
      ldv_emg_wrapper_isr_dma0_done_read_3(ldv_26_resource_1,ldv_26_ldv_param_1_4,ldv_26_size_cnt,ldv_26_ldv_param_3_5);
      
#line 5778 
      ldv_free((void *)ldv_26_ldv_param_1_4);
      
#line 5779 
      ldv_free((void *)ldv_26_ldv_param_3_5);
    }
    
#line 5783 
    goto ldv_30956;
    default: 
#line 5785 
    ;
    
#line 5785 
    __VERIFIER_assume(0);
  }
  ldv_30956: 
#line 5794 
  ;
  
#line 5794 
  goto ldv_call_26;
  
#line 5796 
  __retres = (void *)0;
  return_label: 
#line 5796 
                return __retres;
}


#line 5801  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_pm_ops_scenario_34(void *arg0)
{
  void *__retres;
  struct dev_pm_ops *ldv_34_pm_ops;
  struct device *ldv_34_device;
  int tmp;
  
#line 5808 
  ldv_free(arg0);
  
#line 5815 
  goto ldv_do_34;
  
#line 5817 
  __retres = (void *)0;
  
#line 5817 
  goto return_label;
  ldv_do_34: 
#line 5820 
  ;
  
#line 5823 
  tmp = ldv_undef_int();
  
#line 5823 
  switch (tmp) {
    int tmp_0;
    case 1: 
#line 5824 
    ;
    
#line 5826 
    if (ldv_34_pm_ops->runtime_idle != (int (*)(struct device *))0) 
#line 5828 
                                                                    (*(ldv_34_pm_ops->runtime_idle))(ldv_34_device); else ;
    
#line 5836 
    goto ldv_do_34;
    case 2: 
#line 5839 
    ;
    
#line 5841 
    if (ldv_34_pm_ops->runtime_suspend != (int (*)(struct device *))0) 
      
#line 5843 
      (*(ldv_34_pm_ops->runtime_suspend))(ldv_34_device); else ;
    
#line 5848 
    if (ldv_34_pm_ops->runtime_resume != (int (*)(struct device *))0) 
      
#line 5850 
      (*(ldv_34_pm_ops->runtime_resume))(ldv_34_device); else ;
    
#line 5858 
    goto ldv_do_34;
    case 3: 
#line 5861 
    ;
    
#line 5863 
    if (ldv_34_pm_ops->prepare != (int (*)(struct device *))0) 
#line 5865 
                                                               (*(ldv_34_pm_ops->prepare))(ldv_34_device); else ;
    
#line 5869 
    tmp_0 = ldv_undef_int();
    
#line 5869 
    switch (tmp_0) {
      int tmp_1;
      int tmp_2;
      int tmp_3;
      case 1: 
#line 5870 
      ;
      
#line 5872 
      if (ldv_34_pm_ops->suspend != (int (*)(struct device *))0) 
#line 5874 
                                                                 (*(ldv_34_pm_ops->suspend))(ldv_34_device); else ;
      
#line 5878 
      tmp_1 = ldv_undef_int();
      
#line 5878 
      if (tmp_1 != 0) {
        
#line 5880 
        if (ldv_34_pm_ops->suspend_noirq != (int (*)(struct device *))0) 
          
#line 5882 
          (*(ldv_34_pm_ops->suspend_noirq))(ldv_34_device); else ;
        
#line 5887 
        if (ldv_34_pm_ops->resume_noirq != (int (*)(struct device *))0) 
          
#line 5889 
          (*(ldv_34_pm_ops->resume_noirq))(ldv_34_device); else ;
      }
      else {
        
#line 5896 
        if (ldv_34_pm_ops->suspend_late != (int (*)(struct device *))0) 
          
#line 5898 
          (*(ldv_34_pm_ops->suspend_late))(ldv_34_device); else ;
        
#line 5903 
        if (ldv_34_pm_ops->resume_early != (int (*)(struct device *))0) 
          
#line 5905 
          (*(ldv_34_pm_ops->resume_early))(ldv_34_device); else ;
      }
      
#line 5911 
      if (ldv_34_pm_ops->resume != (int (*)(struct device *))0) 
#line 5913 
                                                                (*(ldv_34_pm_ops->resume))(ldv_34_device); else ;
      
#line 5917 
      goto ldv_30968;
      case 2: 
#line 5919 
      ;
      
#line 5921 
      if (ldv_34_pm_ops->freeze != (int (*)(struct device *))0) 
#line 5923 
                                                                (*(ldv_34_pm_ops->freeze))(ldv_34_device); else ;
      
#line 5927 
      tmp_2 = ldv_undef_int();
      
#line 5927 
      if (tmp_2 != 0) {
        
#line 5929 
        if (ldv_34_pm_ops->freeze_late != (int (*)(struct device *))0) 
          
#line 5931 
          (*(ldv_34_pm_ops->freeze_late))(ldv_34_device); else ;
        
#line 5936 
        if (ldv_34_pm_ops->thaw_early != (int (*)(struct device *))0) 
          
#line 5938 
          (*(ldv_34_pm_ops->thaw_early))(ldv_34_device); else ;
      }
      else {
        
#line 5945 
        if (ldv_34_pm_ops->freeze_noirq != (int (*)(struct device *))0) 
          
#line 5947 
          (*(ldv_34_pm_ops->freeze_noirq))(ldv_34_device); else ;
        
#line 5952 
        if (ldv_34_pm_ops->thaw_noirq != (int (*)(struct device *))0) 
          
#line 5954 
          (*(ldv_34_pm_ops->thaw_noirq))(ldv_34_device); else ;
      }
      
#line 5960 
      if (ldv_34_pm_ops->thaw != (int (*)(struct device *))0) 
#line 5962 
                                                              (*(ldv_34_pm_ops->thaw))(ldv_34_device); else ;
      
#line 5966 
      goto ldv_30968;
      case 3: 
#line 5968 
      ;
      
#line 5970 
      if (ldv_34_pm_ops->poweroff != (int (*)(struct device *))0) 
#line 5972 
                                                                  (*(ldv_34_pm_ops->poweroff))(ldv_34_device); else ;
      
#line 5976 
      tmp_3 = ldv_undef_int();
      
#line 5976 
      if (tmp_3 != 0) {
        
#line 5978 
        if (ldv_34_pm_ops->poweroff_late != (int (*)(struct device *))0) 
          
#line 5980 
          (*(ldv_34_pm_ops->poweroff_late))(ldv_34_device); else ;
        
#line 5985 
        if (ldv_34_pm_ops->restore_early != (int (*)(struct device *))0) 
          
#line 5987 
          (*(ldv_34_pm_ops->restore_early))(ldv_34_device); else ;
      }
      else {
        
#line 5994 
        if (ldv_34_pm_ops->poweroff_noirq != (int (*)(struct device *))0) 
          
#line 5996 
          (*(ldv_34_pm_ops->poweroff_noirq))(ldv_34_device); else ;
        
#line 6001 
        if (ldv_34_pm_ops->restore_noirq != (int (*)(struct device *))0) 
          
#line 6003 
          (*(ldv_34_pm_ops->restore_noirq))(ldv_34_device); else ;
      }
      
#line 6009 
      if (ldv_34_pm_ops->restore != (int (*)(struct device *))0) 
#line 6011 
                                                                 (*(ldv_34_pm_ops->restore))(ldv_34_device); else ;
      
#line 6015 
      goto ldv_30968;
      default: 
#line 6017 
      ;
      
#line 6017 
      __VERIFIER_assume(0);
    }
    ldv_30968: 
#line 6020 
    ;
    
#line 6020 
    if (ldv_34_pm_ops->complete != (void (*)(struct device *))0) 
#line 6022 
                                                                 (*(ldv_34_pm_ops->complete))(ldv_34_device); else ;
    
#line 6030 
    goto ldv_do_34;
    case 4: 
#line 6033 
    ;
    
#line 6039 
    __retres = (void *)0;
    
#line 6039 
    goto return_label;
    default: 
#line 6042 
    ;
    
#line 6042 
    __VERIFIER_assume(0);
  }
  
#line 6045 
  __retres = (void *)0;
  return_label: 
#line 6045 
                return __retres;
}


#line 6050  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
struct dentry *ldv_emg_debugfs_create_file(char *arg0, unsigned short arg1, struct dentry *arg2, void *arg3, struct file_operations *arg4)
{
  struct dentry *__retres;
  struct dentry *ldv_4_dentry;
  struct file_operations *ldv_4_file_operations;
  int tmp_1;
  
#line 6058 
  tmp_1 = ldv_undef_int();
  
#line 6058 
  if (tmp_1 != 0) {
    
#line 6060 
    ldv_4_dentry = (struct dentry *)ldv_xmalloc_unknown_size(0UL);
    
#line 6061 
    ldv_4_file_operations = arg4;
    
#line 6065 
    ldv_dispatch_register_4_3(ldv_4_file_operations);
    
#line 6069 
    __retres = ldv_4_dentry;
    
#line 6069 
    goto return_label;
  }
  else {
    struct dentry *tmp_0;
    
#line 6076 
    tmp_0 = (struct dentry *)ERR_PTR(-19L);
    
#line 6076 
    __retres = tmp_0;
    
#line 6076 
    goto return_label;
  }
  return_label: 
#line 6058 
                return __retres;
}


#line 6086  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_19(void *arg0)
{
  void *__retres;
  struct file *ldv_19_resource_1;
  int ldv_19_ldv_param_2_3;
  long long ldv_19_ldv_param_1_2;
  char *ldv_19_ldv_param_1_4;
  struct inode *ldv_19_resource_0;
  unsigned long ldv_19_size_cnt;
  long long *ldv_19_ldv_param_3_5;
  char *ldv_19_ldv_param_1_6;
  long long *ldv_19_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 6097 
  struct file_operations *ldv_19_container = ldv_emg_alias_dma_rx_errors_ops_2;
  
#line 6098 
  int ldv_19_ret = ldv_undef_int();
  
#line 6101 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 6105 
  ldv_19_ret = ldv_undef_int();
  
#line 6108 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 6109 
    ldv_19_container = data->arg0;
    
#line 6110 
    ldv_free((void *)data);
  }
  else ;
  
#line 6115 
  ldv_19_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 6116 
  tmp_1 = ldv_undef_int();
  
#line 6116 
  ldv_19_size_cnt = (unsigned long)tmp_1;
  
#line 6123 
  goto ldv_main_19;
  
#line 6125 
  __retres = (void *)0;
  
#line 6125 
  goto return_label;
  ldv_main_19: 
#line 6128 
  ;
  
#line 6131 
  tmp_3 = ldv_undef_int();
  
#line 6131 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 6134 
    ldv_19_ret = (*ldv_emg_alias_simple_open_5)(ldv_19_resource_0,ldv_19_resource_1);
    
#line 6136 
    ldv_19_ret = ldv_filter_err_code(ldv_19_ret);
    
#line 6139 
    tmp_2 = ldv_undef_int();
    
#line 6139 
    if (tmp_2 != 0) {
      
#line 6141 
      __VERIFIER_assume(ldv_19_ret == 0);
      
#line 6148 
      goto ldv_call_19;
    }
    else {
      
#line 6152 
      __VERIFIER_assume(ldv_19_ret != 0);
      
#line 6159 
      goto ldv_main_19;
    }
  }
  else {
    
#line 6164 
    ldv_free((void *)ldv_19_resource_0);
    
#line 6172 
    __retres = (void *)0;
    
#line 6172 
    goto return_label;
  }
  
#line 6175 
  __retres = (void *)0;
  
#line 6175 
  goto return_label;
  ldv_call_19: 
#line 6178 
  ;
  
#line 6181 
  tmp_4 = ldv_undef_int();
  
#line 6181 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 6182 
    ;
    
#line 6184 
    ldv_19_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 6185 
    ldv_19_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 6189 
    if (ldv_19_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 6195 
      __VERIFIER_assume(ldv_19_size_cnt <= 2147479552UL);
      
#line 6197 
      (*(ldv_19_container->write))(ldv_19_resource_1,(char const *)ldv_19_ldv_param_1_6,ldv_19_size_cnt,ldv_19_ldv_param_3_7);
    }
    else ;
    
#line 6202 
    ldv_free((void *)ldv_19_ldv_param_1_6);
    
#line 6203 
    ldv_free((void *)ldv_19_ldv_param_3_7);
    
#line 6210 
    goto ldv_call_19;
    case 2: 
#line 6213 
    ;
    
#line 6215 
    if (ldv_19_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 6217 
      (*(ldv_19_container->release))(ldv_19_resource_0,ldv_19_resource_1); else ;
    
#line 6225 
    goto ldv_main_19;
    case 3: 
#line 6228 
    ;
    
#line 6232 
    tmp_9 = ldv_undef_int();
    
#line 6232 
    if (tmp_9 != 0) 
#line 6235 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_19_resource_1,ldv_19_ldv_param_1_2,ldv_19_ldv_param_2_3);
    else {
      
#line 6241 
      ldv_19_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 6242 
      ldv_19_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 6247 
      ldv_emg_wrapper_dma_rx_errors_read_3(ldv_19_resource_1,ldv_19_ldv_param_1_4,ldv_19_size_cnt,ldv_19_ldv_param_3_5);
      
#line 6251 
      ldv_free((void *)ldv_19_ldv_param_3_5);
      
#line 6252 
      ldv_free((void *)ldv_19_ldv_param_1_4);
    }
    
#line 6256 
    goto ldv_31003;
    default: 
#line 6258 
    ;
    
#line 6258 
    __VERIFIER_assume(0);
  }
  ldv_31003: 
#line 6267 
  ;
  
#line 6267 
  goto ldv_call_19;
  
#line 6269 
  __retres = (void *)0;
  return_label: 
#line 6269 
                return __retres;
}


#line 6274  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_pm_register_17_13(void)
{
  int ret;
  struct ldv_struct_platform_instance_17 *cf_arg_34;
  int tmp;
  
#line 6277 
  tmp = ldv_undef_int();
  
#line 6277 
  switch (tmp) {
    case 0: 
#line 6278 
    ;
    
#line 6279 
    cf_arg_34 = (struct ldv_struct_platform_instance_17 *)ldv_xmalloc(16UL);
    
#line 6280 
    ret = pthread_create(& ldv_thread_34,(pthread_attr_t const *)0,& ldv_pm_ops_scenario_34,(void *)cf_arg_34);
    
#line 6281 
    __VERIFIER_assume(ret == 0);
    
#line 6282 
    goto ldv_31011;
    default: 
#line 6284 
    ;
    
#line 6284 
    __VERIFIER_assume(0);
  }
  ldv_31011: 
#line 6285 
  ;
  
#line 6286 
  return;
}


#line 6290  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_68(void *arg0)
{
  void *__retres;
  struct file *ldv_68_resource_1;
  int ldv_68_ldv_param_2_3;
  long long ldv_68_ldv_param_1_2;
  char *ldv_68_ldv_param_1_4;
  struct inode *ldv_68_resource_0;
  unsigned long ldv_68_size_cnt;
  long long *ldv_68_ldv_param_3_5;
  char *ldv_68_ldv_param_1_6;
  long long *ldv_68_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 6301 
  struct file_operations *ldv_68_container = ldv_emg_alias_pwr_fix_tsf_ps_ops_2;
  
#line 6302 
  int ldv_68_ret = ldv_undef_int();
  
#line 6305 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 6309 
  ldv_68_ret = ldv_undef_int();
  
#line 6312 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 6313 
    ldv_68_container = data->arg0;
    
#line 6314 
    ldv_free((void *)data);
  }
  else ;
  
#line 6319 
  ldv_68_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 6320 
  tmp_1 = ldv_undef_int();
  
#line 6320 
  ldv_68_size_cnt = (unsigned long)tmp_1;
  
#line 6327 
  goto ldv_main_68;
  
#line 6329 
  __retres = (void *)0;
  
#line 6329 
  goto return_label;
  ldv_main_68: 
#line 6332 
  ;
  
#line 6335 
  tmp_3 = ldv_undef_int();
  
#line 6335 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 6338 
    ldv_68_ret = (*ldv_emg_alias_simple_open_5)(ldv_68_resource_0,ldv_68_resource_1);
    
#line 6340 
    ldv_68_ret = ldv_filter_err_code(ldv_68_ret);
    
#line 6343 
    tmp_2 = ldv_undef_int();
    
#line 6343 
    if (tmp_2 != 0) {
      
#line 6345 
      __VERIFIER_assume(ldv_68_ret == 0);
      
#line 6352 
      goto ldv_call_68;
    }
    else {
      
#line 6356 
      __VERIFIER_assume(ldv_68_ret != 0);
      
#line 6363 
      goto ldv_main_68;
    }
  }
  else {
    
#line 6368 
    ldv_free((void *)ldv_68_resource_0);
    
#line 6376 
    __retres = (void *)0;
    
#line 6376 
    goto return_label;
  }
  
#line 6379 
  __retres = (void *)0;
  
#line 6379 
  goto return_label;
  ldv_call_68: 
#line 6382 
  ;
  
#line 6385 
  tmp_4 = ldv_undef_int();
  
#line 6385 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 6386 
    ;
    
#line 6388 
    ldv_68_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 6389 
    ldv_68_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 6393 
    if (ldv_68_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 6399 
      __VERIFIER_assume(ldv_68_size_cnt <= 2147479552UL);
      
#line 6401 
      (*(ldv_68_container->write))(ldv_68_resource_1,(char const *)ldv_68_ldv_param_1_6,ldv_68_size_cnt,ldv_68_ldv_param_3_7);
    }
    else ;
    
#line 6406 
    ldv_free((void *)ldv_68_ldv_param_3_7);
    
#line 6407 
    ldv_free((void *)ldv_68_ldv_param_1_6);
    
#line 6414 
    goto ldv_call_68;
    case 2: 
#line 6417 
    ;
    
#line 6419 
    if (ldv_68_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 6421 
      (*(ldv_68_container->release))(ldv_68_resource_0,ldv_68_resource_1); else ;
    
#line 6429 
    goto ldv_main_68;
    case 3: 
#line 6432 
    ;
    
#line 6436 
    tmp_9 = ldv_undef_int();
    
#line 6436 
    if (tmp_9 != 0) 
#line 6439 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_68_resource_1,ldv_68_ldv_param_1_2,ldv_68_ldv_param_2_3);
    else {
      
#line 6445 
      ldv_68_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 6446 
      ldv_68_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 6451 
      ldv_emg_wrapper_pwr_fix_tsf_ps_read_3(ldv_68_resource_1,ldv_68_ldv_param_1_4,ldv_68_size_cnt,ldv_68_ldv_param_3_5);
      
#line 6455 
      ldv_free((void *)ldv_68_ldv_param_1_4);
      
#line 6456 
      ldv_free((void *)ldv_68_ldv_param_3_5);
    }
    
#line 6460 
    goto ldv_31033;
    default: 
#line 6462 
    ;
    
#line 6462 
    __VERIFIER_assume(0);
  }
  ldv_31033: 
#line 6471 
  ;
  
#line 6471 
  goto ldv_call_68;
  
#line 6473 
  __retres = (void *)0;
  return_label: 
#line 6473 
                return __retres;
}


#line 6478  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_71(void *arg0)
{
  void *__retres;
  struct file *ldv_71_resource_1;
  int ldv_71_ldv_param_2_3;
  long long ldv_71_ldv_param_1_2;
  char *ldv_71_ldv_param_1_4;
  struct inode *ldv_71_resource_0;
  unsigned long ldv_71_size_cnt;
  long long *ldv_71_ldv_param_3_5;
  char *ldv_71_ldv_param_1_6;
  long long *ldv_71_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 6489 
  struct file_operations *ldv_71_container = ldv_emg_alias_pwr_power_save_off_ops_2;
  
#line 6490 
  int ldv_71_ret = ldv_undef_int();
  
#line 6493 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 6497 
  ldv_71_ret = ldv_undef_int();
  
#line 6500 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 6501 
    ldv_71_container = data->arg0;
    
#line 6502 
    ldv_free((void *)data);
  }
  else ;
  
#line 6507 
  ldv_71_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 6508 
  tmp_1 = ldv_undef_int();
  
#line 6508 
  ldv_71_size_cnt = (unsigned long)tmp_1;
  
#line 6515 
  goto ldv_main_71;
  
#line 6517 
  __retres = (void *)0;
  
#line 6517 
  goto return_label;
  ldv_main_71: 
#line 6520 
  ;
  
#line 6523 
  tmp_3 = ldv_undef_int();
  
#line 6523 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 6526 
    ldv_71_ret = (*ldv_emg_alias_simple_open_5)(ldv_71_resource_0,ldv_71_resource_1);
    
#line 6528 
    ldv_71_ret = ldv_filter_err_code(ldv_71_ret);
    
#line 6531 
    tmp_2 = ldv_undef_int();
    
#line 6531 
    if (tmp_2 != 0) {
      
#line 6533 
      __VERIFIER_assume(ldv_71_ret == 0);
      
#line 6540 
      goto ldv_call_71;
    }
    else {
      
#line 6544 
      __VERIFIER_assume(ldv_71_ret != 0);
      
#line 6551 
      goto ldv_main_71;
    }
  }
  else {
    
#line 6556 
    ldv_free((void *)ldv_71_resource_0);
    
#line 6564 
    __retres = (void *)0;
    
#line 6564 
    goto return_label;
  }
  
#line 6567 
  __retres = (void *)0;
  
#line 6567 
  goto return_label;
  ldv_call_71: 
#line 6570 
  ;
  
#line 6573 
  tmp_4 = ldv_undef_int();
  
#line 6573 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 6574 
    ;
    
#line 6576 
    ldv_71_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 6577 
    ldv_71_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 6581 
    if (ldv_71_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 6587 
      __VERIFIER_assume(ldv_71_size_cnt <= 2147479552UL);
      
#line 6589 
      (*(ldv_71_container->write))(ldv_71_resource_1,(char const *)ldv_71_ldv_param_1_6,ldv_71_size_cnt,ldv_71_ldv_param_3_7);
    }
    else ;
    
#line 6594 
    ldv_free((void *)ldv_71_ldv_param_1_6);
    
#line 6595 
    ldv_free((void *)ldv_71_ldv_param_3_7);
    
#line 6602 
    goto ldv_call_71;
    case 2: 
#line 6605 
    ;
    
#line 6607 
    if (ldv_71_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 6609 
      (*(ldv_71_container->release))(ldv_71_resource_0,ldv_71_resource_1); else ;
    
#line 6617 
    goto ldv_main_71;
    case 3: 
#line 6620 
    ;
    
#line 6624 
    tmp_9 = ldv_undef_int();
    
#line 6624 
    if (tmp_9 != 0) 
#line 6627 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_71_resource_1,ldv_71_ldv_param_1_2,ldv_71_ldv_param_2_3);
    else {
      
#line 6633 
      ldv_71_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 6634 
      ldv_71_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 6639 
      ldv_emg_wrapper_pwr_power_save_off_read_3(ldv_71_resource_1,ldv_71_ldv_param_1_4,ldv_71_size_cnt,ldv_71_ldv_param_3_5);
      
#line 6643 
      ldv_free((void *)ldv_71_ldv_param_3_5);
      
#line 6644 
      ldv_free((void *)ldv_71_ldv_param_1_4);
    }
    
#line 6648 
    goto ldv_31055;
    default: 
#line 6650 
    ;
    
#line 6650 
    __VERIFIER_assume(0);
  }
  ldv_31055: 
#line 6659 
  ;
  
#line 6659 
  goto ldv_call_71;
  
#line 6661 
  __retres = (void *)0;
  return_label: 
#line 6661 
                return __retres;
}


#line 6666  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_80(void *arg0)
{
  void *__retres;
  struct file *ldv_80_resource_1;
  int ldv_80_ldv_param_2_3;
  long long ldv_80_ldv_param_1_2;
  char *ldv_80_ldv_param_1_4;
  struct inode *ldv_80_resource_0;
  unsigned long ldv_80_size_cnt;
  long long *ldv_80_ldv_param_3_5;
  char *ldv_80_ldv_param_1_6;
  long long *ldv_80_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 6677 
  struct file_operations *ldv_80_container = ldv_emg_alias_event_heart_beat_ops_2;
  
#line 6678 
  int ldv_80_ret = ldv_undef_int();
  
#line 6681 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 6685 
  ldv_80_ret = ldv_undef_int();
  
#line 6688 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 6689 
    ldv_80_container = data->arg0;
    
#line 6690 
    ldv_free((void *)data);
  }
  else ;
  
#line 6695 
  ldv_80_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 6696 
  tmp_1 = ldv_undef_int();
  
#line 6696 
  ldv_80_size_cnt = (unsigned long)tmp_1;
  
#line 6703 
  goto ldv_main_80;
  
#line 6705 
  __retres = (void *)0;
  
#line 6705 
  goto return_label;
  ldv_main_80: 
#line 6708 
  ;
  
#line 6711 
  tmp_3 = ldv_undef_int();
  
#line 6711 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 6714 
    ldv_80_ret = (*ldv_emg_alias_simple_open_5)(ldv_80_resource_0,ldv_80_resource_1);
    
#line 6716 
    ldv_80_ret = ldv_filter_err_code(ldv_80_ret);
    
#line 6719 
    tmp_2 = ldv_undef_int();
    
#line 6719 
    if (tmp_2 != 0) {
      
#line 6721 
      __VERIFIER_assume(ldv_80_ret == 0);
      
#line 6728 
      goto ldv_call_80;
    }
    else {
      
#line 6732 
      __VERIFIER_assume(ldv_80_ret != 0);
      
#line 6739 
      goto ldv_main_80;
    }
  }
  else {
    
#line 6744 
    ldv_free((void *)ldv_80_resource_0);
    
#line 6752 
    __retres = (void *)0;
    
#line 6752 
    goto return_label;
  }
  
#line 6755 
  __retres = (void *)0;
  
#line 6755 
  goto return_label;
  ldv_call_80: 
#line 6758 
  ;
  
#line 6761 
  tmp_4 = ldv_undef_int();
  
#line 6761 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 6762 
    ;
    
#line 6764 
    ldv_80_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 6765 
    ldv_80_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 6769 
    if (ldv_80_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 6775 
      __VERIFIER_assume(ldv_80_size_cnt <= 2147479552UL);
      
#line 6777 
      (*(ldv_80_container->write))(ldv_80_resource_1,(char const *)ldv_80_ldv_param_1_6,ldv_80_size_cnt,ldv_80_ldv_param_3_7);
    }
    else ;
    
#line 6782 
    ldv_free((void *)ldv_80_ldv_param_3_7);
    
#line 6783 
    ldv_free((void *)ldv_80_ldv_param_1_6);
    
#line 6790 
    goto ldv_call_80;
    case 2: 
#line 6793 
    ;
    
#line 6795 
    if (ldv_80_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 6797 
      (*(ldv_80_container->release))(ldv_80_resource_0,ldv_80_resource_1); else ;
    
#line 6805 
    goto ldv_main_80;
    case 3: 
#line 6808 
    ;
    
#line 6812 
    tmp_9 = ldv_undef_int();
    
#line 6812 
    if (tmp_9 != 0) 
#line 6815 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_80_resource_1,ldv_80_ldv_param_1_2,ldv_80_ldv_param_2_3);
    else {
      
#line 6821 
      ldv_80_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 6822 
      ldv_80_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 6827 
      ldv_emg_wrapper_event_heart_beat_read_3(ldv_80_resource_1,ldv_80_ldv_param_1_4,ldv_80_size_cnt,ldv_80_ldv_param_3_5);
      
#line 6831 
      ldv_free((void *)ldv_80_ldv_param_1_4);
      
#line 6832 
      ldv_free((void *)ldv_80_ldv_param_3_5);
    }
    
#line 6836 
    goto ldv_31077;
    default: 
#line 6838 
    ;
    
#line 6838 
    __VERIFIER_assume(0);
  }
  ldv_31077: 
#line 6847 
  ;
  
#line 6847 
  goto ldv_call_80;
  
#line 6849 
  __retres = (void *)0;
  return_label: 
#line 6849 
                return __retres;
}


#line 6854  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_18(void *arg0)
{
  void *__retres;
  struct file *ldv_18_resource_1;
  int ldv_18_ldv_param_2_3;
  long long ldv_18_ldv_param_1_2;
  char *ldv_18_ldv_param_1_4;
  struct inode *ldv_18_resource_0;
  unsigned long ldv_18_size_cnt;
  long long *ldv_18_ldv_param_3_5;
  char *ldv_18_ldv_param_1_6;
  long long *ldv_18_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 6865 
  struct file_operations *ldv_18_container = ldv_emg_alias_dma_tx_requested_ops_2;
  
#line 6866 
  int ldv_18_ret = ldv_undef_int();
  
#line 6869 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 6873 
  ldv_18_ret = ldv_undef_int();
  
#line 6876 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 6877 
    ldv_18_container = data->arg0;
    
#line 6878 
    ldv_free((void *)data);
  }
  else ;
  
#line 6883 
  ldv_18_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 6884 
  tmp_1 = ldv_undef_int();
  
#line 6884 
  ldv_18_size_cnt = (unsigned long)tmp_1;
  
#line 6891 
  goto ldv_main_18;
  
#line 6893 
  __retres = (void *)0;
  
#line 6893 
  goto return_label;
  ldv_main_18: 
#line 6896 
  ;
  
#line 6899 
  tmp_3 = ldv_undef_int();
  
#line 6899 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 6902 
    ldv_18_ret = (*ldv_emg_alias_simple_open_5)(ldv_18_resource_0,ldv_18_resource_1);
    
#line 6904 
    ldv_18_ret = ldv_filter_err_code(ldv_18_ret);
    
#line 6907 
    tmp_2 = ldv_undef_int();
    
#line 6907 
    if (tmp_2 != 0) {
      
#line 6909 
      __VERIFIER_assume(ldv_18_ret == 0);
      
#line 6916 
      goto ldv_call_18;
    }
    else {
      
#line 6920 
      __VERIFIER_assume(ldv_18_ret != 0);
      
#line 6927 
      goto ldv_main_18;
    }
  }
  else {
    
#line 6932 
    ldv_free((void *)ldv_18_resource_0);
    
#line 6940 
    __retres = (void *)0;
    
#line 6940 
    goto return_label;
  }
  
#line 6943 
  __retres = (void *)0;
  
#line 6943 
  goto return_label;
  ldv_call_18: 
#line 6946 
  ;
  
#line 6949 
  tmp_4 = ldv_undef_int();
  
#line 6949 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 6950 
    ;
    
#line 6952 
    ldv_18_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 6953 
    ldv_18_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 6957 
    if (ldv_18_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 6963 
      __VERIFIER_assume(ldv_18_size_cnt <= 2147479552UL);
      
#line 6965 
      (*(ldv_18_container->write))(ldv_18_resource_1,(char const *)ldv_18_ldv_param_1_6,ldv_18_size_cnt,ldv_18_ldv_param_3_7);
    }
    else ;
    
#line 6970 
    ldv_free((void *)ldv_18_ldv_param_3_7);
    
#line 6971 
    ldv_free((void *)ldv_18_ldv_param_1_6);
    
#line 6978 
    goto ldv_call_18;
    case 2: 
#line 6981 
    ;
    
#line 6983 
    if (ldv_18_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 6985 
      (*(ldv_18_container->release))(ldv_18_resource_0,ldv_18_resource_1); else ;
    
#line 6993 
    goto ldv_main_18;
    case 3: 
#line 6996 
    ;
    
#line 7000 
    tmp_9 = ldv_undef_int();
    
#line 7000 
    if (tmp_9 != 0) 
#line 7003 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_18_resource_1,ldv_18_ldv_param_1_2,ldv_18_ldv_param_2_3);
    else {
      
#line 7009 
      ldv_18_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 7010 
      ldv_18_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 7015 
      ldv_emg_wrapper_dma_tx_requested_read_3(ldv_18_resource_1,ldv_18_ldv_param_1_4,ldv_18_size_cnt,ldv_18_ldv_param_3_5);
      
#line 7019 
      ldv_free((void *)ldv_18_ldv_param_3_5);
      
#line 7020 
      ldv_free((void *)ldv_18_ldv_param_1_4);
    }
    
#line 7024 
    goto ldv_31099;
    default: 
#line 7026 
    ;
    
#line 7026 
    __VERIFIER_assume(0);
  }
  ldv_31099: 
#line 7035 
  ;
  
#line 7035 
  goto ldv_call_18;
  
#line 7037 
  __retres = (void *)0;
  return_label: 
#line 7037 
                return __retres;
}


#line 7042  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_77(void *arg0)
{
  void *__retres;
  struct file *ldv_77_resource_1;
  int ldv_77_ldv_param_2_3;
  long long ldv_77_ldv_param_1_2;
  char *ldv_77_ldv_param_1_4;
  struct inode *ldv_77_resource_0;
  unsigned long ldv_77_size_cnt;
  long long *ldv_77_ldv_param_3_5;
  char *ldv_77_ldv_param_1_6;
  long long *ldv_77_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 7053 
  struct file_operations *ldv_77_container = ldv_emg_alias_isr_fiqs_ops_2;
  
#line 7054 
  int ldv_77_ret = ldv_undef_int();
  
#line 7057 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 7061 
  ldv_77_ret = ldv_undef_int();
  
#line 7064 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 7065 
    ldv_77_container = data->arg0;
    
#line 7066 
    ldv_free((void *)data);
  }
  else ;
  
#line 7071 
  ldv_77_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 7072 
  tmp_1 = ldv_undef_int();
  
#line 7072 
  ldv_77_size_cnt = (unsigned long)tmp_1;
  
#line 7079 
  goto ldv_main_77;
  
#line 7081 
  __retres = (void *)0;
  
#line 7081 
  goto return_label;
  ldv_main_77: 
#line 7084 
  ;
  
#line 7087 
  tmp_3 = ldv_undef_int();
  
#line 7087 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 7090 
    ldv_77_ret = (*ldv_emg_alias_simple_open_5)(ldv_77_resource_0,ldv_77_resource_1);
    
#line 7092 
    ldv_77_ret = ldv_filter_err_code(ldv_77_ret);
    
#line 7095 
    tmp_2 = ldv_undef_int();
    
#line 7095 
    if (tmp_2 != 0) {
      
#line 7097 
      __VERIFIER_assume(ldv_77_ret == 0);
      
#line 7104 
      goto ldv_call_77;
    }
    else {
      
#line 7108 
      __VERIFIER_assume(ldv_77_ret != 0);
      
#line 7115 
      goto ldv_main_77;
    }
  }
  else {
    
#line 7120 
    ldv_free((void *)ldv_77_resource_0);
    
#line 7128 
    __retres = (void *)0;
    
#line 7128 
    goto return_label;
  }
  
#line 7131 
  __retres = (void *)0;
  
#line 7131 
  goto return_label;
  ldv_call_77: 
#line 7134 
  ;
  
#line 7137 
  tmp_4 = ldv_undef_int();
  
#line 7137 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 7138 
    ;
    
#line 7140 
    ldv_77_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 7141 
    ldv_77_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 7145 
    if (ldv_77_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 7151 
      __VERIFIER_assume(ldv_77_size_cnt <= 2147479552UL);
      
#line 7153 
      (*(ldv_77_container->write))(ldv_77_resource_1,(char const *)ldv_77_ldv_param_1_6,ldv_77_size_cnt,ldv_77_ldv_param_3_7);
    }
    else ;
    
#line 7158 
    ldv_free((void *)ldv_77_ldv_param_1_6);
    
#line 7159 
    ldv_free((void *)ldv_77_ldv_param_3_7);
    
#line 7166 
    goto ldv_call_77;
    case 2: 
#line 7169 
    ;
    
#line 7171 
    if (ldv_77_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 7173 
      (*(ldv_77_container->release))(ldv_77_resource_0,ldv_77_resource_1); else ;
    
#line 7181 
    goto ldv_main_77;
    case 3: 
#line 7184 
    ;
    
#line 7188 
    tmp_9 = ldv_undef_int();
    
#line 7188 
    if (tmp_9 != 0) 
#line 7191 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_77_resource_1,ldv_77_ldv_param_1_2,ldv_77_ldv_param_2_3);
    else {
      
#line 7197 
      ldv_77_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 7198 
      ldv_77_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 7203 
      ldv_emg_wrapper_isr_fiqs_read_3(ldv_77_resource_1,ldv_77_ldv_param_1_4,ldv_77_size_cnt,ldv_77_ldv_param_3_5);
      
#line 7207 
      ldv_free((void *)ldv_77_ldv_param_3_5);
      
#line 7208 
      ldv_free((void *)ldv_77_ldv_param_1_4);
    }
    
#line 7212 
    goto ldv_31121;
    default: 
#line 7214 
    ;
    
#line 7214 
    __VERIFIER_assume(0);
  }
  ldv_31121: 
#line 7223 
  ;
  
#line 7223 
  goto ldv_call_77;
  
#line 7225 
  __retres = (void *)0;
  return_label: 
#line 7225 
                return __retres;
}


#line 7230  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_13(void *arg0)
{
  void *__retres;
  struct file *ldv_13_resource_1;
  int ldv_13_ldv_param_2_3;
  long long ldv_13_ldv_param_1_2;
  char *ldv_13_ldv_param_1_4;
  struct inode *ldv_13_resource_0;
  unsigned long ldv_13_size_cnt;
  long long *ldv_13_ldv_param_3_5;
  char *ldv_13_ldv_param_1_6;
  long long *ldv_13_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 7241 
  struct file_operations *ldv_13_container = ldv_emg_alias_pwr_enable_ps_ops_2;
  
#line 7242 
  int ldv_13_ret = ldv_undef_int();
  
#line 7245 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 7249 
  ldv_13_ret = ldv_undef_int();
  
#line 7252 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 7253 
    ldv_13_container = data->arg0;
    
#line 7254 
    ldv_free((void *)data);
  }
  else ;
  
#line 7259 
  ldv_13_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 7260 
  tmp_1 = ldv_undef_int();
  
#line 7260 
  ldv_13_size_cnt = (unsigned long)tmp_1;
  
#line 7267 
  goto ldv_main_13;
  
#line 7269 
  __retres = (void *)0;
  
#line 7269 
  goto return_label;
  ldv_main_13: 
#line 7272 
  ;
  
#line 7275 
  tmp_3 = ldv_undef_int();
  
#line 7275 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 7278 
    ldv_13_ret = (*ldv_emg_alias_simple_open_5)(ldv_13_resource_0,ldv_13_resource_1);
    
#line 7280 
    ldv_13_ret = ldv_filter_err_code(ldv_13_ret);
    
#line 7283 
    tmp_2 = ldv_undef_int();
    
#line 7283 
    if (tmp_2 != 0) {
      
#line 7285 
      __VERIFIER_assume(ldv_13_ret == 0);
      
#line 7292 
      goto ldv_call_13;
    }
    else {
      
#line 7296 
      __VERIFIER_assume(ldv_13_ret != 0);
      
#line 7303 
      goto ldv_main_13;
    }
  }
  else {
    
#line 7308 
    ldv_free((void *)ldv_13_resource_0);
    
#line 7316 
    __retres = (void *)0;
    
#line 7316 
    goto return_label;
  }
  
#line 7319 
  __retres = (void *)0;
  
#line 7319 
  goto return_label;
  ldv_call_13: 
#line 7322 
  ;
  
#line 7325 
  tmp_4 = ldv_undef_int();
  
#line 7325 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 7326 
    ;
    
#line 7328 
    ldv_13_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 7329 
    ldv_13_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 7333 
    if (ldv_13_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 7339 
      __VERIFIER_assume(ldv_13_size_cnt <= 2147479552UL);
      
#line 7341 
      (*(ldv_13_container->write))(ldv_13_resource_1,(char const *)ldv_13_ldv_param_1_6,ldv_13_size_cnt,ldv_13_ldv_param_3_7);
    }
    else ;
    
#line 7346 
    ldv_free((void *)ldv_13_ldv_param_3_7);
    
#line 7347 
    ldv_free((void *)ldv_13_ldv_param_1_6);
    
#line 7354 
    goto ldv_call_13;
    case 2: 
#line 7357 
    ;
    
#line 7359 
    if (ldv_13_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 7361 
      (*(ldv_13_container->release))(ldv_13_resource_0,ldv_13_resource_1); else ;
    
#line 7369 
    goto ldv_main_13;
    case 3: 
#line 7372 
    ;
    
#line 7376 
    tmp_9 = ldv_undef_int();
    
#line 7376 
    if (tmp_9 != 0) 
#line 7379 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_13_resource_1,ldv_13_ldv_param_1_2,ldv_13_ldv_param_2_3);
    else {
      
#line 7385 
      ldv_13_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 7386 
      ldv_13_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 7391 
      ldv_emg_wrapper_pwr_enable_ps_read_3(ldv_13_resource_1,ldv_13_ldv_param_1_4,ldv_13_size_cnt,ldv_13_ldv_param_3_5);
      
#line 7395 
      ldv_free((void *)ldv_13_ldv_param_3_5);
      
#line 7396 
      ldv_free((void *)ldv_13_ldv_param_1_4);
    }
    
#line 7400 
    goto ldv_31143;
    default: 
#line 7402 
    ;
    
#line 7402 
    __VERIFIER_assume(0);
  }
  ldv_31143: 
#line 7411 
  ;
  
#line 7411 
  goto ldv_call_13;
  
#line 7413 
  __retres = (void *)0;
  return_label: 
#line 7413 
                return __retres;
}


#line 7418  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_32(void *arg0)
{
  void *__retres;
  struct file *ldv_32_resource_1;
  int ldv_32_ldv_param_2_3;
  long long ldv_32_ldv_param_1_2;
  char *ldv_32_ldv_param_1_4;
  struct inode *ldv_32_resource_0;
  unsigned long ldv_32_size_cnt;
  long long *ldv_32_ldv_param_3_5;
  char *ldv_32_ldv_param_1_6;
  long long *ldv_32_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 7429 
  struct file_operations *ldv_32_container = ldv_emg_alias_ps_upsd_max_sptime_ops_2;
  
#line 7430 
  int ldv_32_ret = ldv_undef_int();
  
#line 7433 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 7437 
  ldv_32_ret = ldv_undef_int();
  
#line 7440 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 7441 
    ldv_32_container = data->arg0;
    
#line 7442 
    ldv_free((void *)data);
  }
  else ;
  
#line 7447 
  ldv_32_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 7448 
  tmp_1 = ldv_undef_int();
  
#line 7448 
  ldv_32_size_cnt = (unsigned long)tmp_1;
  
#line 7455 
  goto ldv_main_32;
  
#line 7457 
  __retres = (void *)0;
  
#line 7457 
  goto return_label;
  ldv_main_32: 
#line 7460 
  ;
  
#line 7463 
  tmp_3 = ldv_undef_int();
  
#line 7463 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 7466 
    ldv_32_ret = (*ldv_emg_alias_simple_open_5)(ldv_32_resource_0,ldv_32_resource_1);
    
#line 7468 
    ldv_32_ret = ldv_filter_err_code(ldv_32_ret);
    
#line 7471 
    tmp_2 = ldv_undef_int();
    
#line 7471 
    if (tmp_2 != 0) {
      
#line 7473 
      __VERIFIER_assume(ldv_32_ret == 0);
      
#line 7480 
      goto ldv_call_32;
    }
    else {
      
#line 7484 
      __VERIFIER_assume(ldv_32_ret != 0);
      
#line 7491 
      goto ldv_main_32;
    }
  }
  else {
    
#line 7496 
    ldv_free((void *)ldv_32_resource_0);
    
#line 7504 
    __retres = (void *)0;
    
#line 7504 
    goto return_label;
  }
  
#line 7507 
  __retres = (void *)0;
  
#line 7507 
  goto return_label;
  ldv_call_32: 
#line 7510 
  ;
  
#line 7513 
  tmp_4 = ldv_undef_int();
  
#line 7513 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 7514 
    ;
    
#line 7516 
    ldv_32_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 7517 
    ldv_32_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 7521 
    if (ldv_32_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 7527 
      __VERIFIER_assume(ldv_32_size_cnt <= 2147479552UL);
      
#line 7529 
      (*(ldv_32_container->write))(ldv_32_resource_1,(char const *)ldv_32_ldv_param_1_6,ldv_32_size_cnt,ldv_32_ldv_param_3_7);
    }
    else ;
    
#line 7534 
    ldv_free((void *)ldv_32_ldv_param_1_6);
    
#line 7535 
    ldv_free((void *)ldv_32_ldv_param_3_7);
    
#line 7542 
    goto ldv_call_32;
    case 2: 
#line 7545 
    ;
    
#line 7547 
    if (ldv_32_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 7549 
      (*(ldv_32_container->release))(ldv_32_resource_0,ldv_32_resource_1); else ;
    
#line 7557 
    goto ldv_main_32;
    case 3: 
#line 7560 
    ;
    
#line 7564 
    tmp_9 = ldv_undef_int();
    
#line 7564 
    if (tmp_9 != 0) 
#line 7567 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_32_resource_1,ldv_32_ldv_param_1_2,ldv_32_ldv_param_2_3);
    else {
      
#line 7573 
      ldv_32_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 7574 
      ldv_32_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 7579 
      ldv_emg_wrapper_ps_upsd_max_sptime_read_3(ldv_32_resource_1,ldv_32_ldv_param_1_4,ldv_32_size_cnt,ldv_32_ldv_param_3_5);
      
#line 7583 
      ldv_free((void *)ldv_32_ldv_param_3_5);
      
#line 7584 
      ldv_free((void *)ldv_32_ldv_param_1_4);
    }
    
#line 7588 
    goto ldv_31165;
    default: 
#line 7590 
    ;
    
#line 7590 
    __VERIFIER_assume(0);
  }
  ldv_31165: 
#line 7599 
  ;
  
#line 7599 
  goto ldv_call_32;
  
#line 7601 
  __retres = (void *)0;
  return_label: 
#line 7601 
                return __retres;
}


#line 7606  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_24(void *arg0)
{
  void *__retres;
  struct file *ldv_24_resource_1;
  int ldv_24_ldv_param_2_3;
  long long ldv_24_ldv_param_1_2;
  char *ldv_24_ldv_param_1_4;
  struct inode *ldv_24_resource_0;
  unsigned long ldv_24_size_cnt;
  long long *ldv_24_ldv_param_3_5;
  char *ldv_24_ldv_param_1_6;
  long long *ldv_24_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 7617 
  struct file_operations *ldv_24_container = ldv_emg_alias_pwr_rcvd_beacons_ops_2;
  
#line 7618 
  int ldv_24_ret = ldv_undef_int();
  
#line 7621 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 7625 
  ldv_24_ret = ldv_undef_int();
  
#line 7628 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 7629 
    ldv_24_container = data->arg0;
    
#line 7630 
    ldv_free((void *)data);
  }
  else ;
  
#line 7635 
  ldv_24_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 7636 
  tmp_1 = ldv_undef_int();
  
#line 7636 
  ldv_24_size_cnt = (unsigned long)tmp_1;
  
#line 7643 
  goto ldv_main_24;
  
#line 7645 
  __retres = (void *)0;
  
#line 7645 
  goto return_label;
  ldv_main_24: 
#line 7648 
  ;
  
#line 7651 
  tmp_3 = ldv_undef_int();
  
#line 7651 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 7654 
    ldv_24_ret = (*ldv_emg_alias_simple_open_5)(ldv_24_resource_0,ldv_24_resource_1);
    
#line 7656 
    ldv_24_ret = ldv_filter_err_code(ldv_24_ret);
    
#line 7659 
    tmp_2 = ldv_undef_int();
    
#line 7659 
    if (tmp_2 != 0) {
      
#line 7661 
      __VERIFIER_assume(ldv_24_ret == 0);
      
#line 7668 
      goto ldv_call_24;
    }
    else {
      
#line 7672 
      __VERIFIER_assume(ldv_24_ret != 0);
      
#line 7679 
      goto ldv_main_24;
    }
  }
  else {
    
#line 7684 
    ldv_free((void *)ldv_24_resource_0);
    
#line 7692 
    __retres = (void *)0;
    
#line 7692 
    goto return_label;
  }
  
#line 7695 
  __retres = (void *)0;
  
#line 7695 
  goto return_label;
  ldv_call_24: 
#line 7698 
  ;
  
#line 7701 
  tmp_4 = ldv_undef_int();
  
#line 7701 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 7702 
    ;
    
#line 7704 
    ldv_24_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 7705 
    ldv_24_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 7709 
    if (ldv_24_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 7715 
      __VERIFIER_assume(ldv_24_size_cnt <= 2147479552UL);
      
#line 7717 
      (*(ldv_24_container->write))(ldv_24_resource_1,(char const *)ldv_24_ldv_param_1_6,ldv_24_size_cnt,ldv_24_ldv_param_3_7);
    }
    else ;
    
#line 7722 
    ldv_free((void *)ldv_24_ldv_param_3_7);
    
#line 7723 
    ldv_free((void *)ldv_24_ldv_param_1_6);
    
#line 7730 
    goto ldv_call_24;
    case 2: 
#line 7733 
    ;
    
#line 7735 
    if (ldv_24_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 7737 
      (*(ldv_24_container->release))(ldv_24_resource_0,ldv_24_resource_1); else ;
    
#line 7745 
    goto ldv_main_24;
    case 3: 
#line 7748 
    ;
    
#line 7752 
    tmp_9 = ldv_undef_int();
    
#line 7752 
    if (tmp_9 != 0) 
#line 7755 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_24_resource_1,ldv_24_ldv_param_1_2,ldv_24_ldv_param_2_3);
    else {
      
#line 7761 
      ldv_24_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 7762 
      ldv_24_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 7767 
      ldv_emg_wrapper_pwr_rcvd_beacons_read_3(ldv_24_resource_1,ldv_24_ldv_param_1_4,ldv_24_size_cnt,ldv_24_ldv_param_3_5);
      
#line 7771 
      ldv_free((void *)ldv_24_ldv_param_3_5);
      
#line 7772 
      ldv_free((void *)ldv_24_ldv_param_1_4);
    }
    
#line 7776 
    goto ldv_31187;
    default: 
#line 7778 
    ;
    
#line 7778 
    __VERIFIER_assume(0);
  }
  ldv_31187: 
#line 7787 
  ;
  
#line 7787 
  goto ldv_call_24;
  
#line 7789 
  __retres = (void *)0;
  return_label: 
#line 7789 
                return __retres;
}


#line 7794  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_8(void *arg0)
{
  void *__retres;
  struct file *ldv_8_resource_1;
  int ldv_8_ldv_param_2_3;
  long long ldv_8_ldv_param_1_2;
  char *ldv_8_ldv_param_1_4;
  struct inode *ldv_8_resource_0;
  unsigned long ldv_8_size_cnt;
  long long *ldv_8_ldv_param_3_5;
  char *ldv_8_ldv_param_1_6;
  long long *ldv_8_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 7805 
  struct file_operations *ldv_8_container = ldv_emg_alias_isr_host_acknowledges_ops_2;
  
#line 7806 
  int ldv_8_ret = ldv_undef_int();
  
#line 7809 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 7813 
  ldv_8_ret = ldv_undef_int();
  
#line 7816 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 7817 
    ldv_8_container = data->arg0;
    
#line 7818 
    ldv_free((void *)data);
  }
  else ;
  
#line 7823 
  ldv_8_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 7824 
  tmp_1 = ldv_undef_int();
  
#line 7824 
  ldv_8_size_cnt = (unsigned long)tmp_1;
  
#line 7831 
  goto ldv_main_8;
  
#line 7833 
  __retres = (void *)0;
  
#line 7833 
  goto return_label;
  ldv_main_8: 
#line 7836 
  ;
  
#line 7839 
  tmp_3 = ldv_undef_int();
  
#line 7839 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 7842 
    ldv_8_ret = (*ldv_emg_alias_simple_open_5)(ldv_8_resource_0,ldv_8_resource_1);
    
#line 7844 
    ldv_8_ret = ldv_filter_err_code(ldv_8_ret);
    
#line 7847 
    tmp_2 = ldv_undef_int();
    
#line 7847 
    if (tmp_2 != 0) {
      
#line 7849 
      __VERIFIER_assume(ldv_8_ret == 0);
      
#line 7856 
      goto ldv_call_8;
    }
    else {
      
#line 7860 
      __VERIFIER_assume(ldv_8_ret != 0);
      
#line 7867 
      goto ldv_main_8;
    }
  }
  else {
    
#line 7872 
    ldv_free((void *)ldv_8_resource_0);
    
#line 7880 
    __retres = (void *)0;
    
#line 7880 
    goto return_label;
  }
  
#line 7883 
  __retres = (void *)0;
  
#line 7883 
  goto return_label;
  ldv_call_8: 
#line 7886 
  ;
  
#line 7889 
  tmp_4 = ldv_undef_int();
  
#line 7889 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 7890 
    ;
    
#line 7892 
    ldv_8_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 7893 
    ldv_8_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 7897 
    if (ldv_8_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 7903 
      __VERIFIER_assume(ldv_8_size_cnt <= 2147479552UL);
      
#line 7905 
      (*(ldv_8_container->write))(ldv_8_resource_1,(char const *)ldv_8_ldv_param_1_6,ldv_8_size_cnt,ldv_8_ldv_param_3_7);
    }
    else ;
    
#line 7910 
    ldv_free((void *)ldv_8_ldv_param_1_6);
    
#line 7911 
    ldv_free((void *)ldv_8_ldv_param_3_7);
    
#line 7918 
    goto ldv_call_8;
    case 2: 
#line 7921 
    ;
    
#line 7923 
    if (ldv_8_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 7925 
      (*(ldv_8_container->release))(ldv_8_resource_0,ldv_8_resource_1); else ;
    
#line 7933 
    goto ldv_main_8;
    case 3: 
#line 7936 
    ;
    
#line 7940 
    tmp_9 = ldv_undef_int();
    
#line 7940 
    if (tmp_9 != 0) 
#line 7943 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_8_resource_1,ldv_8_ldv_param_1_2,ldv_8_ldv_param_2_3);
    else {
      
#line 7949 
      ldv_8_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 7950 
      ldv_8_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 7955 
      ldv_emg_wrapper_isr_host_acknowledges_read_3(ldv_8_resource_1,ldv_8_ldv_param_1_4,ldv_8_size_cnt,ldv_8_ldv_param_3_5);
      
#line 7959 
      ldv_free((void *)ldv_8_ldv_param_3_5);
      
#line 7960 
      ldv_free((void *)ldv_8_ldv_param_1_4);
    }
    
#line 7964 
    goto ldv_31209;
    default: 
#line 7966 
    ;
    
#line 7966 
    __VERIFIER_assume(0);
  }
  ldv_31209: 
#line 7975 
  ;
  
#line 7975 
  goto ldv_call_8;
  
#line 7977 
  __retres = (void *)0;
  return_label: 
#line 7977 
                return __retres;
}


#line 7982  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_59(void *arg0)
{
  void *__retres;
  struct file *ldv_59_resource_1;
  int ldv_59_ldv_param_2_3;
  long long ldv_59_ldv_param_1_2;
  char *ldv_59_ldv_param_1_4;
  struct inode *ldv_59_resource_0;
  unsigned long ldv_59_size_cnt;
  long long *ldv_59_ldv_param_3_5;
  char *ldv_59_ldv_param_1_6;
  long long *ldv_59_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 7993 
  struct file_operations *ldv_59_container = ldv_emg_alias_pwr_wake_on_host_ops_2;
  
#line 7994 
  int ldv_59_ret = ldv_undef_int();
  
#line 7997 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 8001 
  ldv_59_ret = ldv_undef_int();
  
#line 8004 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 8005 
    ldv_59_container = data->arg0;
    
#line 8006 
    ldv_free((void *)data);
  }
  else ;
  
#line 8011 
  ldv_59_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 8012 
  tmp_1 = ldv_undef_int();
  
#line 8012 
  ldv_59_size_cnt = (unsigned long)tmp_1;
  
#line 8019 
  goto ldv_main_59;
  
#line 8021 
  __retres = (void *)0;
  
#line 8021 
  goto return_label;
  ldv_main_59: 
#line 8024 
  ;
  
#line 8027 
  tmp_3 = ldv_undef_int();
  
#line 8027 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 8030 
    ldv_59_ret = (*ldv_emg_alias_simple_open_5)(ldv_59_resource_0,ldv_59_resource_1);
    
#line 8032 
    ldv_59_ret = ldv_filter_err_code(ldv_59_ret);
    
#line 8035 
    tmp_2 = ldv_undef_int();
    
#line 8035 
    if (tmp_2 != 0) {
      
#line 8037 
      __VERIFIER_assume(ldv_59_ret == 0);
      
#line 8044 
      goto ldv_call_59;
    }
    else {
      
#line 8048 
      __VERIFIER_assume(ldv_59_ret != 0);
      
#line 8055 
      goto ldv_main_59;
    }
  }
  else {
    
#line 8060 
    ldv_free((void *)ldv_59_resource_0);
    
#line 8068 
    __retres = (void *)0;
    
#line 8068 
    goto return_label;
  }
  
#line 8071 
  __retres = (void *)0;
  
#line 8071 
  goto return_label;
  ldv_call_59: 
#line 8074 
  ;
  
#line 8077 
  tmp_4 = ldv_undef_int();
  
#line 8077 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 8078 
    ;
    
#line 8080 
    ldv_59_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 8081 
    ldv_59_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 8085 
    if (ldv_59_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 8091 
      __VERIFIER_assume(ldv_59_size_cnt <= 2147479552UL);
      
#line 8093 
      (*(ldv_59_container->write))(ldv_59_resource_1,(char const *)ldv_59_ldv_param_1_6,ldv_59_size_cnt,ldv_59_ldv_param_3_7);
    }
    else ;
    
#line 8098 
    ldv_free((void *)ldv_59_ldv_param_3_7);
    
#line 8099 
    ldv_free((void *)ldv_59_ldv_param_1_6);
    
#line 8106 
    goto ldv_call_59;
    case 2: 
#line 8109 
    ;
    
#line 8111 
    if (ldv_59_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 8113 
      (*(ldv_59_container->release))(ldv_59_resource_0,ldv_59_resource_1); else ;
    
#line 8121 
    goto ldv_main_59;
    case 3: 
#line 8124 
    ;
    
#line 8128 
    tmp_9 = ldv_undef_int();
    
#line 8128 
    if (tmp_9 != 0) 
#line 8131 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_59_resource_1,ldv_59_ldv_param_1_2,ldv_59_ldv_param_2_3);
    else {
      
#line 8137 
      ldv_59_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 8138 
      ldv_59_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 8143 
      ldv_emg_wrapper_pwr_wake_on_host_read_3(ldv_59_resource_1,ldv_59_ldv_param_1_4,ldv_59_size_cnt,ldv_59_ldv_param_3_5);
      
#line 8147 
      ldv_free((void *)ldv_59_ldv_param_1_4);
      
#line 8148 
      ldv_free((void *)ldv_59_ldv_param_3_5);
    }
    
#line 8152 
    goto ldv_31231;
    default: 
#line 8154 
    ;
    
#line 8154 
    __VERIFIER_assume(0);
  }
  ldv_31231: 
#line 8163 
  ;
  
#line 8163 
  goto ldv_call_59;
  
#line 8165 
  __retres = (void *)0;
  return_label: 
#line 8165 
                return __retres;
}


#line 8170  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_31(void *arg0)
{
  void *__retres;
  struct file *ldv_31_resource_1;
  int ldv_31_ldv_param_2_3;
  long long ldv_31_ldv_param_1_2;
  char *ldv_31_ldv_param_1_4;
  struct inode *ldv_31_resource_0;
  unsigned long ldv_31_size_cnt;
  long long *ldv_31_ldv_param_3_5;
  char *ldv_31_ldv_param_1_6;
  long long *ldv_31_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 8181 
  struct file_operations *ldv_31_container = ldv_emg_alias_isr_tx_procs_ops_2;
  
#line 8182 
  int ldv_31_ret = ldv_undef_int();
  
#line 8185 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 8189 
  ldv_31_ret = ldv_undef_int();
  
#line 8192 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 8193 
    ldv_31_container = data->arg0;
    
#line 8194 
    ldv_free((void *)data);
  }
  else ;
  
#line 8199 
  ldv_31_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 8200 
  tmp_1 = ldv_undef_int();
  
#line 8200 
  ldv_31_size_cnt = (unsigned long)tmp_1;
  
#line 8207 
  goto ldv_main_31;
  
#line 8209 
  __retres = (void *)0;
  
#line 8209 
  goto return_label;
  ldv_main_31: 
#line 8212 
  ;
  
#line 8215 
  tmp_3 = ldv_undef_int();
  
#line 8215 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 8218 
    ldv_31_ret = (*ldv_emg_alias_simple_open_5)(ldv_31_resource_0,ldv_31_resource_1);
    
#line 8220 
    ldv_31_ret = ldv_filter_err_code(ldv_31_ret);
    
#line 8223 
    tmp_2 = ldv_undef_int();
    
#line 8223 
    if (tmp_2 != 0) {
      
#line 8225 
      __VERIFIER_assume(ldv_31_ret == 0);
      
#line 8232 
      goto ldv_call_31;
    }
    else {
      
#line 8236 
      __VERIFIER_assume(ldv_31_ret != 0);
      
#line 8243 
      goto ldv_main_31;
    }
  }
  else {
    
#line 8248 
    ldv_free((void *)ldv_31_resource_0);
    
#line 8256 
    __retres = (void *)0;
    
#line 8256 
    goto return_label;
  }
  
#line 8259 
  __retres = (void *)0;
  
#line 8259 
  goto return_label;
  ldv_call_31: 
#line 8262 
  ;
  
#line 8265 
  tmp_4 = ldv_undef_int();
  
#line 8265 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 8266 
    ;
    
#line 8268 
    ldv_31_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 8269 
    ldv_31_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 8273 
    if (ldv_31_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 8279 
      __VERIFIER_assume(ldv_31_size_cnt <= 2147479552UL);
      
#line 8281 
      (*(ldv_31_container->write))(ldv_31_resource_1,(char const *)ldv_31_ldv_param_1_6,ldv_31_size_cnt,ldv_31_ldv_param_3_7);
    }
    else ;
    
#line 8286 
    ldv_free((void *)ldv_31_ldv_param_3_7);
    
#line 8287 
    ldv_free((void *)ldv_31_ldv_param_1_6);
    
#line 8294 
    goto ldv_call_31;
    case 2: 
#line 8297 
    ;
    
#line 8299 
    if (ldv_31_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 8301 
      (*(ldv_31_container->release))(ldv_31_resource_0,ldv_31_resource_1); else ;
    
#line 8309 
    goto ldv_main_31;
    case 3: 
#line 8312 
    ;
    
#line 8316 
    tmp_9 = ldv_undef_int();
    
#line 8316 
    if (tmp_9 != 0) 
#line 8319 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_31_resource_1,ldv_31_ldv_param_1_2,ldv_31_ldv_param_2_3);
    else {
      
#line 8325 
      ldv_31_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 8326 
      ldv_31_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 8331 
      ldv_emg_wrapper_isr_tx_procs_read_3(ldv_31_resource_1,ldv_31_ldv_param_1_4,ldv_31_size_cnt,ldv_31_ldv_param_3_5);
      
#line 8335 
      ldv_free((void *)ldv_31_ldv_param_3_5);
      
#line 8336 
      ldv_free((void *)ldv_31_ldv_param_1_4);
    }
    
#line 8340 
    goto ldv_31253;
    default: 
#line 8342 
    ;
    
#line 8342 
    __VERIFIER_assume(0);
  }
  ldv_31253: 
#line 8351 
  ;
  
#line 8351 
  goto ldv_call_31;
  
#line 8353 
  __retres = (void *)0;
  return_label: 
#line 8353 
                return __retres;
}


#line 8358  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_52(void *arg0)
{
  void *__retres;
  struct file *ldv_52_resource_1;
  int ldv_52_ldv_param_2_3;
  long long ldv_52_ldv_param_1_2;
  char *ldv_52_ldv_param_1_4;
  struct inode *ldv_52_resource_0;
  unsigned long ldv_52_size_cnt;
  long long *ldv_52_ldv_param_3_5;
  char *ldv_52_ldv_param_1_6;
  long long *ldv_52_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 8369 
  struct file_operations *ldv_52_container = ldv_emg_alias_isr_hw_pm_mode_changes_ops_2;
  
#line 8370 
  int ldv_52_ret = ldv_undef_int();
  
#line 8373 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 8377 
  ldv_52_ret = ldv_undef_int();
  
#line 8380 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 8381 
    ldv_52_container = data->arg0;
    
#line 8382 
    ldv_free((void *)data);
  }
  else ;
  
#line 8387 
  ldv_52_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 8388 
  tmp_1 = ldv_undef_int();
  
#line 8388 
  ldv_52_size_cnt = (unsigned long)tmp_1;
  
#line 8395 
  goto ldv_main_52;
  
#line 8397 
  __retres = (void *)0;
  
#line 8397 
  goto return_label;
  ldv_main_52: 
#line 8400 
  ;
  
#line 8403 
  tmp_3 = ldv_undef_int();
  
#line 8403 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 8406 
    ldv_52_ret = (*ldv_emg_alias_simple_open_5)(ldv_52_resource_0,ldv_52_resource_1);
    
#line 8408 
    ldv_52_ret = ldv_filter_err_code(ldv_52_ret);
    
#line 8411 
    tmp_2 = ldv_undef_int();
    
#line 8411 
    if (tmp_2 != 0) {
      
#line 8413 
      __VERIFIER_assume(ldv_52_ret == 0);
      
#line 8420 
      goto ldv_call_52;
    }
    else {
      
#line 8424 
      __VERIFIER_assume(ldv_52_ret != 0);
      
#line 8431 
      goto ldv_main_52;
    }
  }
  else {
    
#line 8436 
    ldv_free((void *)ldv_52_resource_0);
    
#line 8444 
    __retres = (void *)0;
    
#line 8444 
    goto return_label;
  }
  
#line 8447 
  __retres = (void *)0;
  
#line 8447 
  goto return_label;
  ldv_call_52: 
#line 8450 
  ;
  
#line 8453 
  tmp_4 = ldv_undef_int();
  
#line 8453 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 8454 
    ;
    
#line 8456 
    ldv_52_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 8457 
    ldv_52_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 8461 
    if (ldv_52_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 8467 
      __VERIFIER_assume(ldv_52_size_cnt <= 2147479552UL);
      
#line 8469 
      (*(ldv_52_container->write))(ldv_52_resource_1,(char const *)ldv_52_ldv_param_1_6,ldv_52_size_cnt,ldv_52_ldv_param_3_7);
    }
    else ;
    
#line 8474 
    ldv_free((void *)ldv_52_ldv_param_3_7);
    
#line 8475 
    ldv_free((void *)ldv_52_ldv_param_1_6);
    
#line 8482 
    goto ldv_call_52;
    case 2: 
#line 8485 
    ;
    
#line 8487 
    if (ldv_52_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 8489 
      (*(ldv_52_container->release))(ldv_52_resource_0,ldv_52_resource_1); else ;
    
#line 8497 
    goto ldv_main_52;
    case 3: 
#line 8500 
    ;
    
#line 8504 
    tmp_9 = ldv_undef_int();
    
#line 8504 
    if (tmp_9 != 0) 
#line 8507 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_52_resource_1,ldv_52_ldv_param_1_2,ldv_52_ldv_param_2_3);
    else {
      
#line 8513 
      ldv_52_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 8514 
      ldv_52_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 8519 
      ldv_emg_wrapper_isr_hw_pm_mode_changes_read_3(ldv_52_resource_1,ldv_52_ldv_param_1_4,ldv_52_size_cnt,ldv_52_ldv_param_3_5);
      
#line 8523 
      ldv_free((void *)ldv_52_ldv_param_3_5);
      
#line 8524 
      ldv_free((void *)ldv_52_ldv_param_1_4);
    }
    
#line 8528 
    goto ldv_31275;
    default: 
#line 8530 
    ;
    
#line 8530 
    __VERIFIER_assume(0);
  }
  ldv_31275: 
#line 8539 
  ;
  
#line 8539 
  goto ldv_call_52;
  
#line 8541 
  __retres = (void *)0;
  return_label: 
#line 8541 
                return __retres;
}


#line 8546  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_63(void *arg0)
{
  void *__retres;
  struct file *ldv_63_resource_1;
  int ldv_63_ldv_param_2_3;
  long long ldv_63_ldv_param_1_2;
  char *ldv_63_ldv_param_1_4;
  struct inode *ldv_63_resource_0;
  unsigned long ldv_63_size_cnt;
  long long *ldv_63_ldv_param_3_5;
  char *ldv_63_ldv_param_1_6;
  long long *ldv_63_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 8557 
  struct file_operations *ldv_63_container = ldv_emg_alias_isr_commands_ops_2;
  
#line 8558 
  int ldv_63_ret = ldv_undef_int();
  
#line 8561 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 8565 
  ldv_63_ret = ldv_undef_int();
  
#line 8568 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 8569 
    ldv_63_container = data->arg0;
    
#line 8570 
    ldv_free((void *)data);
  }
  else ;
  
#line 8575 
  ldv_63_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 8576 
  tmp_1 = ldv_undef_int();
  
#line 8576 
  ldv_63_size_cnt = (unsigned long)tmp_1;
  
#line 8583 
  goto ldv_main_63;
  
#line 8585 
  __retres = (void *)0;
  
#line 8585 
  goto return_label;
  ldv_main_63: 
#line 8588 
  ;
  
#line 8591 
  tmp_3 = ldv_undef_int();
  
#line 8591 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 8594 
    ldv_63_ret = (*ldv_emg_alias_simple_open_5)(ldv_63_resource_0,ldv_63_resource_1);
    
#line 8596 
    ldv_63_ret = ldv_filter_err_code(ldv_63_ret);
    
#line 8599 
    tmp_2 = ldv_undef_int();
    
#line 8599 
    if (tmp_2 != 0) {
      
#line 8601 
      __VERIFIER_assume(ldv_63_ret == 0);
      
#line 8608 
      goto ldv_call_63;
    }
    else {
      
#line 8612 
      __VERIFIER_assume(ldv_63_ret != 0);
      
#line 8619 
      goto ldv_main_63;
    }
  }
  else {
    
#line 8624 
    ldv_free((void *)ldv_63_resource_0);
    
#line 8632 
    __retres = (void *)0;
    
#line 8632 
    goto return_label;
  }
  
#line 8635 
  __retres = (void *)0;
  
#line 8635 
  goto return_label;
  ldv_call_63: 
#line 8638 
  ;
  
#line 8641 
  tmp_4 = ldv_undef_int();
  
#line 8641 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 8642 
    ;
    
#line 8644 
    ldv_63_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 8645 
    ldv_63_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 8649 
    if (ldv_63_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 8655 
      __VERIFIER_assume(ldv_63_size_cnt <= 2147479552UL);
      
#line 8657 
      (*(ldv_63_container->write))(ldv_63_resource_1,(char const *)ldv_63_ldv_param_1_6,ldv_63_size_cnt,ldv_63_ldv_param_3_7);
    }
    else ;
    
#line 8662 
    ldv_free((void *)ldv_63_ldv_param_3_7);
    
#line 8663 
    ldv_free((void *)ldv_63_ldv_param_1_6);
    
#line 8670 
    goto ldv_call_63;
    case 2: 
#line 8673 
    ;
    
#line 8675 
    if (ldv_63_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 8677 
      (*(ldv_63_container->release))(ldv_63_resource_0,ldv_63_resource_1); else ;
    
#line 8685 
    goto ldv_main_63;
    case 3: 
#line 8688 
    ;
    
#line 8692 
    tmp_9 = ldv_undef_int();
    
#line 8692 
    if (tmp_9 != 0) 
#line 8695 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_63_resource_1,ldv_63_ldv_param_1_2,ldv_63_ldv_param_2_3);
    else {
      
#line 8701 
      ldv_63_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 8702 
      ldv_63_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 8707 
      ldv_emg_wrapper_isr_commands_read_3(ldv_63_resource_1,ldv_63_ldv_param_1_4,ldv_63_size_cnt,ldv_63_ldv_param_3_5);
      
#line 8711 
      ldv_free((void *)ldv_63_ldv_param_1_4);
      
#line 8712 
      ldv_free((void *)ldv_63_ldv_param_3_5);
    }
    
#line 8716 
    goto ldv_31297;
    default: 
#line 8718 
    ;
    
#line 8718 
    __VERIFIER_assume(0);
  }
  ldv_31297: 
#line 8727 
  ;
  
#line 8727 
  goto ldv_call_63;
  
#line 8729 
  __retres = (void *)0;
  return_label: 
#line 8729 
                return __retres;
}


#line 8734  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_deregister_3_1(struct platform_driver *arg0)
{
  int ret;
  struct ldv_struct_platform_instance_17 *cf_arg_17;
  int tmp;
  
#line 8737 
  tmp = ldv_undef_int();
  
#line 8737 
  switch (tmp) {
    case 0: 
#line 8738 
    ;
    
#line 8739 
    ret = pthread_join(ldv_thread_17,(void **)0);
    
#line 8740 
    __VERIFIER_assume(ret == 0);
    
#line 8741 
    goto ldv_31305;
    default: 
#line 8743 
    ;
    
#line 8743 
    __VERIFIER_assume(0);
  }
  ldv_31305: 
#line 8744 
  ;
  
#line 8745 
  return;
}


#line 8749  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_5(void *arg0)
{
  void *__retres;
  struct file *ldv_5_resource_1;
  int ldv_5_ldv_param_2_3;
  long long ldv_5_ldv_param_1_2;
  char *ldv_5_ldv_param_1_4;
  struct inode *ldv_5_resource_0;
  unsigned long ldv_5_size_cnt;
  long long *ldv_5_ldv_param_3_5;
  char *ldv_5_ldv_param_1_6;
  long long *ldv_5_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 8760 
  struct file_operations *ldv_5_container = ldv_emg_alias_isr_decrypt_done_ops_2;
  
#line 8761 
  int ldv_5_ret = ldv_undef_int();
  
#line 8764 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 8768 
  ldv_5_ret = ldv_undef_int();
  
#line 8771 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 8772 
    ldv_5_container = data->arg0;
    
#line 8773 
    ldv_free((void *)data);
  }
  else ;
  
#line 8778 
  ldv_5_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 8779 
  tmp_1 = ldv_undef_int();
  
#line 8779 
  ldv_5_size_cnt = (unsigned long)tmp_1;
  
#line 8786 
  goto ldv_main_5;
  
#line 8788 
  __retres = (void *)0;
  
#line 8788 
  goto return_label;
  ldv_main_5: 
#line 8791 
  ;
  
#line 8794 
  tmp_3 = ldv_undef_int();
  
#line 8794 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 8797 
    ldv_5_ret = (*ldv_emg_alias_simple_open_5)(ldv_5_resource_0,ldv_5_resource_1);
    
#line 8799 
    ldv_5_ret = ldv_filter_err_code(ldv_5_ret);
    
#line 8802 
    tmp_2 = ldv_undef_int();
    
#line 8802 
    if (tmp_2 != 0) {
      
#line 8804 
      __VERIFIER_assume(ldv_5_ret == 0);
      
#line 8811 
      goto ldv_call_5;
    }
    else {
      
#line 8815 
      __VERIFIER_assume(ldv_5_ret != 0);
      
#line 8822 
      goto ldv_main_5;
    }
  }
  else {
    
#line 8827 
    ldv_free((void *)ldv_5_resource_0);
    
#line 8835 
    __retres = (void *)0;
    
#line 8835 
    goto return_label;
  }
  
#line 8838 
  __retres = (void *)0;
  
#line 8838 
  goto return_label;
  ldv_call_5: 
#line 8841 
  ;
  
#line 8844 
  tmp_4 = ldv_undef_int();
  
#line 8844 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 8845 
    ;
    
#line 8847 
    ldv_5_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 8848 
    ldv_5_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 8852 
    if (ldv_5_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 8858 
      __VERIFIER_assume(ldv_5_size_cnt <= 2147479552UL);
      
#line 8860 
      (*(ldv_5_container->write))(ldv_5_resource_1,(char const *)ldv_5_ldv_param_1_6,ldv_5_size_cnt,ldv_5_ldv_param_3_7);
    }
    else ;
    
#line 8865 
    ldv_free((void *)ldv_5_ldv_param_3_7);
    
#line 8866 
    ldv_free((void *)ldv_5_ldv_param_1_6);
    
#line 8873 
    goto ldv_call_5;
    case 2: 
#line 8876 
    ;
    
#line 8878 
    if (ldv_5_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 8880 
      (*(ldv_5_container->release))(ldv_5_resource_0,ldv_5_resource_1); else ;
    
#line 8888 
    goto ldv_main_5;
    case 3: 
#line 8891 
    ;
    
#line 8895 
    tmp_9 = ldv_undef_int();
    
#line 8895 
    if (tmp_9 != 0) 
#line 8898 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_5_resource_1,ldv_5_ldv_param_1_2,ldv_5_ldv_param_2_3);
    else {
      
#line 8904 
      ldv_5_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 8905 
      ldv_5_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 8910 
      ldv_emg_wrapper_isr_decrypt_done_read_3(ldv_5_resource_1,ldv_5_ldv_param_1_4,ldv_5_size_cnt,ldv_5_ldv_param_3_5);
      
#line 8914 
      ldv_free((void *)ldv_5_ldv_param_1_4);
      
#line 8915 
      ldv_free((void *)ldv_5_ldv_param_3_5);
    }
    
#line 8919 
    goto ldv_31327;
    default: 
#line 8921 
    ;
    
#line 8921 
    __VERIFIER_assume(0);
  }
  ldv_31327: 
#line 8930 
  ;
  
#line 8930 
  goto ldv_call_5;
  
#line 8932 
  __retres = (void *)0;
  return_label: 
#line 8932 
                return __retres;
}


#line 8937  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_79(void *arg0)
{
  void *__retres;
  struct file *ldv_79_resource_1;
  int ldv_79_ldv_param_2_3;
  long long ldv_79_ldv_param_1_2;
  char *ldv_79_ldv_param_1_4;
  struct inode *ldv_79_resource_0;
  unsigned long ldv_79_size_cnt;
  long long *ldv_79_ldv_param_3_5;
  char *ldv_79_ldv_param_1_6;
  long long *ldv_79_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 8948 
  struct file_operations *ldv_79_container = ldv_emg_alias_isr_pci_pm_ops_2;
  
#line 8949 
  int ldv_79_ret = ldv_undef_int();
  
#line 8952 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 8956 
  ldv_79_ret = ldv_undef_int();
  
#line 8959 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 8960 
    ldv_79_container = data->arg0;
    
#line 8961 
    ldv_free((void *)data);
  }
  else ;
  
#line 8966 
  ldv_79_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 8967 
  tmp_1 = ldv_undef_int();
  
#line 8967 
  ldv_79_size_cnt = (unsigned long)tmp_1;
  
#line 8974 
  goto ldv_main_79;
  
#line 8976 
  __retres = (void *)0;
  
#line 8976 
  goto return_label;
  ldv_main_79: 
#line 8979 
  ;
  
#line 8982 
  tmp_3 = ldv_undef_int();
  
#line 8982 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 8985 
    ldv_79_ret = (*ldv_emg_alias_simple_open_5)(ldv_79_resource_0,ldv_79_resource_1);
    
#line 8987 
    ldv_79_ret = ldv_filter_err_code(ldv_79_ret);
    
#line 8990 
    tmp_2 = ldv_undef_int();
    
#line 8990 
    if (tmp_2 != 0) {
      
#line 8992 
      __VERIFIER_assume(ldv_79_ret == 0);
      
#line 8999 
      goto ldv_call_79;
    }
    else {
      
#line 9003 
      __VERIFIER_assume(ldv_79_ret != 0);
      
#line 9010 
      goto ldv_main_79;
    }
  }
  else {
    
#line 9015 
    ldv_free((void *)ldv_79_resource_0);
    
#line 9023 
    __retres = (void *)0;
    
#line 9023 
    goto return_label;
  }
  
#line 9026 
  __retres = (void *)0;
  
#line 9026 
  goto return_label;
  ldv_call_79: 
#line 9029 
  ;
  
#line 9032 
  tmp_4 = ldv_undef_int();
  
#line 9032 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 9033 
    ;
    
#line 9035 
    ldv_79_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 9036 
    ldv_79_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 9040 
    if (ldv_79_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 9046 
      __VERIFIER_assume(ldv_79_size_cnt <= 2147479552UL);
      
#line 9048 
      (*(ldv_79_container->write))(ldv_79_resource_1,(char const *)ldv_79_ldv_param_1_6,ldv_79_size_cnt,ldv_79_ldv_param_3_7);
    }
    else ;
    
#line 9053 
    ldv_free((void *)ldv_79_ldv_param_3_7);
    
#line 9054 
    ldv_free((void *)ldv_79_ldv_param_1_6);
    
#line 9061 
    goto ldv_call_79;
    case 2: 
#line 9064 
    ;
    
#line 9066 
    if (ldv_79_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 9068 
      (*(ldv_79_container->release))(ldv_79_resource_0,ldv_79_resource_1); else ;
    
#line 9076 
    goto ldv_main_79;
    case 3: 
#line 9079 
    ;
    
#line 9083 
    tmp_9 = ldv_undef_int();
    
#line 9083 
    if (tmp_9 != 0) 
#line 9086 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_79_resource_1,ldv_79_ldv_param_1_2,ldv_79_ldv_param_2_3);
    else {
      
#line 9092 
      ldv_79_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 9093 
      ldv_79_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 9098 
      ldv_emg_wrapper_isr_pci_pm_read_3(ldv_79_resource_1,ldv_79_ldv_param_1_4,ldv_79_size_cnt,ldv_79_ldv_param_3_5);
      
#line 9102 
      ldv_free((void *)ldv_79_ldv_param_1_4);
      
#line 9103 
      ldv_free((void *)ldv_79_ldv_param_3_5);
    }
    
#line 9107 
    goto ldv_31349;
    default: 
#line 9109 
    ;
    
#line 9109 
    __VERIFIER_assume(0);
  }
  ldv_31349: 
#line 9118 
  ;
  
#line 9118 
  goto ldv_call_79;
  
#line 9120 
  __retres = (void *)0;
  return_label: 
#line 9120 
                return __retres;
}


#line 9125  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_22(void *arg0)
{
  void *__retres;
  struct file *ldv_22_resource_1;
  int ldv_22_ldv_param_2_3;
  long long ldv_22_ldv_param_1_2;
  char *ldv_22_ldv_param_1_4;
  struct inode *ldv_22_resource_0;
  unsigned long ldv_22_size_cnt;
  long long *ldv_22_ldv_param_3_5;
  char *ldv_22_ldv_param_1_6;
  long long *ldv_22_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 9136 
  struct file_operations *ldv_22_container = ldv_emg_alias_isr_rx_rdys_ops_2;
  
#line 9137 
  int ldv_22_ret = ldv_undef_int();
  
#line 9140 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 9144 
  ldv_22_ret = ldv_undef_int();
  
#line 9147 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 9148 
    ldv_22_container = data->arg0;
    
#line 9149 
    ldv_free((void *)data);
  }
  else ;
  
#line 9154 
  ldv_22_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 9155 
  tmp_1 = ldv_undef_int();
  
#line 9155 
  ldv_22_size_cnt = (unsigned long)tmp_1;
  
#line 9162 
  goto ldv_main_22;
  
#line 9164 
  __retres = (void *)0;
  
#line 9164 
  goto return_label;
  ldv_main_22: 
#line 9167 
  ;
  
#line 9170 
  tmp_3 = ldv_undef_int();
  
#line 9170 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 9173 
    ldv_22_ret = (*ldv_emg_alias_simple_open_5)(ldv_22_resource_0,ldv_22_resource_1);
    
#line 9175 
    ldv_22_ret = ldv_filter_err_code(ldv_22_ret);
    
#line 9178 
    tmp_2 = ldv_undef_int();
    
#line 9178 
    if (tmp_2 != 0) {
      
#line 9180 
      __VERIFIER_assume(ldv_22_ret == 0);
      
#line 9187 
      goto ldv_call_22;
    }
    else {
      
#line 9191 
      __VERIFIER_assume(ldv_22_ret != 0);
      
#line 9198 
      goto ldv_main_22;
    }
  }
  else {
    
#line 9203 
    ldv_free((void *)ldv_22_resource_0);
    
#line 9211 
    __retres = (void *)0;
    
#line 9211 
    goto return_label;
  }
  
#line 9214 
  __retres = (void *)0;
  
#line 9214 
  goto return_label;
  ldv_call_22: 
#line 9217 
  ;
  
#line 9220 
  tmp_4 = ldv_undef_int();
  
#line 9220 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 9221 
    ;
    
#line 9223 
    ldv_22_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 9224 
    ldv_22_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 9228 
    if (ldv_22_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 9234 
      __VERIFIER_assume(ldv_22_size_cnt <= 2147479552UL);
      
#line 9236 
      (*(ldv_22_container->write))(ldv_22_resource_1,(char const *)ldv_22_ldv_param_1_6,ldv_22_size_cnt,ldv_22_ldv_param_3_7);
    }
    else ;
    
#line 9241 
    ldv_free((void *)ldv_22_ldv_param_1_6);
    
#line 9242 
    ldv_free((void *)ldv_22_ldv_param_3_7);
    
#line 9249 
    goto ldv_call_22;
    case 2: 
#line 9252 
    ;
    
#line 9254 
    if (ldv_22_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 9256 
      (*(ldv_22_container->release))(ldv_22_resource_0,ldv_22_resource_1); else ;
    
#line 9264 
    goto ldv_main_22;
    case 3: 
#line 9267 
    ;
    
#line 9271 
    tmp_9 = ldv_undef_int();
    
#line 9271 
    if (tmp_9 != 0) 
#line 9274 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_22_resource_1,ldv_22_ldv_param_1_2,ldv_22_ldv_param_2_3);
    else {
      
#line 9280 
      ldv_22_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 9281 
      ldv_22_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 9286 
      ldv_emg_wrapper_isr_rx_rdys_read_3(ldv_22_resource_1,ldv_22_ldv_param_1_4,ldv_22_size_cnt,ldv_22_ldv_param_3_5);
      
#line 9290 
      ldv_free((void *)ldv_22_ldv_param_3_5);
      
#line 9291 
      ldv_free((void *)ldv_22_ldv_param_1_4);
    }
    
#line 9295 
    goto ldv_31371;
    default: 
#line 9297 
    ;
    
#line 9297 
    __VERIFIER_assume(0);
  }
  ldv_31371: 
#line 9306 
  ;
  
#line 9306 
  goto ldv_call_22;
  
#line 9308 
  __retres = (void *)0;
  return_label: 
#line 9308 
                return __retres;
}


#line 9313  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_82(void *arg0)
{
  void *__retres;
  struct file *ldv_82_resource_1;
  int ldv_82_ldv_param_2_3;
  long long ldv_82_ldv_param_1_2;
  char *ldv_82_ldv_param_1_4;
  struct inode *ldv_82_resource_0;
  unsigned long ldv_82_size_cnt;
  long long *ldv_82_ldv_param_3_5;
  char *ldv_82_ldv_param_1_6;
  long long *ldv_82_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 9324 
  struct file_operations *ldv_82_container = ldv_emg_alias_pwr_missing_bcns_ops_2;
  
#line 9325 
  int ldv_82_ret = ldv_undef_int();
  
#line 9328 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 9332 
  ldv_82_ret = ldv_undef_int();
  
#line 9335 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 9336 
    ldv_82_container = data->arg0;
    
#line 9337 
    ldv_free((void *)data);
  }
  else ;
  
#line 9342 
  ldv_82_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 9343 
  tmp_1 = ldv_undef_int();
  
#line 9343 
  ldv_82_size_cnt = (unsigned long)tmp_1;
  
#line 9350 
  goto ldv_main_82;
  
#line 9352 
  __retres = (void *)0;
  
#line 9352 
  goto return_label;
  ldv_main_82: 
#line 9355 
  ;
  
#line 9358 
  tmp_3 = ldv_undef_int();
  
#line 9358 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 9361 
    ldv_82_ret = (*ldv_emg_alias_simple_open_5)(ldv_82_resource_0,ldv_82_resource_1);
    
#line 9363 
    ldv_82_ret = ldv_filter_err_code(ldv_82_ret);
    
#line 9366 
    tmp_2 = ldv_undef_int();
    
#line 9366 
    if (tmp_2 != 0) {
      
#line 9368 
      __VERIFIER_assume(ldv_82_ret == 0);
      
#line 9375 
      goto ldv_call_82;
    }
    else {
      
#line 9379 
      __VERIFIER_assume(ldv_82_ret != 0);
      
#line 9386 
      goto ldv_main_82;
    }
  }
  else {
    
#line 9391 
    ldv_free((void *)ldv_82_resource_0);
    
#line 9399 
    __retres = (void *)0;
    
#line 9399 
    goto return_label;
  }
  
#line 9402 
  __retres = (void *)0;
  
#line 9402 
  goto return_label;
  ldv_call_82: 
#line 9405 
  ;
  
#line 9408 
  tmp_4 = ldv_undef_int();
  
#line 9408 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 9409 
    ;
    
#line 9411 
    ldv_82_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 9412 
    ldv_82_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 9416 
    if (ldv_82_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 9422 
      __VERIFIER_assume(ldv_82_size_cnt <= 2147479552UL);
      
#line 9424 
      (*(ldv_82_container->write))(ldv_82_resource_1,(char const *)ldv_82_ldv_param_1_6,ldv_82_size_cnt,ldv_82_ldv_param_3_7);
    }
    else ;
    
#line 9429 
    ldv_free((void *)ldv_82_ldv_param_3_7);
    
#line 9430 
    ldv_free((void *)ldv_82_ldv_param_1_6);
    
#line 9437 
    goto ldv_call_82;
    case 2: 
#line 9440 
    ;
    
#line 9442 
    if (ldv_82_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 9444 
      (*(ldv_82_container->release))(ldv_82_resource_0,ldv_82_resource_1); else ;
    
#line 9452 
    goto ldv_main_82;
    case 3: 
#line 9455 
    ;
    
#line 9459 
    tmp_9 = ldv_undef_int();
    
#line 9459 
    if (tmp_9 != 0) 
#line 9462 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_82_resource_1,ldv_82_ldv_param_1_2,ldv_82_ldv_param_2_3);
    else {
      
#line 9468 
      ldv_82_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 9469 
      ldv_82_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 9474 
      ldv_emg_wrapper_pwr_missing_bcns_read_3(ldv_82_resource_1,ldv_82_ldv_param_1_4,ldv_82_size_cnt,ldv_82_ldv_param_3_5);
      
#line 9478 
      ldv_free((void *)ldv_82_ldv_param_3_5);
      
#line 9479 
      ldv_free((void *)ldv_82_ldv_param_1_4);
    }
    
#line 9483 
    goto ldv_31393;
    default: 
#line 9485 
    ;
    
#line 9485 
    __VERIFIER_assume(0);
  }
  ldv_31393: 
#line 9494 
  ;
  
#line 9494 
  goto ldv_call_82;
  
#line 9496 
  __retres = (void *)0;
  return_label: 
#line 9496 
                return __retres;
}


#line 9501  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_43(void *arg0)
{
  void *__retres;
  struct file *ldv_43_resource_1;
  int ldv_43_ldv_param_2_3;
  long long ldv_43_ldv_param_1_2;
  char *ldv_43_ldv_param_1_4;
  struct inode *ldv_43_resource_0;
  unsigned long ldv_43_size_cnt;
  long long *ldv_43_ldv_param_3_5;
  char *ldv_43_ldv_param_1_6;
  long long *ldv_43_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 9512 
  struct file_operations *ldv_43_container = ldv_emg_alias_dma_rx_requested_ops_2;
  
#line 9513 
  int ldv_43_ret = ldv_undef_int();
  
#line 9516 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 9520 
  ldv_43_ret = ldv_undef_int();
  
#line 9523 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 9524 
    ldv_43_container = data->arg0;
    
#line 9525 
    ldv_free((void *)data);
  }
  else ;
  
#line 9530 
  ldv_43_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 9531 
  tmp_1 = ldv_undef_int();
  
#line 9531 
  ldv_43_size_cnt = (unsigned long)tmp_1;
  
#line 9538 
  goto ldv_main_43;
  
#line 9540 
  __retres = (void *)0;
  
#line 9540 
  goto return_label;
  ldv_main_43: 
#line 9543 
  ;
  
#line 9546 
  tmp_3 = ldv_undef_int();
  
#line 9546 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 9549 
    ldv_43_ret = (*ldv_emg_alias_simple_open_5)(ldv_43_resource_0,ldv_43_resource_1);
    
#line 9551 
    ldv_43_ret = ldv_filter_err_code(ldv_43_ret);
    
#line 9554 
    tmp_2 = ldv_undef_int();
    
#line 9554 
    if (tmp_2 != 0) {
      
#line 9556 
      __VERIFIER_assume(ldv_43_ret == 0);
      
#line 9563 
      goto ldv_call_43;
    }
    else {
      
#line 9567 
      __VERIFIER_assume(ldv_43_ret != 0);
      
#line 9574 
      goto ldv_main_43;
    }
  }
  else {
    
#line 9579 
    ldv_free((void *)ldv_43_resource_0);
    
#line 9587 
    __retres = (void *)0;
    
#line 9587 
    goto return_label;
  }
  
#line 9590 
  __retres = (void *)0;
  
#line 9590 
  goto return_label;
  ldv_call_43: 
#line 9593 
  ;
  
#line 9596 
  tmp_4 = ldv_undef_int();
  
#line 9596 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 9597 
    ;
    
#line 9599 
    ldv_43_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 9600 
    ldv_43_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 9604 
    if (ldv_43_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 9610 
      __VERIFIER_assume(ldv_43_size_cnt <= 2147479552UL);
      
#line 9612 
      (*(ldv_43_container->write))(ldv_43_resource_1,(char const *)ldv_43_ldv_param_1_6,ldv_43_size_cnt,ldv_43_ldv_param_3_7);
    }
    else ;
    
#line 9617 
    ldv_free((void *)ldv_43_ldv_param_3_7);
    
#line 9618 
    ldv_free((void *)ldv_43_ldv_param_1_6);
    
#line 9625 
    goto ldv_call_43;
    case 2: 
#line 9628 
    ;
    
#line 9630 
    if (ldv_43_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 9632 
      (*(ldv_43_container->release))(ldv_43_resource_0,ldv_43_resource_1); else ;
    
#line 9640 
    goto ldv_main_43;
    case 3: 
#line 9643 
    ;
    
#line 9647 
    tmp_9 = ldv_undef_int();
    
#line 9647 
    if (tmp_9 != 0) 
#line 9650 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_43_resource_1,ldv_43_ldv_param_1_2,ldv_43_ldv_param_2_3);
    else {
      
#line 9656 
      ldv_43_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 9657 
      ldv_43_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 9662 
      ldv_emg_wrapper_dma_rx_requested_read_3(ldv_43_resource_1,ldv_43_ldv_param_1_4,ldv_43_size_cnt,ldv_43_ldv_param_3_5);
      
#line 9666 
      ldv_free((void *)ldv_43_ldv_param_3_5);
      
#line 9667 
      ldv_free((void *)ldv_43_ldv_param_1_4);
    }
    
#line 9671 
    goto ldv_31415;
    default: 
#line 9673 
    ;
    
#line 9673 
    __VERIFIER_assume(0);
  }
  ldv_31415: 
#line 9682 
  ;
  
#line 9682 
  goto ldv_call_43;
  
#line 9684 
  __retres = (void *)0;
  return_label: 
#line 9684 
                return __retres;
}


#line 9689  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_72(void *arg0)
{
  void *__retres;
  struct file *ldv_72_resource_1;
  int ldv_72_ldv_param_2_3;
  long long ldv_72_ldv_param_1_2;
  char *ldv_72_ldv_param_1_4;
  struct inode *ldv_72_resource_0;
  unsigned long ldv_72_size_cnt;
  long long *ldv_72_ldv_param_3_5;
  char *ldv_72_ldv_param_1_6;
  long long *ldv_72_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 9700 
  struct file_operations *ldv_72_container = ldv_emg_alias_mic_calc_failure_ops_2;
  
#line 9701 
  int ldv_72_ret = ldv_undef_int();
  
#line 9704 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 9708 
  ldv_72_ret = ldv_undef_int();
  
#line 9711 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 9712 
    ldv_72_container = data->arg0;
    
#line 9713 
    ldv_free((void *)data);
  }
  else ;
  
#line 9718 
  ldv_72_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 9719 
  tmp_1 = ldv_undef_int();
  
#line 9719 
  ldv_72_size_cnt = (unsigned long)tmp_1;
  
#line 9726 
  goto ldv_main_72;
  
#line 9728 
  __retres = (void *)0;
  
#line 9728 
  goto return_label;
  ldv_main_72: 
#line 9731 
  ;
  
#line 9734 
  tmp_3 = ldv_undef_int();
  
#line 9734 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 9737 
    ldv_72_ret = (*ldv_emg_alias_simple_open_5)(ldv_72_resource_0,ldv_72_resource_1);
    
#line 9739 
    ldv_72_ret = ldv_filter_err_code(ldv_72_ret);
    
#line 9742 
    tmp_2 = ldv_undef_int();
    
#line 9742 
    if (tmp_2 != 0) {
      
#line 9744 
      __VERIFIER_assume(ldv_72_ret == 0);
      
#line 9751 
      goto ldv_call_72;
    }
    else {
      
#line 9755 
      __VERIFIER_assume(ldv_72_ret != 0);
      
#line 9762 
      goto ldv_main_72;
    }
  }
  else {
    
#line 9767 
    ldv_free((void *)ldv_72_resource_0);
    
#line 9775 
    __retres = (void *)0;
    
#line 9775 
    goto return_label;
  }
  
#line 9778 
  __retres = (void *)0;
  
#line 9778 
  goto return_label;
  ldv_call_72: 
#line 9781 
  ;
  
#line 9784 
  tmp_4 = ldv_undef_int();
  
#line 9784 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 9785 
    ;
    
#line 9787 
    ldv_72_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 9788 
    ldv_72_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 9792 
    if (ldv_72_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 9798 
      __VERIFIER_assume(ldv_72_size_cnt <= 2147479552UL);
      
#line 9800 
      (*(ldv_72_container->write))(ldv_72_resource_1,(char const *)ldv_72_ldv_param_1_6,ldv_72_size_cnt,ldv_72_ldv_param_3_7);
    }
    else ;
    
#line 9805 
    ldv_free((void *)ldv_72_ldv_param_3_7);
    
#line 9806 
    ldv_free((void *)ldv_72_ldv_param_1_6);
    
#line 9813 
    goto ldv_call_72;
    case 2: 
#line 9816 
    ;
    
#line 9818 
    if (ldv_72_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 9820 
      (*(ldv_72_container->release))(ldv_72_resource_0,ldv_72_resource_1); else ;
    
#line 9828 
    goto ldv_main_72;
    case 3: 
#line 9831 
    ;
    
#line 9835 
    tmp_9 = ldv_undef_int();
    
#line 9835 
    if (tmp_9 != 0) 
#line 9838 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_72_resource_1,ldv_72_ldv_param_1_2,ldv_72_ldv_param_2_3);
    else {
      
#line 9844 
      ldv_72_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 9845 
      ldv_72_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 9850 
      ldv_emg_wrapper_mic_calc_failure_read_3(ldv_72_resource_1,ldv_72_ldv_param_1_4,ldv_72_size_cnt,ldv_72_ldv_param_3_5);
      
#line 9854 
      ldv_free((void *)ldv_72_ldv_param_3_5);
      
#line 9855 
      ldv_free((void *)ldv_72_ldv_param_1_4);
    }
    
#line 9859 
    goto ldv_31437;
    default: 
#line 9861 
    ;
    
#line 9861 
    __VERIFIER_assume(0);
  }
  ldv_31437: 
#line 9870 
  ;
  
#line 9870 
  goto ldv_call_72;
  
#line 9872 
  __retres = (void *)0;
  return_label: 
#line 9872 
                return __retres;
}


#line 9877  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_20(void *arg0)
{
  void *__retres;
  struct file *ldv_20_resource_1;
  int ldv_20_ldv_param_2_3;
  long long ldv_20_ldv_param_1_2;
  char *ldv_20_ldv_param_1_4;
  struct inode *ldv_20_resource_0;
  unsigned long ldv_20_size_cnt;
  long long *ldv_20_ldv_param_3_5;
  char *ldv_20_ldv_param_1_6;
  long long *ldv_20_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 9888 
  struct file_operations *ldv_20_container = ldv_emg_alias_event_phy_transmit_error_ops_2;
  
#line 9889 
  int ldv_20_ret = ldv_undef_int();
  
#line 9892 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 9896 
  ldv_20_ret = ldv_undef_int();
  
#line 9899 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 9900 
    ldv_20_container = data->arg0;
    
#line 9901 
    ldv_free((void *)data);
  }
  else ;
  
#line 9906 
  ldv_20_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 9907 
  tmp_1 = ldv_undef_int();
  
#line 9907 
  ldv_20_size_cnt = (unsigned long)tmp_1;
  
#line 9914 
  goto ldv_main_20;
  
#line 9916 
  __retres = (void *)0;
  
#line 9916 
  goto return_label;
  ldv_main_20: 
#line 9919 
  ;
  
#line 9922 
  tmp_3 = ldv_undef_int();
  
#line 9922 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 9925 
    ldv_20_ret = (*ldv_emg_alias_simple_open_5)(ldv_20_resource_0,ldv_20_resource_1);
    
#line 9927 
    ldv_20_ret = ldv_filter_err_code(ldv_20_ret);
    
#line 9930 
    tmp_2 = ldv_undef_int();
    
#line 9930 
    if (tmp_2 != 0) {
      
#line 9932 
      __VERIFIER_assume(ldv_20_ret == 0);
      
#line 9939 
      goto ldv_call_20;
    }
    else {
      
#line 9943 
      __VERIFIER_assume(ldv_20_ret != 0);
      
#line 9950 
      goto ldv_main_20;
    }
  }
  else {
    
#line 9955 
    ldv_free((void *)ldv_20_resource_0);
    
#line 9963 
    __retres = (void *)0;
    
#line 9963 
    goto return_label;
  }
  
#line 9966 
  __retres = (void *)0;
  
#line 9966 
  goto return_label;
  ldv_call_20: 
#line 9969 
  ;
  
#line 9972 
  tmp_4 = ldv_undef_int();
  
#line 9972 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 9973 
    ;
    
#line 9975 
    ldv_20_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 9976 
    ldv_20_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 9980 
    if (ldv_20_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 9986 
      __VERIFIER_assume(ldv_20_size_cnt <= 2147479552UL);
      
#line 9988 
      (*(ldv_20_container->write))(ldv_20_resource_1,(char const *)ldv_20_ldv_param_1_6,ldv_20_size_cnt,ldv_20_ldv_param_3_7);
    }
    else ;
    
#line 9993 
    ldv_free((void *)ldv_20_ldv_param_3_7);
    
#line 9994 
    ldv_free((void *)ldv_20_ldv_param_1_6);
    
#line 10001 
    goto ldv_call_20;
    case 2: 
#line 10004 
    ;
    
#line 10006 
    if (ldv_20_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 10008 
      (*(ldv_20_container->release))(ldv_20_resource_0,ldv_20_resource_1); else ;
    
#line 10016 
    goto ldv_main_20;
    case 3: 
#line 10019 
    ;
    
#line 10023 
    tmp_9 = ldv_undef_int();
    
#line 10023 
    if (tmp_9 != 0) 
#line 10026 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_20_resource_1,ldv_20_ldv_param_1_2,ldv_20_ldv_param_2_3);
    else {
      
#line 10032 
      ldv_20_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 10033 
      ldv_20_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 10038 
      ldv_emg_wrapper_event_phy_transmit_error_read_3(ldv_20_resource_1,ldv_20_ldv_param_1_4,ldv_20_size_cnt,ldv_20_ldv_param_3_5);
      
#line 10042 
      ldv_free((void *)ldv_20_ldv_param_3_5);
      
#line 10043 
      ldv_free((void *)ldv_20_ldv_param_1_4);
    }
    
#line 10047 
    goto ldv_31459;
    default: 
#line 10049 
    ;
    
#line 10049 
    __VERIFIER_assume(0);
  }
  ldv_31459: 
#line 10058 
  ;
  
#line 10058 
  goto ldv_call_20;
  
#line 10060 
  __retres = (void *)0;
  return_label: 
#line 10060 
                return __retres;
}


#line 10065  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_42(void *arg0)
{
  void *__retres;
  struct file *ldv_42_resource_1;
  int ldv_42_ldv_param_2_3;
  long long ldv_42_ldv_param_1_2;
  char *ldv_42_ldv_param_1_4;
  struct inode *ldv_42_resource_0;
  unsigned long ldv_42_size_cnt;
  long long *ldv_42_ldv_param_3_5;
  char *ldv_42_ldv_param_1_6;
  long long *ldv_42_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 10076 
  struct file_operations *ldv_42_container = ldv_emg_alias_isr_dma1_done_ops_2;
  
#line 10077 
  int ldv_42_ret = ldv_undef_int();
  
#line 10080 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 10084 
  ldv_42_ret = ldv_undef_int();
  
#line 10087 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 10088 
    ldv_42_container = data->arg0;
    
#line 10089 
    ldv_free((void *)data);
  }
  else ;
  
#line 10094 
  ldv_42_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 10095 
  tmp_1 = ldv_undef_int();
  
#line 10095 
  ldv_42_size_cnt = (unsigned long)tmp_1;
  
#line 10102 
  goto ldv_main_42;
  
#line 10104 
  __retres = (void *)0;
  
#line 10104 
  goto return_label;
  ldv_main_42: 
#line 10107 
  ;
  
#line 10110 
  tmp_3 = ldv_undef_int();
  
#line 10110 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 10113 
    ldv_42_ret = (*ldv_emg_alias_simple_open_5)(ldv_42_resource_0,ldv_42_resource_1);
    
#line 10115 
    ldv_42_ret = ldv_filter_err_code(ldv_42_ret);
    
#line 10118 
    tmp_2 = ldv_undef_int();
    
#line 10118 
    if (tmp_2 != 0) {
      
#line 10120 
      __VERIFIER_assume(ldv_42_ret == 0);
      
#line 10127 
      goto ldv_call_42;
    }
    else {
      
#line 10131 
      __VERIFIER_assume(ldv_42_ret != 0);
      
#line 10138 
      goto ldv_main_42;
    }
  }
  else {
    
#line 10143 
    ldv_free((void *)ldv_42_resource_0);
    
#line 10151 
    __retres = (void *)0;
    
#line 10151 
    goto return_label;
  }
  
#line 10154 
  __retres = (void *)0;
  
#line 10154 
  goto return_label;
  ldv_call_42: 
#line 10157 
  ;
  
#line 10160 
  tmp_4 = ldv_undef_int();
  
#line 10160 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 10161 
    ;
    
#line 10163 
    ldv_42_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 10164 
    ldv_42_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 10168 
    if (ldv_42_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 10174 
      __VERIFIER_assume(ldv_42_size_cnt <= 2147479552UL);
      
#line 10176 
      (*(ldv_42_container->write))(ldv_42_resource_1,(char const *)ldv_42_ldv_param_1_6,ldv_42_size_cnt,ldv_42_ldv_param_3_7);
    }
    else ;
    
#line 10181 
    ldv_free((void *)ldv_42_ldv_param_3_7);
    
#line 10182 
    ldv_free((void *)ldv_42_ldv_param_1_6);
    
#line 10189 
    goto ldv_call_42;
    case 2: 
#line 10192 
    ;
    
#line 10194 
    if (ldv_42_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 10196 
      (*(ldv_42_container->release))(ldv_42_resource_0,ldv_42_resource_1); else ;
    
#line 10204 
    goto ldv_main_42;
    case 3: 
#line 10207 
    ;
    
#line 10211 
    tmp_9 = ldv_undef_int();
    
#line 10211 
    if (tmp_9 != 0) 
#line 10214 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_42_resource_1,ldv_42_ldv_param_1_2,ldv_42_ldv_param_2_3);
    else {
      
#line 10220 
      ldv_42_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 10221 
      ldv_42_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 10226 
      ldv_emg_wrapper_isr_dma1_done_read_3(ldv_42_resource_1,ldv_42_ldv_param_1_4,ldv_42_size_cnt,ldv_42_ldv_param_3_5);
      
#line 10230 
      ldv_free((void *)ldv_42_ldv_param_3_5);
      
#line 10231 
      ldv_free((void *)ldv_42_ldv_param_1_4);
    }
    
#line 10235 
    goto ldv_31481;
    default: 
#line 10237 
    ;
    
#line 10237 
    __VERIFIER_assume(0);
  }
  ldv_31481: 
#line 10246 
  ;
  
#line 10246 
  goto ldv_call_42;
  
#line 10248 
  __retres = (void *)0;
  return_label: 
#line 10248 
                return __retres;
}


#line 10253  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_64(void *arg0)
{
  void *__retres;
  struct file *ldv_64_resource_1;
  int ldv_64_ldv_param_2_3;
  long long ldv_64_ldv_param_1_2;
  char *ldv_64_ldv_param_1_4;
  struct inode *ldv_64_resource_0;
  unsigned long ldv_64_size_cnt;
  long long *ldv_64_ldv_param_3_5;
  char *ldv_64_ldv_param_1_6;
  long long *ldv_64_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 10264 
  struct file_operations *ldv_64_container = ldv_emg_alias_event_rx_mismatch_ops_2;
  
#line 10265 
  int ldv_64_ret = ldv_undef_int();
  
#line 10268 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 10272 
  ldv_64_ret = ldv_undef_int();
  
#line 10275 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 10276 
    ldv_64_container = data->arg0;
    
#line 10277 
    ldv_free((void *)data);
  }
  else ;
  
#line 10282 
  ldv_64_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 10283 
  tmp_1 = ldv_undef_int();
  
#line 10283 
  ldv_64_size_cnt = (unsigned long)tmp_1;
  
#line 10290 
  goto ldv_main_64;
  
#line 10292 
  __retres = (void *)0;
  
#line 10292 
  goto return_label;
  ldv_main_64: 
#line 10295 
  ;
  
#line 10298 
  tmp_3 = ldv_undef_int();
  
#line 10298 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 10301 
    ldv_64_ret = (*ldv_emg_alias_simple_open_5)(ldv_64_resource_0,ldv_64_resource_1);
    
#line 10303 
    ldv_64_ret = ldv_filter_err_code(ldv_64_ret);
    
#line 10306 
    tmp_2 = ldv_undef_int();
    
#line 10306 
    if (tmp_2 != 0) {
      
#line 10308 
      __VERIFIER_assume(ldv_64_ret == 0);
      
#line 10315 
      goto ldv_call_64;
    }
    else {
      
#line 10319 
      __VERIFIER_assume(ldv_64_ret != 0);
      
#line 10326 
      goto ldv_main_64;
    }
  }
  else {
    
#line 10331 
    ldv_free((void *)ldv_64_resource_0);
    
#line 10339 
    __retres = (void *)0;
    
#line 10339 
    goto return_label;
  }
  
#line 10342 
  __retres = (void *)0;
  
#line 10342 
  goto return_label;
  ldv_call_64: 
#line 10345 
  ;
  
#line 10348 
  tmp_4 = ldv_undef_int();
  
#line 10348 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 10349 
    ;
    
#line 10351 
    ldv_64_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 10352 
    ldv_64_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 10356 
    if (ldv_64_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 10362 
      __VERIFIER_assume(ldv_64_size_cnt <= 2147479552UL);
      
#line 10364 
      (*(ldv_64_container->write))(ldv_64_resource_1,(char const *)ldv_64_ldv_param_1_6,ldv_64_size_cnt,ldv_64_ldv_param_3_7);
    }
    else ;
    
#line 10369 
    ldv_free((void *)ldv_64_ldv_param_1_6);
    
#line 10370 
    ldv_free((void *)ldv_64_ldv_param_3_7);
    
#line 10377 
    goto ldv_call_64;
    case 2: 
#line 10380 
    ;
    
#line 10382 
    if (ldv_64_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 10384 
      (*(ldv_64_container->release))(ldv_64_resource_0,ldv_64_resource_1); else ;
    
#line 10392 
    goto ldv_main_64;
    case 3: 
#line 10395 
    ;
    
#line 10399 
    tmp_9 = ldv_undef_int();
    
#line 10399 
    if (tmp_9 != 0) 
#line 10402 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_64_resource_1,ldv_64_ldv_param_1_2,ldv_64_ldv_param_2_3);
    else {
      
#line 10408 
      ldv_64_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 10409 
      ldv_64_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 10414 
      ldv_emg_wrapper_event_rx_mismatch_read_3(ldv_64_resource_1,ldv_64_ldv_param_1_4,ldv_64_size_cnt,ldv_64_ldv_param_3_5);
      
#line 10418 
      ldv_free((void *)ldv_64_ldv_param_3_5);
      
#line 10419 
      ldv_free((void *)ldv_64_ldv_param_1_4);
    }
    
#line 10423 
    goto ldv_31503;
    default: 
#line 10425 
    ;
    
#line 10425 
    __VERIFIER_assume(0);
  }
  ldv_31503: 
#line 10434 
  ;
  
#line 10434 
  goto ldv_call_64;
  
#line 10436 
  __retres = (void *)0;
  return_label: 
#line 10436 
                return __retres;
}


#line 10441  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_16(void *arg0)
{
  void *__retres;
  struct file *ldv_16_resource_1;
  int ldv_16_ldv_param_2_3;
  long long ldv_16_ldv_param_1_2;
  char *ldv_16_ldv_param_1_4;
  struct inode *ldv_16_resource_0;
  unsigned long ldv_16_size_cnt;
  long long *ldv_16_ldv_param_3_5;
  char *ldv_16_ldv_param_1_6;
  long long *ldv_16_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 10452 
  struct file_operations *ldv_16_container = ldv_emg_alias_event_calibration_ops_2;
  
#line 10453 
  int ldv_16_ret = ldv_undef_int();
  
#line 10456 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 10460 
  ldv_16_ret = ldv_undef_int();
  
#line 10463 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 10464 
    ldv_16_container = data->arg0;
    
#line 10465 
    ldv_free((void *)data);
  }
  else ;
  
#line 10470 
  ldv_16_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 10471 
  tmp_1 = ldv_undef_int();
  
#line 10471 
  ldv_16_size_cnt = (unsigned long)tmp_1;
  
#line 10478 
  goto ldv_main_16;
  
#line 10480 
  __retres = (void *)0;
  
#line 10480 
  goto return_label;
  ldv_main_16: 
#line 10483 
  ;
  
#line 10486 
  tmp_3 = ldv_undef_int();
  
#line 10486 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 10489 
    ldv_16_ret = (*ldv_emg_alias_simple_open_5)(ldv_16_resource_0,ldv_16_resource_1);
    
#line 10491 
    ldv_16_ret = ldv_filter_err_code(ldv_16_ret);
    
#line 10494 
    tmp_2 = ldv_undef_int();
    
#line 10494 
    if (tmp_2 != 0) {
      
#line 10496 
      __VERIFIER_assume(ldv_16_ret == 0);
      
#line 10503 
      goto ldv_call_16;
    }
    else {
      
#line 10507 
      __VERIFIER_assume(ldv_16_ret != 0);
      
#line 10514 
      goto ldv_main_16;
    }
  }
  else {
    
#line 10519 
    ldv_free((void *)ldv_16_resource_0);
    
#line 10527 
    __retres = (void *)0;
    
#line 10527 
    goto return_label;
  }
  
#line 10530 
  __retres = (void *)0;
  
#line 10530 
  goto return_label;
  ldv_call_16: 
#line 10533 
  ;
  
#line 10536 
  tmp_4 = ldv_undef_int();
  
#line 10536 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 10537 
    ;
    
#line 10539 
    ldv_16_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 10540 
    ldv_16_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 10544 
    if (ldv_16_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 10550 
      __VERIFIER_assume(ldv_16_size_cnt <= 2147479552UL);
      
#line 10552 
      (*(ldv_16_container->write))(ldv_16_resource_1,(char const *)ldv_16_ldv_param_1_6,ldv_16_size_cnt,ldv_16_ldv_param_3_7);
    }
    else ;
    
#line 10557 
    ldv_free((void *)ldv_16_ldv_param_3_7);
    
#line 10558 
    ldv_free((void *)ldv_16_ldv_param_1_6);
    
#line 10565 
    goto ldv_call_16;
    case 2: 
#line 10568 
    ;
    
#line 10570 
    if (ldv_16_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 10572 
      (*(ldv_16_container->release))(ldv_16_resource_0,ldv_16_resource_1); else ;
    
#line 10580 
    goto ldv_main_16;
    case 3: 
#line 10583 
    ;
    
#line 10587 
    tmp_9 = ldv_undef_int();
    
#line 10587 
    if (tmp_9 != 0) 
#line 10590 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_16_resource_1,ldv_16_ldv_param_1_2,ldv_16_ldv_param_2_3);
    else {
      
#line 10596 
      ldv_16_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 10597 
      ldv_16_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 10602 
      ldv_emg_wrapper_event_calibration_read_3(ldv_16_resource_1,ldv_16_ldv_param_1_4,ldv_16_size_cnt,ldv_16_ldv_param_3_5);
      
#line 10606 
      ldv_free((void *)ldv_16_ldv_param_1_4);
      
#line 10607 
      ldv_free((void *)ldv_16_ldv_param_3_5);
    }
    
#line 10611 
    goto ldv_31525;
    default: 
#line 10613 
    ;
    
#line 10613 
    __VERIFIER_assume(0);
  }
  ldv_31525: 
#line 10622 
  ;
  
#line 10622 
  goto ldv_call_16;
  
#line 10624 
  __retres = (void *)0;
  return_label: 
#line 10624 
                return __retres;
}


#line 10629  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_46(void *arg0)
{
  void *__retres;
  struct file *ldv_46_resource_1;
  int ldv_46_ldv_param_2_3;
  long long ldv_46_ldv_param_1_2;
  char *ldv_46_ldv_param_1_4;
  struct inode *ldv_46_resource_0;
  unsigned long ldv_46_size_cnt;
  long long *ldv_46_ldv_param_3_5;
  char *ldv_46_ldv_param_1_6;
  long long *ldv_46_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 10640 
  struct file_operations *ldv_46_container = ldv_emg_alias_pwr_tx_without_ps_ops_2;
  
#line 10641 
  int ldv_46_ret = ldv_undef_int();
  
#line 10644 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 10648 
  ldv_46_ret = ldv_undef_int();
  
#line 10651 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 10652 
    ldv_46_container = data->arg0;
    
#line 10653 
    ldv_free((void *)data);
  }
  else ;
  
#line 10658 
  ldv_46_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 10659 
  tmp_1 = ldv_undef_int();
  
#line 10659 
  ldv_46_size_cnt = (unsigned long)tmp_1;
  
#line 10666 
  goto ldv_main_46;
  
#line 10668 
  __retres = (void *)0;
  
#line 10668 
  goto return_label;
  ldv_main_46: 
#line 10671 
  ;
  
#line 10674 
  tmp_3 = ldv_undef_int();
  
#line 10674 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 10677 
    ldv_46_ret = (*ldv_emg_alias_simple_open_5)(ldv_46_resource_0,ldv_46_resource_1);
    
#line 10679 
    ldv_46_ret = ldv_filter_err_code(ldv_46_ret);
    
#line 10682 
    tmp_2 = ldv_undef_int();
    
#line 10682 
    if (tmp_2 != 0) {
      
#line 10684 
      __VERIFIER_assume(ldv_46_ret == 0);
      
#line 10691 
      goto ldv_call_46;
    }
    else {
      
#line 10695 
      __VERIFIER_assume(ldv_46_ret != 0);
      
#line 10702 
      goto ldv_main_46;
    }
  }
  else {
    
#line 10707 
    ldv_free((void *)ldv_46_resource_0);
    
#line 10715 
    __retres = (void *)0;
    
#line 10715 
    goto return_label;
  }
  
#line 10718 
  __retres = (void *)0;
  
#line 10718 
  goto return_label;
  ldv_call_46: 
#line 10721 
  ;
  
#line 10724 
  tmp_4 = ldv_undef_int();
  
#line 10724 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 10725 
    ;
    
#line 10727 
    ldv_46_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 10728 
    ldv_46_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 10732 
    if (ldv_46_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 10738 
      __VERIFIER_assume(ldv_46_size_cnt <= 2147479552UL);
      
#line 10740 
      (*(ldv_46_container->write))(ldv_46_resource_1,(char const *)ldv_46_ldv_param_1_6,ldv_46_size_cnt,ldv_46_ldv_param_3_7);
    }
    else ;
    
#line 10745 
    ldv_free((void *)ldv_46_ldv_param_3_7);
    
#line 10746 
    ldv_free((void *)ldv_46_ldv_param_1_6);
    
#line 10753 
    goto ldv_call_46;
    case 2: 
#line 10756 
    ;
    
#line 10758 
    if (ldv_46_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 10760 
      (*(ldv_46_container->release))(ldv_46_resource_0,ldv_46_resource_1); else ;
    
#line 10768 
    goto ldv_main_46;
    case 3: 
#line 10771 
    ;
    
#line 10775 
    tmp_9 = ldv_undef_int();
    
#line 10775 
    if (tmp_9 != 0) 
#line 10778 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_46_resource_1,ldv_46_ldv_param_1_2,ldv_46_ldv_param_2_3);
    else {
      
#line 10784 
      ldv_46_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 10785 
      ldv_46_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 10790 
      ldv_emg_wrapper_pwr_tx_without_ps_read_3(ldv_46_resource_1,ldv_46_ldv_param_1_4,ldv_46_size_cnt,ldv_46_ldv_param_3_5);
      
#line 10794 
      ldv_free((void *)ldv_46_ldv_param_1_4);
      
#line 10795 
      ldv_free((void *)ldv_46_ldv_param_3_5);
    }
    
#line 10799 
    goto ldv_31547;
    default: 
#line 10801 
    ;
    
#line 10801 
    __VERIFIER_assume(0);
  }
  ldv_31547: 
#line 10810 
  ;
  
#line 10810 
  goto ldv_call_46;
  
#line 10812 
  __retres = (void *)0;
  return_label: 
#line 10812 
                return __retres;
}


#line 10817  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_14(void *arg0)
{
  void *__retres;
  struct file *ldv_14_resource_1;
  int ldv_14_ldv_param_2_3;
  long long ldv_14_ldv_param_1_2;
  char *ldv_14_ldv_param_1_4;
  struct inode *ldv_14_resource_0;
  unsigned long ldv_14_size_cnt;
  long long *ldv_14_ldv_param_3_5;
  char *ldv_14_ldv_param_1_6;
  long long *ldv_14_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 10828 
  struct file_operations *ldv_14_container = ldv_emg_alias_pwr_wake_on_timer_exp_ops_2;
  
#line 10829 
  int ldv_14_ret = ldv_undef_int();
  
#line 10832 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 10836 
  ldv_14_ret = ldv_undef_int();
  
#line 10839 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 10840 
    ldv_14_container = data->arg0;
    
#line 10841 
    ldv_free((void *)data);
  }
  else ;
  
#line 10846 
  ldv_14_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 10847 
  tmp_1 = ldv_undef_int();
  
#line 10847 
  ldv_14_size_cnt = (unsigned long)tmp_1;
  
#line 10854 
  goto ldv_main_14;
  
#line 10856 
  __retres = (void *)0;
  
#line 10856 
  goto return_label;
  ldv_main_14: 
#line 10859 
  ;
  
#line 10862 
  tmp_3 = ldv_undef_int();
  
#line 10862 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 10865 
    ldv_14_ret = (*ldv_emg_alias_simple_open_5)(ldv_14_resource_0,ldv_14_resource_1);
    
#line 10867 
    ldv_14_ret = ldv_filter_err_code(ldv_14_ret);
    
#line 10870 
    tmp_2 = ldv_undef_int();
    
#line 10870 
    if (tmp_2 != 0) {
      
#line 10872 
      __VERIFIER_assume(ldv_14_ret == 0);
      
#line 10879 
      goto ldv_call_14;
    }
    else {
      
#line 10883 
      __VERIFIER_assume(ldv_14_ret != 0);
      
#line 10890 
      goto ldv_main_14;
    }
  }
  else {
    
#line 10895 
    ldv_free((void *)ldv_14_resource_0);
    
#line 10903 
    __retres = (void *)0;
    
#line 10903 
    goto return_label;
  }
  
#line 10906 
  __retres = (void *)0;
  
#line 10906 
  goto return_label;
  ldv_call_14: 
#line 10909 
  ;
  
#line 10912 
  tmp_4 = ldv_undef_int();
  
#line 10912 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 10913 
    ;
    
#line 10915 
    ldv_14_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 10916 
    ldv_14_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 10920 
    if (ldv_14_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 10926 
      __VERIFIER_assume(ldv_14_size_cnt <= 2147479552UL);
      
#line 10928 
      (*(ldv_14_container->write))(ldv_14_resource_1,(char const *)ldv_14_ldv_param_1_6,ldv_14_size_cnt,ldv_14_ldv_param_3_7);
    }
    else ;
    
#line 10933 
    ldv_free((void *)ldv_14_ldv_param_3_7);
    
#line 10934 
    ldv_free((void *)ldv_14_ldv_param_1_6);
    
#line 10941 
    goto ldv_call_14;
    case 2: 
#line 10944 
    ;
    
#line 10946 
    if (ldv_14_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 10948 
      (*(ldv_14_container->release))(ldv_14_resource_0,ldv_14_resource_1); else ;
    
#line 10956 
    goto ldv_main_14;
    case 3: 
#line 10959 
    ;
    
#line 10963 
    tmp_9 = ldv_undef_int();
    
#line 10963 
    if (tmp_9 != 0) 
#line 10966 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_14_resource_1,ldv_14_ldv_param_1_2,ldv_14_ldv_param_2_3);
    else {
      
#line 10972 
      ldv_14_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 10973 
      ldv_14_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 10978 
      ldv_emg_wrapper_pwr_wake_on_timer_exp_read_3(ldv_14_resource_1,ldv_14_ldv_param_1_4,ldv_14_size_cnt,ldv_14_ldv_param_3_5);
      
#line 10982 
      ldv_free((void *)ldv_14_ldv_param_1_4);
      
#line 10983 
      ldv_free((void *)ldv_14_ldv_param_3_5);
    }
    
#line 10987 
    goto ldv_31569;
    default: 
#line 10989 
    ;
    
#line 10989 
    __VERIFIER_assume(0);
  }
  ldv_31569: 
#line 10998 
  ;
  
#line 10998 
  goto ldv_call_14;
  
#line 11000 
  __retres = (void *)0;
  return_label: 
#line 11000 
                return __retres;
}


#line 11005  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_47(void *arg0)
{
  void *__retres;
  struct file *ldv_47_resource_1;
  int ldv_47_ldv_param_2_3;
  long long ldv_47_ldv_param_1_2;
  char *ldv_47_ldv_param_1_4;
  struct inode *ldv_47_resource_0;
  unsigned long ldv_47_size_cnt;
  long long *ldv_47_ldv_param_3_5;
  char *ldv_47_ldv_param_1_6;
  long long *ldv_47_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 11016 
  struct file_operations *ldv_47_container = ldv_emg_alias_isr_wakeups_ops_2;
  
#line 11017 
  int ldv_47_ret = ldv_undef_int();
  
#line 11020 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 11024 
  ldv_47_ret = ldv_undef_int();
  
#line 11027 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 11028 
    ldv_47_container = data->arg0;
    
#line 11029 
    ldv_free((void *)data);
  }
  else ;
  
#line 11034 
  ldv_47_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 11035 
  tmp_1 = ldv_undef_int();
  
#line 11035 
  ldv_47_size_cnt = (unsigned long)tmp_1;
  
#line 11042 
  goto ldv_main_47;
  
#line 11044 
  __retres = (void *)0;
  
#line 11044 
  goto return_label;
  ldv_main_47: 
#line 11047 
  ;
  
#line 11050 
  tmp_3 = ldv_undef_int();
  
#line 11050 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 11053 
    ldv_47_ret = (*ldv_emg_alias_simple_open_5)(ldv_47_resource_0,ldv_47_resource_1);
    
#line 11055 
    ldv_47_ret = ldv_filter_err_code(ldv_47_ret);
    
#line 11058 
    tmp_2 = ldv_undef_int();
    
#line 11058 
    if (tmp_2 != 0) {
      
#line 11060 
      __VERIFIER_assume(ldv_47_ret == 0);
      
#line 11067 
      goto ldv_call_47;
    }
    else {
      
#line 11071 
      __VERIFIER_assume(ldv_47_ret != 0);
      
#line 11078 
      goto ldv_main_47;
    }
  }
  else {
    
#line 11083 
    ldv_free((void *)ldv_47_resource_0);
    
#line 11091 
    __retres = (void *)0;
    
#line 11091 
    goto return_label;
  }
  
#line 11094 
  __retres = (void *)0;
  
#line 11094 
  goto return_label;
  ldv_call_47: 
#line 11097 
  ;
  
#line 11100 
  tmp_4 = ldv_undef_int();
  
#line 11100 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 11101 
    ;
    
#line 11103 
    ldv_47_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 11104 
    ldv_47_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 11108 
    if (ldv_47_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 11114 
      __VERIFIER_assume(ldv_47_size_cnt <= 2147479552UL);
      
#line 11116 
      (*(ldv_47_container->write))(ldv_47_resource_1,(char const *)ldv_47_ldv_param_1_6,ldv_47_size_cnt,ldv_47_ldv_param_3_7);
    }
    else ;
    
#line 11121 
    ldv_free((void *)ldv_47_ldv_param_3_7);
    
#line 11122 
    ldv_free((void *)ldv_47_ldv_param_1_6);
    
#line 11129 
    goto ldv_call_47;
    case 2: 
#line 11132 
    ;
    
#line 11134 
    if (ldv_47_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 11136 
      (*(ldv_47_container->release))(ldv_47_resource_0,ldv_47_resource_1); else ;
    
#line 11144 
    goto ldv_main_47;
    case 3: 
#line 11147 
    ;
    
#line 11151 
    tmp_9 = ldv_undef_int();
    
#line 11151 
    if (tmp_9 != 0) 
#line 11154 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_47_resource_1,ldv_47_ldv_param_1_2,ldv_47_ldv_param_2_3);
    else {
      
#line 11160 
      ldv_47_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 11161 
      ldv_47_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 11166 
      ldv_emg_wrapper_isr_wakeups_read_3(ldv_47_resource_1,ldv_47_ldv_param_1_4,ldv_47_size_cnt,ldv_47_ldv_param_3_5);
      
#line 11170 
      ldv_free((void *)ldv_47_ldv_param_3_5);
      
#line 11171 
      ldv_free((void *)ldv_47_ldv_param_1_4);
    }
    
#line 11175 
    goto ldv_31591;
    default: 
#line 11177 
    ;
    
#line 11177 
    __VERIFIER_assume(0);
  }
  ldv_31591: 
#line 11186 
  ;
  
#line 11186 
  goto ldv_call_47;
  
#line 11188 
  __retres = (void *)0;
  return_label: 
#line 11188 
                return __retres;
}


#line 11193  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_pm_deregister_17_12(void)
{
  int ret;
  struct ldv_struct_platform_instance_17 *cf_arg_34;
  int tmp;
  
#line 11196 
  tmp = ldv_undef_int();
  
#line 11196 
  switch (tmp) {
    case 0: 
#line 11197 
    ;
    
#line 11198 
    ret = pthread_join(ldv_thread_34,(void **)0);
    
#line 11199 
    __VERIFIER_assume(ret == 0);
    
#line 11200 
    goto ldv_31599;
    default: 
#line 11202 
    ;
    
#line 11202 
    __VERIFIER_assume(0);
  }
  ldv_31599: 
#line 11203 
  ;
  
#line 11204 
  return;
}


#line 11208  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_58(void *arg0)
{
  void *__retres;
  struct file *ldv_58_resource_1;
  int ldv_58_ldv_param_2_3;
  long long ldv_58_ldv_param_1_2;
  char *ldv_58_ldv_param_1_4;
  struct inode *ldv_58_resource_0;
  unsigned long ldv_58_size_cnt;
  long long *ldv_58_ldv_param_3_5;
  char *ldv_58_ldv_param_1_6;
  long long *ldv_58_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 11219 
  struct file_operations *ldv_58_container = ldv_emg_alias_pwr_rcvd_awake_beacons_ops_2;
  
#line 11220 
  int ldv_58_ret = ldv_undef_int();
  
#line 11223 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 11227 
  ldv_58_ret = ldv_undef_int();
  
#line 11230 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 11231 
    ldv_58_container = data->arg0;
    
#line 11232 
    ldv_free((void *)data);
  }
  else ;
  
#line 11237 
  ldv_58_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 11238 
  tmp_1 = ldv_undef_int();
  
#line 11238 
  ldv_58_size_cnt = (unsigned long)tmp_1;
  
#line 11245 
  goto ldv_main_58;
  
#line 11247 
  __retres = (void *)0;
  
#line 11247 
  goto return_label;
  ldv_main_58: 
#line 11250 
  ;
  
#line 11253 
  tmp_3 = ldv_undef_int();
  
#line 11253 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 11256 
    ldv_58_ret = (*ldv_emg_alias_simple_open_5)(ldv_58_resource_0,ldv_58_resource_1);
    
#line 11258 
    ldv_58_ret = ldv_filter_err_code(ldv_58_ret);
    
#line 11261 
    tmp_2 = ldv_undef_int();
    
#line 11261 
    if (tmp_2 != 0) {
      
#line 11263 
      __VERIFIER_assume(ldv_58_ret == 0);
      
#line 11270 
      goto ldv_call_58;
    }
    else {
      
#line 11274 
      __VERIFIER_assume(ldv_58_ret != 0);
      
#line 11281 
      goto ldv_main_58;
    }
  }
  else {
    
#line 11286 
    ldv_free((void *)ldv_58_resource_0);
    
#line 11294 
    __retres = (void *)0;
    
#line 11294 
    goto return_label;
  }
  
#line 11297 
  __retres = (void *)0;
  
#line 11297 
  goto return_label;
  ldv_call_58: 
#line 11300 
  ;
  
#line 11303 
  tmp_4 = ldv_undef_int();
  
#line 11303 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 11304 
    ;
    
#line 11306 
    ldv_58_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 11307 
    ldv_58_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 11311 
    if (ldv_58_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 11317 
      __VERIFIER_assume(ldv_58_size_cnt <= 2147479552UL);
      
#line 11319 
      (*(ldv_58_container->write))(ldv_58_resource_1,(char const *)ldv_58_ldv_param_1_6,ldv_58_size_cnt,ldv_58_ldv_param_3_7);
    }
    else ;
    
#line 11324 
    ldv_free((void *)ldv_58_ldv_param_3_7);
    
#line 11325 
    ldv_free((void *)ldv_58_ldv_param_1_6);
    
#line 11332 
    goto ldv_call_58;
    case 2: 
#line 11335 
    ;
    
#line 11337 
    if (ldv_58_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 11339 
      (*(ldv_58_container->release))(ldv_58_resource_0,ldv_58_resource_1); else ;
    
#line 11347 
    goto ldv_main_58;
    case 3: 
#line 11350 
    ;
    
#line 11354 
    tmp_9 = ldv_undef_int();
    
#line 11354 
    if (tmp_9 != 0) 
#line 11357 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_58_resource_1,ldv_58_ldv_param_1_2,ldv_58_ldv_param_2_3);
    else {
      
#line 11363 
      ldv_58_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 11364 
      ldv_58_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 11369 
      ldv_emg_wrapper_pwr_rcvd_awake_beacons_read_3(ldv_58_resource_1,ldv_58_ldv_param_1_4,ldv_58_size_cnt,ldv_58_ldv_param_3_5);
      
#line 11373 
      ldv_free((void *)ldv_58_ldv_param_3_5);
      
#line 11374 
      ldv_free((void *)ldv_58_ldv_param_1_4);
    }
    
#line 11378 
    goto ldv_31621;
    default: 
#line 11380 
    ;
    
#line 11380 
    __VERIFIER_assume(0);
  }
  ldv_31621: 
#line 11389 
  ;
  
#line 11389 
  goto ldv_call_58;
  
#line 11391 
  __retres = (void *)0;
  return_label: 
#line 11391 
                return __retres;
}


#line 11396  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_9(void *arg0)
{
  void *__retres;
  struct file *ldv_9_resource_1;
  int ldv_9_ldv_param_2_3;
  long long ldv_9_ldv_param_1_2;
  char *ldv_9_ldv_param_1_4;
  struct inode *ldv_9_resource_0;
  unsigned long ldv_9_size_cnt;
  long long *ldv_9_ldv_param_3_5;
  char *ldv_9_ldv_param_1_6;
  long long *ldv_9_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 11407 
  struct file_operations *ldv_9_container = ldv_emg_alias_rxpipe_tx_xfr_host_int_trig_rx_data_ops_2;
  
#line 11408 
  int ldv_9_ret = ldv_undef_int();
  
#line 11411 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 11415 
  ldv_9_ret = ldv_undef_int();
  
#line 11418 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 11419 
    ldv_9_container = data->arg0;
    
#line 11420 
    ldv_free((void *)data);
  }
  else ;
  
#line 11425 
  ldv_9_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 11426 
  tmp_1 = ldv_undef_int();
  
#line 11426 
  ldv_9_size_cnt = (unsigned long)tmp_1;
  
#line 11433 
  goto ldv_main_9;
  
#line 11435 
  __retres = (void *)0;
  
#line 11435 
  goto return_label;
  ldv_main_9: 
#line 11438 
  ;
  
#line 11441 
  tmp_3 = ldv_undef_int();
  
#line 11441 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 11444 
    ldv_9_ret = (*ldv_emg_alias_simple_open_5)(ldv_9_resource_0,ldv_9_resource_1);
    
#line 11446 
    ldv_9_ret = ldv_filter_err_code(ldv_9_ret);
    
#line 11449 
    tmp_2 = ldv_undef_int();
    
#line 11449 
    if (tmp_2 != 0) {
      
#line 11451 
      __VERIFIER_assume(ldv_9_ret == 0);
      
#line 11458 
      goto ldv_call_9;
    }
    else {
      
#line 11462 
      __VERIFIER_assume(ldv_9_ret != 0);
      
#line 11469 
      goto ldv_main_9;
    }
  }
  else {
    
#line 11474 
    ldv_free((void *)ldv_9_resource_0);
    
#line 11482 
    __retres = (void *)0;
    
#line 11482 
    goto return_label;
  }
  
#line 11485 
  __retres = (void *)0;
  
#line 11485 
  goto return_label;
  ldv_call_9: 
#line 11488 
  ;
  
#line 11491 
  tmp_4 = ldv_undef_int();
  
#line 11491 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 11492 
    ;
    
#line 11494 
    ldv_9_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 11495 
    ldv_9_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 11499 
    if (ldv_9_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 11505 
      __VERIFIER_assume(ldv_9_size_cnt <= 2147479552UL);
      
#line 11507 
      (*(ldv_9_container->write))(ldv_9_resource_1,(char const *)ldv_9_ldv_param_1_6,ldv_9_size_cnt,ldv_9_ldv_param_3_7);
    }
    else ;
    
#line 11512 
    ldv_free((void *)ldv_9_ldv_param_3_7);
    
#line 11513 
    ldv_free((void *)ldv_9_ldv_param_1_6);
    
#line 11520 
    goto ldv_call_9;
    case 2: 
#line 11523 
    ;
    
#line 11525 
    if (ldv_9_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 11527 
      (*(ldv_9_container->release))(ldv_9_resource_0,ldv_9_resource_1); else ;
    
#line 11535 
    goto ldv_main_9;
    case 3: 
#line 11538 
    ;
    
#line 11542 
    tmp_9 = ldv_undef_int();
    
#line 11542 
    if (tmp_9 != 0) 
#line 11545 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_9_resource_1,ldv_9_ldv_param_1_2,ldv_9_ldv_param_2_3);
    else {
      
#line 11551 
      ldv_9_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 11552 
      ldv_9_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 11557 
      ldv_emg_wrapper_rxpipe_tx_xfr_host_int_trig_rx_data_read_3(ldv_9_resource_1,ldv_9_ldv_param_1_4,ldv_9_size_cnt,ldv_9_ldv_param_3_5);
      
#line 11561 
      ldv_free((void *)ldv_9_ldv_param_3_5);
      
#line 11562 
      ldv_free((void *)ldv_9_ldv_param_1_4);
    }
    
#line 11566 
    goto ldv_31643;
    default: 
#line 11568 
    ;
    
#line 11568 
    __VERIFIER_assume(0);
  }
  ldv_31643: 
#line 11577 
  ;
  
#line 11577 
  goto ldv_call_9;
  
#line 11579 
  __retres = (void *)0;
  return_label: 
#line 11579 
                return __retres;
}


#line 11584  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_61(void *arg0)
{
  void *__retres;
  struct file *ldv_61_resource_1;
  int ldv_61_ldv_param_2_3;
  long long ldv_61_ldv_param_1_2;
  char *ldv_61_ldv_param_1_4;
  struct inode *ldv_61_resource_0;
  unsigned long ldv_61_size_cnt;
  long long *ldv_61_ldv_param_3_5;
  char *ldv_61_ldv_param_1_6;
  long long *ldv_61_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 11595 
  struct file_operations *ldv_61_container = ldv_emg_alias_aes_encrypt_packets_ops_2;
  
#line 11596 
  int ldv_61_ret = ldv_undef_int();
  
#line 11599 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 11603 
  ldv_61_ret = ldv_undef_int();
  
#line 11606 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 11607 
    ldv_61_container = data->arg0;
    
#line 11608 
    ldv_free((void *)data);
  }
  else ;
  
#line 11613 
  ldv_61_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 11614 
  tmp_1 = ldv_undef_int();
  
#line 11614 
  ldv_61_size_cnt = (unsigned long)tmp_1;
  
#line 11621 
  goto ldv_main_61;
  
#line 11623 
  __retres = (void *)0;
  
#line 11623 
  goto return_label;
  ldv_main_61: 
#line 11626 
  ;
  
#line 11629 
  tmp_3 = ldv_undef_int();
  
#line 11629 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 11632 
    ldv_61_ret = (*ldv_emg_alias_simple_open_5)(ldv_61_resource_0,ldv_61_resource_1);
    
#line 11634 
    ldv_61_ret = ldv_filter_err_code(ldv_61_ret);
    
#line 11637 
    tmp_2 = ldv_undef_int();
    
#line 11637 
    if (tmp_2 != 0) {
      
#line 11639 
      __VERIFIER_assume(ldv_61_ret == 0);
      
#line 11646 
      goto ldv_call_61;
    }
    else {
      
#line 11650 
      __VERIFIER_assume(ldv_61_ret != 0);
      
#line 11657 
      goto ldv_main_61;
    }
  }
  else {
    
#line 11662 
    ldv_free((void *)ldv_61_resource_0);
    
#line 11670 
    __retres = (void *)0;
    
#line 11670 
    goto return_label;
  }
  
#line 11673 
  __retres = (void *)0;
  
#line 11673 
  goto return_label;
  ldv_call_61: 
#line 11676 
  ;
  
#line 11679 
  tmp_4 = ldv_undef_int();
  
#line 11679 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 11680 
    ;
    
#line 11682 
    ldv_61_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 11683 
    ldv_61_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 11687 
    if (ldv_61_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 11693 
      __VERIFIER_assume(ldv_61_size_cnt <= 2147479552UL);
      
#line 11695 
      (*(ldv_61_container->write))(ldv_61_resource_1,(char const *)ldv_61_ldv_param_1_6,ldv_61_size_cnt,ldv_61_ldv_param_3_7);
    }
    else ;
    
#line 11700 
    ldv_free((void *)ldv_61_ldv_param_1_6);
    
#line 11701 
    ldv_free((void *)ldv_61_ldv_param_3_7);
    
#line 11708 
    goto ldv_call_61;
    case 2: 
#line 11711 
    ;
    
#line 11713 
    if (ldv_61_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 11715 
      (*(ldv_61_container->release))(ldv_61_resource_0,ldv_61_resource_1); else ;
    
#line 11723 
    goto ldv_main_61;
    case 3: 
#line 11726 
    ;
    
#line 11730 
    tmp_9 = ldv_undef_int();
    
#line 11730 
    if (tmp_9 != 0) 
#line 11733 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_61_resource_1,ldv_61_ldv_param_1_2,ldv_61_ldv_param_2_3);
    else {
      
#line 11739 
      ldv_61_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 11740 
      ldv_61_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 11745 
      ldv_emg_wrapper_aes_encrypt_packets_read_3(ldv_61_resource_1,ldv_61_ldv_param_1_4,ldv_61_size_cnt,ldv_61_ldv_param_3_5);
      
#line 11749 
      ldv_free((void *)ldv_61_ldv_param_3_5);
      
#line 11750 
      ldv_free((void *)ldv_61_ldv_param_1_4);
    }
    
#line 11754 
    goto ldv_31665;
    default: 
#line 11756 
    ;
    
#line 11756 
    __VERIFIER_assume(0);
  }
  ldv_31665: 
#line 11765 
  ;
  
#line 11765 
  goto ldv_call_61;
  
#line 11767 
  __retres = (void *)0;
  return_label: 
#line 11767 
                return __retres;
}


#line 11772  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_76(void *arg0)
{
  void *__retres;
  struct file *ldv_76_resource_1;
  int ldv_76_ldv_param_2_3;
  long long ldv_76_ldv_param_1_2;
  char *ldv_76_ldv_param_1_4;
  struct inode *ldv_76_resource_0;
  unsigned long ldv_76_size_cnt;
  long long *ldv_76_ldv_param_3_5;
  char *ldv_76_ldv_param_1_6;
  long long *ldv_76_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 11783 
  struct file_operations *ldv_76_container = ldv_emg_alias_ps_pspoll_max_apturn_ops_2;
  
#line 11784 
  int ldv_76_ret = ldv_undef_int();
  
#line 11787 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 11791 
  ldv_76_ret = ldv_undef_int();
  
#line 11794 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 11795 
    ldv_76_container = data->arg0;
    
#line 11796 
    ldv_free((void *)data);
  }
  else ;
  
#line 11801 
  ldv_76_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 11802 
  tmp_1 = ldv_undef_int();
  
#line 11802 
  ldv_76_size_cnt = (unsigned long)tmp_1;
  
#line 11809 
  goto ldv_main_76;
  
#line 11811 
  __retres = (void *)0;
  
#line 11811 
  goto return_label;
  ldv_main_76: 
#line 11814 
  ;
  
#line 11817 
  tmp_3 = ldv_undef_int();
  
#line 11817 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 11820 
    ldv_76_ret = (*ldv_emg_alias_simple_open_5)(ldv_76_resource_0,ldv_76_resource_1);
    
#line 11822 
    ldv_76_ret = ldv_filter_err_code(ldv_76_ret);
    
#line 11825 
    tmp_2 = ldv_undef_int();
    
#line 11825 
    if (tmp_2 != 0) {
      
#line 11827 
      __VERIFIER_assume(ldv_76_ret == 0);
      
#line 11834 
      goto ldv_call_76;
    }
    else {
      
#line 11838 
      __VERIFIER_assume(ldv_76_ret != 0);
      
#line 11845 
      goto ldv_main_76;
    }
  }
  else {
    
#line 11850 
    ldv_free((void *)ldv_76_resource_0);
    
#line 11858 
    __retres = (void *)0;
    
#line 11858 
    goto return_label;
  }
  
#line 11861 
  __retres = (void *)0;
  
#line 11861 
  goto return_label;
  ldv_call_76: 
#line 11864 
  ;
  
#line 11867 
  tmp_4 = ldv_undef_int();
  
#line 11867 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 11868 
    ;
    
#line 11870 
    ldv_76_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 11871 
    ldv_76_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 11875 
    if (ldv_76_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 11881 
      __VERIFIER_assume(ldv_76_size_cnt <= 2147479552UL);
      
#line 11883 
      (*(ldv_76_container->write))(ldv_76_resource_1,(char const *)ldv_76_ldv_param_1_6,ldv_76_size_cnt,ldv_76_ldv_param_3_7);
    }
    else ;
    
#line 11888 
    ldv_free((void *)ldv_76_ldv_param_3_7);
    
#line 11889 
    ldv_free((void *)ldv_76_ldv_param_1_6);
    
#line 11896 
    goto ldv_call_76;
    case 2: 
#line 11899 
    ;
    
#line 11901 
    if (ldv_76_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 11903 
      (*(ldv_76_container->release))(ldv_76_resource_0,ldv_76_resource_1); else ;
    
#line 11911 
    goto ldv_main_76;
    case 3: 
#line 11914 
    ;
    
#line 11918 
    tmp_9 = ldv_undef_int();
    
#line 11918 
    if (tmp_9 != 0) 
#line 11921 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_76_resource_1,ldv_76_ldv_param_1_2,ldv_76_ldv_param_2_3);
    else {
      
#line 11927 
      ldv_76_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 11928 
      ldv_76_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 11933 
      ldv_emg_wrapper_ps_pspoll_max_apturn_read_3(ldv_76_resource_1,ldv_76_ldv_param_1_4,ldv_76_size_cnt,ldv_76_ldv_param_3_5);
      
#line 11937 
      ldv_free((void *)ldv_76_ldv_param_1_4);
      
#line 11938 
      ldv_free((void *)ldv_76_ldv_param_3_5);
    }
    
#line 11942 
    goto ldv_31687;
    default: 
#line 11944 
    ;
    
#line 11944 
    __VERIFIER_assume(0);
  }
  ldv_31687: 
#line 11953 
  ;
  
#line 11953 
  goto ldv_call_76;
  
#line 11955 
  __retres = (void *)0;
  return_label: 
#line 11955 
                return __retres;
}


#line 11960  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_21(void *arg0)
{
  void *__retres;
  struct file *ldv_21_resource_1;
  int ldv_21_ldv_param_2_3;
  long long ldv_21_ldv_param_1_2;
  char *ldv_21_ldv_param_1_4;
  struct inode *ldv_21_resource_0;
  unsigned long ldv_21_size_cnt;
  long long *ldv_21_ldv_param_3_5;
  char *ldv_21_ldv_param_1_6;
  long long *ldv_21_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 11971 
  struct file_operations *ldv_21_container = ldv_emg_alias_rx_path_reset_ops_2;
  
#line 11972 
  int ldv_21_ret = ldv_undef_int();
  
#line 11975 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 11979 
  ldv_21_ret = ldv_undef_int();
  
#line 11982 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 11983 
    ldv_21_container = data->arg0;
    
#line 11984 
    ldv_free((void *)data);
  }
  else ;
  
#line 11989 
  ldv_21_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 11990 
  tmp_1 = ldv_undef_int();
  
#line 11990 
  ldv_21_size_cnt = (unsigned long)tmp_1;
  
#line 11997 
  goto ldv_main_21;
  
#line 11999 
  __retres = (void *)0;
  
#line 11999 
  goto return_label;
  ldv_main_21: 
#line 12002 
  ;
  
#line 12005 
  tmp_3 = ldv_undef_int();
  
#line 12005 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 12008 
    ldv_21_ret = (*ldv_emg_alias_simple_open_5)(ldv_21_resource_0,ldv_21_resource_1);
    
#line 12010 
    ldv_21_ret = ldv_filter_err_code(ldv_21_ret);
    
#line 12013 
    tmp_2 = ldv_undef_int();
    
#line 12013 
    if (tmp_2 != 0) {
      
#line 12015 
      __VERIFIER_assume(ldv_21_ret == 0);
      
#line 12022 
      goto ldv_call_21;
    }
    else {
      
#line 12026 
      __VERIFIER_assume(ldv_21_ret != 0);
      
#line 12033 
      goto ldv_main_21;
    }
  }
  else {
    
#line 12038 
    ldv_free((void *)ldv_21_resource_0);
    
#line 12046 
    __retres = (void *)0;
    
#line 12046 
    goto return_label;
  }
  
#line 12049 
  __retres = (void *)0;
  
#line 12049 
  goto return_label;
  ldv_call_21: 
#line 12052 
  ;
  
#line 12055 
  tmp_4 = ldv_undef_int();
  
#line 12055 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 12056 
    ;
    
#line 12058 
    ldv_21_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 12059 
    ldv_21_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 12063 
    if (ldv_21_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 12069 
      __VERIFIER_assume(ldv_21_size_cnt <= 2147479552UL);
      
#line 12071 
      (*(ldv_21_container->write))(ldv_21_resource_1,(char const *)ldv_21_ldv_param_1_6,ldv_21_size_cnt,ldv_21_ldv_param_3_7);
    }
    else ;
    
#line 12076 
    ldv_free((void *)ldv_21_ldv_param_3_7);
    
#line 12077 
    ldv_free((void *)ldv_21_ldv_param_1_6);
    
#line 12084 
    goto ldv_call_21;
    case 2: 
#line 12087 
    ;
    
#line 12089 
    if (ldv_21_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 12091 
      (*(ldv_21_container->release))(ldv_21_resource_0,ldv_21_resource_1); else ;
    
#line 12099 
    goto ldv_main_21;
    case 3: 
#line 12102 
    ;
    
#line 12106 
    tmp_9 = ldv_undef_int();
    
#line 12106 
    if (tmp_9 != 0) 
#line 12109 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_21_resource_1,ldv_21_ldv_param_1_2,ldv_21_ldv_param_2_3);
    else {
      
#line 12115 
      ldv_21_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 12116 
      ldv_21_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 12121 
      ldv_emg_wrapper_rx_path_reset_read_3(ldv_21_resource_1,ldv_21_ldv_param_1_4,ldv_21_size_cnt,ldv_21_ldv_param_3_5);
      
#line 12125 
      ldv_free((void *)ldv_21_ldv_param_3_5);
      
#line 12126 
      ldv_free((void *)ldv_21_ldv_param_1_4);
    }
    
#line 12130 
    goto ldv_31709;
    default: 
#line 12132 
    ;
    
#line 12132 
    __VERIFIER_assume(0);
  }
  ldv_31709: 
#line 12141 
  ;
  
#line 12141 
  goto ldv_call_21;
  
#line 12143 
  __retres = (void *)0;
  return_label: 
#line 12143 
                return __retres;
}


#line 12148  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_emg_platform_driver_unregister(struct platform_driver *arg0)
{
  
#line 12151 
  struct platform_driver *ldv_3_platform_driver = ldv_emg_alias_wl12xx_driver_2;
  
#line 12154 
  ldv_3_platform_driver = arg0;
  
#line 12158 
  ldv_dispatch_deregister_3_1(ldv_3_platform_driver);
  
#line 12162 
  goto return_label;
  return_label: 
#line 12164 
                return;
}


#line 12169  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_6(void *arg0)
{
  void *__retres;
  struct file *ldv_6_resource_1;
  int ldv_6_ldv_param_2_3;
  long long ldv_6_ldv_param_1_2;
  char *ldv_6_ldv_param_1_4;
  struct inode *ldv_6_resource_0;
  unsigned long ldv_6_size_cnt;
  long long *ldv_6_ldv_param_3_5;
  char *ldv_6_ldv_param_1_6;
  long long *ldv_6_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 12180 
  struct file_operations *ldv_6_container = ldv_emg_alias_isr_irqs_ops_2;
  
#line 12181 
  int ldv_6_ret = ldv_undef_int();
  
#line 12184 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 12188 
  ldv_6_ret = ldv_undef_int();
  
#line 12191 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 12192 
    ldv_6_container = data->arg0;
    
#line 12193 
    ldv_free((void *)data);
  }
  else ;
  
#line 12198 
  ldv_6_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 12199 
  tmp_1 = ldv_undef_int();
  
#line 12199 
  ldv_6_size_cnt = (unsigned long)tmp_1;
  
#line 12206 
  goto ldv_main_6;
  
#line 12208 
  __retres = (void *)0;
  
#line 12208 
  goto return_label;
  ldv_main_6: 
#line 12211 
  ;
  
#line 12214 
  tmp_3 = ldv_undef_int();
  
#line 12214 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 12217 
    ldv_6_ret = (*ldv_emg_alias_simple_open_5)(ldv_6_resource_0,ldv_6_resource_1);
    
#line 12219 
    ldv_6_ret = ldv_filter_err_code(ldv_6_ret);
    
#line 12222 
    tmp_2 = ldv_undef_int();
    
#line 12222 
    if (tmp_2 != 0) {
      
#line 12224 
      __VERIFIER_assume(ldv_6_ret == 0);
      
#line 12231 
      goto ldv_call_6;
    }
    else {
      
#line 12235 
      __VERIFIER_assume(ldv_6_ret != 0);
      
#line 12242 
      goto ldv_main_6;
    }
  }
  else {
    
#line 12247 
    ldv_free((void *)ldv_6_resource_0);
    
#line 12255 
    __retres = (void *)0;
    
#line 12255 
    goto return_label;
  }
  
#line 12258 
  __retres = (void *)0;
  
#line 12258 
  goto return_label;
  ldv_call_6: 
#line 12261 
  ;
  
#line 12264 
  tmp_4 = ldv_undef_int();
  
#line 12264 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 12265 
    ;
    
#line 12267 
    ldv_6_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 12268 
    ldv_6_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 12272 
    if (ldv_6_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 12278 
      __VERIFIER_assume(ldv_6_size_cnt <= 2147479552UL);
      
#line 12280 
      (*(ldv_6_container->write))(ldv_6_resource_1,(char const *)ldv_6_ldv_param_1_6,ldv_6_size_cnt,ldv_6_ldv_param_3_7);
    }
    else ;
    
#line 12285 
    ldv_free((void *)ldv_6_ldv_param_3_7);
    
#line 12286 
    ldv_free((void *)ldv_6_ldv_param_1_6);
    
#line 12293 
    goto ldv_call_6;
    case 2: 
#line 12296 
    ;
    
#line 12298 
    if (ldv_6_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 12300 
      (*(ldv_6_container->release))(ldv_6_resource_0,ldv_6_resource_1); else ;
    
#line 12308 
    goto ldv_main_6;
    case 3: 
#line 12311 
    ;
    
#line 12315 
    tmp_9 = ldv_undef_int();
    
#line 12315 
    if (tmp_9 != 0) 
#line 12318 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_6_resource_1,ldv_6_ldv_param_1_2,ldv_6_ldv_param_2_3);
    else {
      
#line 12324 
      ldv_6_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 12325 
      ldv_6_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 12330 
      ldv_emg_wrapper_isr_irqs_read_3(ldv_6_resource_1,ldv_6_ldv_param_1_4,ldv_6_size_cnt,ldv_6_ldv_param_3_5);
      
#line 12334 
      ldv_free((void *)ldv_6_ldv_param_3_5);
      
#line 12335 
      ldv_free((void *)ldv_6_ldv_param_1_4);
    }
    
#line 12339 
    goto ldv_31735;
    default: 
#line 12341 
    ;
    
#line 12341 
    __VERIFIER_assume(0);
  }
  ldv_31735: 
#line 12350 
  ;
  
#line 12350 
  goto ldv_call_6;
  
#line 12352 
  __retres = (void *)0;
  return_label: 
#line 12352 
                return __retres;
}


#line 12357  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_50(void *arg0)
{
  void *__retres;
  struct file *ldv_50_resource_1;
  int ldv_50_ldv_param_2_3;
  long long ldv_50_ldv_param_1_2;
  char *ldv_50_ldv_param_1_4;
  struct inode *ldv_50_resource_0;
  unsigned long ldv_50_size_cnt;
  long long *ldv_50_ldv_param_3_5;
  char *ldv_50_ldv_param_1_6;
  long long *ldv_50_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 12368 
  struct file_operations *ldv_50_container = ldv_emg_alias_rx_hdr_overflow_ops_2;
  
#line 12369 
  int ldv_50_ret = ldv_undef_int();
  
#line 12372 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 12376 
  ldv_50_ret = ldv_undef_int();
  
#line 12379 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 12380 
    ldv_50_container = data->arg0;
    
#line 12381 
    ldv_free((void *)data);
  }
  else ;
  
#line 12386 
  ldv_50_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 12387 
  tmp_1 = ldv_undef_int();
  
#line 12387 
  ldv_50_size_cnt = (unsigned long)tmp_1;
  
#line 12394 
  goto ldv_main_50;
  
#line 12396 
  __retres = (void *)0;
  
#line 12396 
  goto return_label;
  ldv_main_50: 
#line 12399 
  ;
  
#line 12402 
  tmp_3 = ldv_undef_int();
  
#line 12402 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 12405 
    ldv_50_ret = (*ldv_emg_alias_simple_open_5)(ldv_50_resource_0,ldv_50_resource_1);
    
#line 12407 
    ldv_50_ret = ldv_filter_err_code(ldv_50_ret);
    
#line 12410 
    tmp_2 = ldv_undef_int();
    
#line 12410 
    if (tmp_2 != 0) {
      
#line 12412 
      __VERIFIER_assume(ldv_50_ret == 0);
      
#line 12419 
      goto ldv_call_50;
    }
    else {
      
#line 12423 
      __VERIFIER_assume(ldv_50_ret != 0);
      
#line 12430 
      goto ldv_main_50;
    }
  }
  else {
    
#line 12435 
    ldv_free((void *)ldv_50_resource_0);
    
#line 12443 
    __retres = (void *)0;
    
#line 12443 
    goto return_label;
  }
  
#line 12446 
  __retres = (void *)0;
  
#line 12446 
  goto return_label;
  ldv_call_50: 
#line 12449 
  ;
  
#line 12452 
  tmp_4 = ldv_undef_int();
  
#line 12452 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 12453 
    ;
    
#line 12455 
    ldv_50_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 12456 
    ldv_50_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 12460 
    if (ldv_50_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 12466 
      __VERIFIER_assume(ldv_50_size_cnt <= 2147479552UL);
      
#line 12468 
      (*(ldv_50_container->write))(ldv_50_resource_1,(char const *)ldv_50_ldv_param_1_6,ldv_50_size_cnt,ldv_50_ldv_param_3_7);
    }
    else ;
    
#line 12473 
    ldv_free((void *)ldv_50_ldv_param_1_6);
    
#line 12474 
    ldv_free((void *)ldv_50_ldv_param_3_7);
    
#line 12481 
    goto ldv_call_50;
    case 2: 
#line 12484 
    ;
    
#line 12486 
    if (ldv_50_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 12488 
      (*(ldv_50_container->release))(ldv_50_resource_0,ldv_50_resource_1); else ;
    
#line 12496 
    goto ldv_main_50;
    case 3: 
#line 12499 
    ;
    
#line 12503 
    tmp_9 = ldv_undef_int();
    
#line 12503 
    if (tmp_9 != 0) 
#line 12506 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_50_resource_1,ldv_50_ldv_param_1_2,ldv_50_ldv_param_2_3);
    else {
      
#line 12512 
      ldv_50_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 12513 
      ldv_50_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 12518 
      ldv_emg_wrapper_rx_hdr_overflow_read_3(ldv_50_resource_1,ldv_50_ldv_param_1_4,ldv_50_size_cnt,ldv_50_ldv_param_3_5);
      
#line 12522 
      ldv_free((void *)ldv_50_ldv_param_3_5);
      
#line 12523 
      ldv_free((void *)ldv_50_ldv_param_1_4);
    }
    
#line 12527 
    goto ldv_31757;
    default: 
#line 12529 
    ;
    
#line 12529 
    __VERIFIER_assume(0);
  }
  ldv_31757: 
#line 12538 
  ;
  
#line 12538 
  goto ldv_call_50;
  
#line 12540 
  __retres = (void *)0;
  return_label: 
#line 12540 
                return __retres;
}


#line 12545  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_74(void *arg0)
{
  void *__retres;
  struct file *ldv_74_resource_1;
  int ldv_74_ldv_param_2_3;
  long long ldv_74_ldv_param_1_2;
  char *ldv_74_ldv_param_1_4;
  struct inode *ldv_74_resource_0;
  unsigned long ldv_74_size_cnt;
  long long *ldv_74_ldv_param_3_5;
  char *ldv_74_ldv_param_1_6;
  long long *ldv_74_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 12556 
  struct file_operations *ldv_74_container = ldv_emg_alias_event_oom_late_ops_2;
  
#line 12557 
  int ldv_74_ret = ldv_undef_int();
  
#line 12560 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 12564 
  ldv_74_ret = ldv_undef_int();
  
#line 12567 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 12568 
    ldv_74_container = data->arg0;
    
#line 12569 
    ldv_free((void *)data);
  }
  else ;
  
#line 12574 
  ldv_74_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 12575 
  tmp_1 = ldv_undef_int();
  
#line 12575 
  ldv_74_size_cnt = (unsigned long)tmp_1;
  
#line 12582 
  goto ldv_main_74;
  
#line 12584 
  __retres = (void *)0;
  
#line 12584 
  goto return_label;
  ldv_main_74: 
#line 12587 
  ;
  
#line 12590 
  tmp_3 = ldv_undef_int();
  
#line 12590 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 12593 
    ldv_74_ret = (*ldv_emg_alias_simple_open_5)(ldv_74_resource_0,ldv_74_resource_1);
    
#line 12595 
    ldv_74_ret = ldv_filter_err_code(ldv_74_ret);
    
#line 12598 
    tmp_2 = ldv_undef_int();
    
#line 12598 
    if (tmp_2 != 0) {
      
#line 12600 
      __VERIFIER_assume(ldv_74_ret == 0);
      
#line 12607 
      goto ldv_call_74;
    }
    else {
      
#line 12611 
      __VERIFIER_assume(ldv_74_ret != 0);
      
#line 12618 
      goto ldv_main_74;
    }
  }
  else {
    
#line 12623 
    ldv_free((void *)ldv_74_resource_0);
    
#line 12631 
    __retres = (void *)0;
    
#line 12631 
    goto return_label;
  }
  
#line 12634 
  __retres = (void *)0;
  
#line 12634 
  goto return_label;
  ldv_call_74: 
#line 12637 
  ;
  
#line 12640 
  tmp_4 = ldv_undef_int();
  
#line 12640 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 12641 
    ;
    
#line 12643 
    ldv_74_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 12644 
    ldv_74_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 12648 
    if (ldv_74_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 12654 
      __VERIFIER_assume(ldv_74_size_cnt <= 2147479552UL);
      
#line 12656 
      (*(ldv_74_container->write))(ldv_74_resource_1,(char const *)ldv_74_ldv_param_1_6,ldv_74_size_cnt,ldv_74_ldv_param_3_7);
    }
    else ;
    
#line 12661 
    ldv_free((void *)ldv_74_ldv_param_3_7);
    
#line 12662 
    ldv_free((void *)ldv_74_ldv_param_1_6);
    
#line 12669 
    goto ldv_call_74;
    case 2: 
#line 12672 
    ;
    
#line 12674 
    if (ldv_74_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 12676 
      (*(ldv_74_container->release))(ldv_74_resource_0,ldv_74_resource_1); else ;
    
#line 12684 
    goto ldv_main_74;
    case 3: 
#line 12687 
    ;
    
#line 12691 
    tmp_9 = ldv_undef_int();
    
#line 12691 
    if (tmp_9 != 0) 
#line 12694 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_74_resource_1,ldv_74_ldv_param_1_2,ldv_74_ldv_param_2_3);
    else {
      
#line 12700 
      ldv_74_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 12701 
      ldv_74_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 12706 
      ldv_emg_wrapper_event_oom_late_read_3(ldv_74_resource_1,ldv_74_ldv_param_1_4,ldv_74_size_cnt,ldv_74_ldv_param_3_5);
      
#line 12710 
      ldv_free((void *)ldv_74_ldv_param_1_4);
      
#line 12711 
      ldv_free((void *)ldv_74_ldv_param_3_5);
    }
    
#line 12715 
    goto ldv_31779;
    default: 
#line 12717 
    ;
    
#line 12717 
    __VERIFIER_assume(0);
  }
  ldv_31779: 
#line 12726 
  ;
  
#line 12726 
  goto ldv_call_74;
  
#line 12728 
  __retres = (void *)0;
  return_label: 
#line 12728 
                return __retres;
}


#line 12733  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_30(void *arg0)
{
  void *__retres;
  struct file *ldv_30_resource_1;
  int ldv_30_ldv_param_2_3;
  long long ldv_30_ldv_param_1_2;
  char *ldv_30_ldv_param_1_4;
  struct inode *ldv_30_resource_0;
  unsigned long ldv_30_size_cnt;
  long long *ldv_30_ldv_param_3_5;
  char *ldv_30_ldv_param_1_6;
  long long *ldv_30_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 12744 
  struct file_operations *ldv_30_container = ldv_emg_alias_rx_fcs_err_ops_2;
  
#line 12745 
  int ldv_30_ret = ldv_undef_int();
  
#line 12748 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 12752 
  ldv_30_ret = ldv_undef_int();
  
#line 12755 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 12756 
    ldv_30_container = data->arg0;
    
#line 12757 
    ldv_free((void *)data);
  }
  else ;
  
#line 12762 
  ldv_30_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 12763 
  tmp_1 = ldv_undef_int();
  
#line 12763 
  ldv_30_size_cnt = (unsigned long)tmp_1;
  
#line 12770 
  goto ldv_main_30;
  
#line 12772 
  __retres = (void *)0;
  
#line 12772 
  goto return_label;
  ldv_main_30: 
#line 12775 
  ;
  
#line 12778 
  tmp_3 = ldv_undef_int();
  
#line 12778 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 12781 
    ldv_30_ret = (*ldv_emg_alias_simple_open_5)(ldv_30_resource_0,ldv_30_resource_1);
    
#line 12783 
    ldv_30_ret = ldv_filter_err_code(ldv_30_ret);
    
#line 12786 
    tmp_2 = ldv_undef_int();
    
#line 12786 
    if (tmp_2 != 0) {
      
#line 12788 
      __VERIFIER_assume(ldv_30_ret == 0);
      
#line 12795 
      goto ldv_call_30;
    }
    else {
      
#line 12799 
      __VERIFIER_assume(ldv_30_ret != 0);
      
#line 12806 
      goto ldv_main_30;
    }
  }
  else {
    
#line 12811 
    ldv_free((void *)ldv_30_resource_0);
    
#line 12819 
    __retres = (void *)0;
    
#line 12819 
    goto return_label;
  }
  
#line 12822 
  __retres = (void *)0;
  
#line 12822 
  goto return_label;
  ldv_call_30: 
#line 12825 
  ;
  
#line 12828 
  tmp_4 = ldv_undef_int();
  
#line 12828 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 12829 
    ;
    
#line 12831 
    ldv_30_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 12832 
    ldv_30_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 12836 
    if (ldv_30_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 12842 
      __VERIFIER_assume(ldv_30_size_cnt <= 2147479552UL);
      
#line 12844 
      (*(ldv_30_container->write))(ldv_30_resource_1,(char const *)ldv_30_ldv_param_1_6,ldv_30_size_cnt,ldv_30_ldv_param_3_7);
    }
    else ;
    
#line 12849 
    ldv_free((void *)ldv_30_ldv_param_1_6);
    
#line 12850 
    ldv_free((void *)ldv_30_ldv_param_3_7);
    
#line 12857 
    goto ldv_call_30;
    case 2: 
#line 12860 
    ;
    
#line 12862 
    if (ldv_30_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 12864 
      (*(ldv_30_container->release))(ldv_30_resource_0,ldv_30_resource_1); else ;
    
#line 12872 
    goto ldv_main_30;
    case 3: 
#line 12875 
    ;
    
#line 12879 
    tmp_9 = ldv_undef_int();
    
#line 12879 
    if (tmp_9 != 0) 
#line 12882 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_30_resource_1,ldv_30_ldv_param_1_2,ldv_30_ldv_param_2_3);
    else {
      
#line 12888 
      ldv_30_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 12889 
      ldv_30_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 12894 
      ldv_emg_wrapper_rx_fcs_err_read_3(ldv_30_resource_1,ldv_30_ldv_param_1_4,ldv_30_size_cnt,ldv_30_ldv_param_3_5);
      
#line 12898 
      ldv_free((void *)ldv_30_ldv_param_3_5);
      
#line 12899 
      ldv_free((void *)ldv_30_ldv_param_1_4);
    }
    
#line 12903 
    goto ldv_31801;
    default: 
#line 12905 
    ;
    
#line 12905 
    __VERIFIER_assume(0);
  }
  ldv_31801: 
#line 12914 
  ;
  
#line 12914 
  goto ldv_call_30;
  
#line 12916 
  __retres = (void *)0;
  return_label: 
#line 12916 
                return __retres;
}


#line 12921  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_39(void *arg0)
{
  void *__retres;
  struct file *ldv_39_resource_1;
  int ldv_39_ldv_param_2_3;
  long long ldv_39_ldv_param_1_2;
  char *ldv_39_ldv_param_1_4;
  struct inode *ldv_39_resource_0;
  unsigned long ldv_39_size_cnt;
  long long *ldv_39_ldv_param_3_5;
  char *ldv_39_ldv_param_1_6;
  long long *ldv_39_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 12932 
  struct file_operations *ldv_39_container = ldv_emg_alias_rx_out_of_mem_ops_2;
  
#line 12933 
  int ldv_39_ret = ldv_undef_int();
  
#line 12936 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 12940 
  ldv_39_ret = ldv_undef_int();
  
#line 12943 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 12944 
    ldv_39_container = data->arg0;
    
#line 12945 
    ldv_free((void *)data);
  }
  else ;
  
#line 12950 
  ldv_39_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 12951 
  tmp_1 = ldv_undef_int();
  
#line 12951 
  ldv_39_size_cnt = (unsigned long)tmp_1;
  
#line 12958 
  goto ldv_main_39;
  
#line 12960 
  __retres = (void *)0;
  
#line 12960 
  goto return_label;
  ldv_main_39: 
#line 12963 
  ;
  
#line 12966 
  tmp_3 = ldv_undef_int();
  
#line 12966 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 12969 
    ldv_39_ret = (*ldv_emg_alias_simple_open_5)(ldv_39_resource_0,ldv_39_resource_1);
    
#line 12971 
    ldv_39_ret = ldv_filter_err_code(ldv_39_ret);
    
#line 12974 
    tmp_2 = ldv_undef_int();
    
#line 12974 
    if (tmp_2 != 0) {
      
#line 12976 
      __VERIFIER_assume(ldv_39_ret == 0);
      
#line 12983 
      goto ldv_call_39;
    }
    else {
      
#line 12987 
      __VERIFIER_assume(ldv_39_ret != 0);
      
#line 12994 
      goto ldv_main_39;
    }
  }
  else {
    
#line 12999 
    ldv_free((void *)ldv_39_resource_0);
    
#line 13007 
    __retres = (void *)0;
    
#line 13007 
    goto return_label;
  }
  
#line 13010 
  __retres = (void *)0;
  
#line 13010 
  goto return_label;
  ldv_call_39: 
#line 13013 
  ;
  
#line 13016 
  tmp_4 = ldv_undef_int();
  
#line 13016 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 13017 
    ;
    
#line 13019 
    ldv_39_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 13020 
    ldv_39_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 13024 
    if (ldv_39_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 13030 
      __VERIFIER_assume(ldv_39_size_cnt <= 2147479552UL);
      
#line 13032 
      (*(ldv_39_container->write))(ldv_39_resource_1,(char const *)ldv_39_ldv_param_1_6,ldv_39_size_cnt,ldv_39_ldv_param_3_7);
    }
    else ;
    
#line 13037 
    ldv_free((void *)ldv_39_ldv_param_3_7);
    
#line 13038 
    ldv_free((void *)ldv_39_ldv_param_1_6);
    
#line 13045 
    goto ldv_call_39;
    case 2: 
#line 13048 
    ;
    
#line 13050 
    if (ldv_39_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 13052 
      (*(ldv_39_container->release))(ldv_39_resource_0,ldv_39_resource_1); else ;
    
#line 13060 
    goto ldv_main_39;
    case 3: 
#line 13063 
    ;
    
#line 13067 
    tmp_9 = ldv_undef_int();
    
#line 13067 
    if (tmp_9 != 0) 
#line 13070 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_39_resource_1,ldv_39_ldv_param_1_2,ldv_39_ldv_param_2_3);
    else {
      
#line 13076 
      ldv_39_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 13077 
      ldv_39_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 13082 
      ldv_emg_wrapper_rx_out_of_mem_read_3(ldv_39_resource_1,ldv_39_ldv_param_1_4,ldv_39_size_cnt,ldv_39_ldv_param_3_5);
      
#line 13086 
      ldv_free((void *)ldv_39_ldv_param_3_5);
      
#line 13087 
      ldv_free((void *)ldv_39_ldv_param_1_4);
    }
    
#line 13091 
    goto ldv_31823;
    default: 
#line 13093 
    ;
    
#line 13093 
    __VERIFIER_assume(0);
  }
  ldv_31823: 
#line 13102 
  ;
  
#line 13102 
  goto ldv_call_39;
  
#line 13104 
  __retres = (void *)0;
  return_label: 
#line 13104 
                return __retres;
}


#line 13109  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_62(void *arg0)
{
  void *__retres;
  struct file *ldv_62_resource_1;
  int ldv_62_ldv_param_2_3;
  long long ldv_62_ldv_param_1_2;
  char *ldv_62_ldv_param_1_4;
  struct inode *ldv_62_resource_0;
  unsigned long ldv_62_size_cnt;
  long long *ldv_62_ldv_param_3_5;
  char *ldv_62_ldv_param_1_6;
  long long *ldv_62_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 13120 
  struct file_operations *ldv_62_container = ldv_emg_alias_aes_encrypt_interrupt_ops_2;
  
#line 13121 
  int ldv_62_ret = ldv_undef_int();
  
#line 13124 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 13128 
  ldv_62_ret = ldv_undef_int();
  
#line 13131 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 13132 
    ldv_62_container = data->arg0;
    
#line 13133 
    ldv_free((void *)data);
  }
  else ;
  
#line 13138 
  ldv_62_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 13139 
  tmp_1 = ldv_undef_int();
  
#line 13139 
  ldv_62_size_cnt = (unsigned long)tmp_1;
  
#line 13146 
  goto ldv_main_62;
  
#line 13148 
  __retres = (void *)0;
  
#line 13148 
  goto return_label;
  ldv_main_62: 
#line 13151 
  ;
  
#line 13154 
  tmp_3 = ldv_undef_int();
  
#line 13154 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 13157 
    ldv_62_ret = (*ldv_emg_alias_simple_open_5)(ldv_62_resource_0,ldv_62_resource_1);
    
#line 13159 
    ldv_62_ret = ldv_filter_err_code(ldv_62_ret);
    
#line 13162 
    tmp_2 = ldv_undef_int();
    
#line 13162 
    if (tmp_2 != 0) {
      
#line 13164 
      __VERIFIER_assume(ldv_62_ret == 0);
      
#line 13171 
      goto ldv_call_62;
    }
    else {
      
#line 13175 
      __VERIFIER_assume(ldv_62_ret != 0);
      
#line 13182 
      goto ldv_main_62;
    }
  }
  else {
    
#line 13187 
    ldv_free((void *)ldv_62_resource_0);
    
#line 13195 
    __retres = (void *)0;
    
#line 13195 
    goto return_label;
  }
  
#line 13198 
  __retres = (void *)0;
  
#line 13198 
  goto return_label;
  ldv_call_62: 
#line 13201 
  ;
  
#line 13204 
  tmp_4 = ldv_undef_int();
  
#line 13204 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 13205 
    ;
    
#line 13207 
    ldv_62_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 13208 
    ldv_62_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 13212 
    if (ldv_62_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 13218 
      __VERIFIER_assume(ldv_62_size_cnt <= 2147479552UL);
      
#line 13220 
      (*(ldv_62_container->write))(ldv_62_resource_1,(char const *)ldv_62_ldv_param_1_6,ldv_62_size_cnt,ldv_62_ldv_param_3_7);
    }
    else ;
    
#line 13225 
    ldv_free((void *)ldv_62_ldv_param_3_7);
    
#line 13226 
    ldv_free((void *)ldv_62_ldv_param_1_6);
    
#line 13233 
    goto ldv_call_62;
    case 2: 
#line 13236 
    ;
    
#line 13238 
    if (ldv_62_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 13240 
      (*(ldv_62_container->release))(ldv_62_resource_0,ldv_62_resource_1); else ;
    
#line 13248 
    goto ldv_main_62;
    case 3: 
#line 13251 
    ;
    
#line 13255 
    tmp_9 = ldv_undef_int();
    
#line 13255 
    if (tmp_9 != 0) 
#line 13258 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_62_resource_1,ldv_62_ldv_param_1_2,ldv_62_ldv_param_2_3);
    else {
      
#line 13264 
      ldv_62_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 13265 
      ldv_62_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 13270 
      ldv_emg_wrapper_aes_encrypt_interrupt_read_3(ldv_62_resource_1,ldv_62_ldv_param_1_4,ldv_62_size_cnt,ldv_62_ldv_param_3_5);
      
#line 13274 
      ldv_free((void *)ldv_62_ldv_param_3_5);
      
#line 13275 
      ldv_free((void *)ldv_62_ldv_param_1_4);
    }
    
#line 13279 
    goto ldv_31845;
    default: 
#line 13281 
    ;
    
#line 13281 
    __VERIFIER_assume(0);
  }
  ldv_31845: 
#line 13290 
  ;
  
#line 13290 
  goto ldv_call_62;
  
#line 13292 
  __retres = (void *)0;
  return_label: 
#line 13292 
                return __retres;
}


#line 13297  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_45(void *arg0)
{
  void *__retres;
  struct file *ldv_45_resource_1;
  int ldv_45_ldv_param_2_3;
  long long ldv_45_ldv_param_1_2;
  char *ldv_45_ldv_param_1_4;
  struct inode *ldv_45_resource_0;
  unsigned long ldv_45_size_cnt;
  long long *ldv_45_ldv_param_3_5;
  char *ldv_45_ldv_param_1_6;
  long long *ldv_45_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 13308 
  struct file_operations *ldv_45_container = ldv_emg_alias_rx_xfr_hint_trig_ops_2;
  
#line 13309 
  int ldv_45_ret = ldv_undef_int();
  
#line 13312 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 13316 
  ldv_45_ret = ldv_undef_int();
  
#line 13319 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 13320 
    ldv_45_container = data->arg0;
    
#line 13321 
    ldv_free((void *)data);
  }
  else ;
  
#line 13326 
  ldv_45_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 13327 
  tmp_1 = ldv_undef_int();
  
#line 13327 
  ldv_45_size_cnt = (unsigned long)tmp_1;
  
#line 13334 
  goto ldv_main_45;
  
#line 13336 
  __retres = (void *)0;
  
#line 13336 
  goto return_label;
  ldv_main_45: 
#line 13339 
  ;
  
#line 13342 
  tmp_3 = ldv_undef_int();
  
#line 13342 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 13345 
    ldv_45_ret = (*ldv_emg_alias_simple_open_5)(ldv_45_resource_0,ldv_45_resource_1);
    
#line 13347 
    ldv_45_ret = ldv_filter_err_code(ldv_45_ret);
    
#line 13350 
    tmp_2 = ldv_undef_int();
    
#line 13350 
    if (tmp_2 != 0) {
      
#line 13352 
      __VERIFIER_assume(ldv_45_ret == 0);
      
#line 13359 
      goto ldv_call_45;
    }
    else {
      
#line 13363 
      __VERIFIER_assume(ldv_45_ret != 0);
      
#line 13370 
      goto ldv_main_45;
    }
  }
  else {
    
#line 13375 
    ldv_free((void *)ldv_45_resource_0);
    
#line 13383 
    __retres = (void *)0;
    
#line 13383 
    goto return_label;
  }
  
#line 13386 
  __retres = (void *)0;
  
#line 13386 
  goto return_label;
  ldv_call_45: 
#line 13389 
  ;
  
#line 13392 
  tmp_4 = ldv_undef_int();
  
#line 13392 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 13393 
    ;
    
#line 13395 
    ldv_45_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 13396 
    ldv_45_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 13400 
    if (ldv_45_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 13406 
      __VERIFIER_assume(ldv_45_size_cnt <= 2147479552UL);
      
#line 13408 
      (*(ldv_45_container->write))(ldv_45_resource_1,(char const *)ldv_45_ldv_param_1_6,ldv_45_size_cnt,ldv_45_ldv_param_3_7);
    }
    else ;
    
#line 13413 
    ldv_free((void *)ldv_45_ldv_param_3_7);
    
#line 13414 
    ldv_free((void *)ldv_45_ldv_param_1_6);
    
#line 13421 
    goto ldv_call_45;
    case 2: 
#line 13424 
    ;
    
#line 13426 
    if (ldv_45_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 13428 
      (*(ldv_45_container->release))(ldv_45_resource_0,ldv_45_resource_1); else ;
    
#line 13436 
    goto ldv_main_45;
    case 3: 
#line 13439 
    ;
    
#line 13443 
    tmp_9 = ldv_undef_int();
    
#line 13443 
    if (tmp_9 != 0) 
#line 13446 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_45_resource_1,ldv_45_ldv_param_1_2,ldv_45_ldv_param_2_3);
    else {
      
#line 13452 
      ldv_45_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 13453 
      ldv_45_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 13458 
      ldv_emg_wrapper_rx_xfr_hint_trig_read_3(ldv_45_resource_1,ldv_45_ldv_param_1_4,ldv_45_size_cnt,ldv_45_ldv_param_3_5);
      
#line 13462 
      ldv_free((void *)ldv_45_ldv_param_1_4);
      
#line 13463 
      ldv_free((void *)ldv_45_ldv_param_3_5);
    }
    
#line 13467 
    goto ldv_31867;
    default: 
#line 13469 
    ;
    
#line 13469 
    __VERIFIER_assume(0);
  }
  ldv_31867: 
#line 13478 
  ;
  
#line 13478 
  goto ldv_call_45;
  
#line 13480 
  __retres = (void *)0;
  return_label: 
#line 13480 
                return __retres;
}


#line 13485  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_platform_instance_17(void *arg0)
{
  void *__retres;
  struct platform_device *ldv_17_resource;
  int tmp_1;
  int tmp_2;
  
#line 13489 
  struct platform_driver *ldv_17_container = ldv_emg_alias_wl12xx_driver_2;
  
#line 13490 
  int ldv_17_probed = 1;
  
#line 13492 
  struct ldv_struct_platform_instance_17 *data = (struct ldv_struct_platform_instance_17 *)arg0;
  
#line 13496 
  ldv_17_probed = 1;
  
#line 13499 
  if (data != (struct ldv_struct_platform_instance_17 *)0) {
    
#line 13500 
    ldv_17_container = data->arg0;
    
#line 13501 
    ldv_free((void *)data);
  }
  else ;
  
#line 13506 
  ldv_17_resource = (struct platform_device *)ldv_xmalloc_unknown_size(0UL);
  
#line 13513 
  goto ldv_main_17;
  
#line 13515 
  __retres = (void *)0;
  
#line 13515 
  goto return_label;
  ldv_main_17: 
#line 13518 
  ;
  
#line 13521 
  tmp_1 = ldv_undef_int();
  
#line 13521 
  if (tmp_1 != 0) {
    int tmp_0;
    
#line 13524 
    ldv_pre_probe();
    
#line 13526 
    ldv_17_probed = ldv_emg_wrapper_wl12xx_probe_2(ldv_17_resource);
    
#line 13528 
    ldv_17_probed = ldv_post_probe(ldv_17_probed);
    
#line 13531 
    tmp_0 = ldv_undef_int();
    
#line 13531 
    if (tmp_0 != 0) {
      
#line 13533 
      __VERIFIER_assume(ldv_17_probed == 0);
      
#line 13540 
      goto ldv_call_17;
    }
    else {
      
#line 13544 
      __VERIFIER_assume(ldv_17_probed != 0);
      
#line 13551 
      goto ldv_main_17;
    }
  }
  else {
    
#line 13556 
    ldv_free((void *)ldv_17_resource);
    
#line 13564 
    __retres = (void *)0;
    
#line 13564 
    goto return_label;
  }
  
#line 13567 
  __retres = (void *)0;
  
#line 13567 
  goto return_label;
  ldv_call_17: 
#line 13570 
  ;
  
#line 13573 
  tmp_2 = ldv_undef_int();
  
#line 13573 
  switch (tmp_2) {
    case 1: 
#line 13574 
    ;
    
#line 13583 
    goto ldv_call_17;
    case 2: 
#line 13586 
    ;
    
#line 13588 
    ldv_dispatch_pm_register_17_13();
    
#line 13592 
    ldv_dispatch_pm_deregister_17_12();
    
#line 13599 
    goto ldv_call_17;
    case 3: 
#line 13602 
    ;
    
#line 13605 
    ldv_emg_wrapper_wl12xx_remove_3(ldv_17_resource);
    
#line 13609 
    ldv_17_probed = 1;
    
#line 13616 
    goto ldv_main_17;
    default: 
#line 13619 
    ;
    
#line 13619 
    __VERIFIER_assume(0);
  }
  
#line 13622 
  __retres = (void *)0;
  return_label: 
#line 13622 
                return __retres;
}


#line 13627  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_81(void *arg0)
{
  void *__retres;
  struct file *ldv_81_resource_1;
  int ldv_81_ldv_param_2_3;
  long long ldv_81_ldv_param_1_2;
  char *ldv_81_ldv_param_1_4;
  struct inode *ldv_81_resource_0;
  unsigned long ldv_81_size_cnt;
  long long *ldv_81_ldv_param_3_5;
  char *ldv_81_ldv_param_1_6;
  long long *ldv_81_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 13638 
  struct file_operations *ldv_81_container = ldv_emg_alias_event_tx_stuck_ops_2;
  
#line 13639 
  int ldv_81_ret = ldv_undef_int();
  
#line 13642 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 13646 
  ldv_81_ret = ldv_undef_int();
  
#line 13649 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 13650 
    ldv_81_container = data->arg0;
    
#line 13651 
    ldv_free((void *)data);
  }
  else ;
  
#line 13656 
  ldv_81_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 13657 
  tmp_1 = ldv_undef_int();
  
#line 13657 
  ldv_81_size_cnt = (unsigned long)tmp_1;
  
#line 13664 
  goto ldv_main_81;
  
#line 13666 
  __retres = (void *)0;
  
#line 13666 
  goto return_label;
  ldv_main_81: 
#line 13669 
  ;
  
#line 13672 
  tmp_3 = ldv_undef_int();
  
#line 13672 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 13675 
    ldv_81_ret = (*ldv_emg_alias_simple_open_5)(ldv_81_resource_0,ldv_81_resource_1);
    
#line 13677 
    ldv_81_ret = ldv_filter_err_code(ldv_81_ret);
    
#line 13680 
    tmp_2 = ldv_undef_int();
    
#line 13680 
    if (tmp_2 != 0) {
      
#line 13682 
      __VERIFIER_assume(ldv_81_ret == 0);
      
#line 13689 
      goto ldv_call_81;
    }
    else {
      
#line 13693 
      __VERIFIER_assume(ldv_81_ret != 0);
      
#line 13700 
      goto ldv_main_81;
    }
  }
  else {
    
#line 13705 
    ldv_free((void *)ldv_81_resource_0);
    
#line 13713 
    __retres = (void *)0;
    
#line 13713 
    goto return_label;
  }
  
#line 13716 
  __retres = (void *)0;
  
#line 13716 
  goto return_label;
  ldv_call_81: 
#line 13719 
  ;
  
#line 13722 
  tmp_4 = ldv_undef_int();
  
#line 13722 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 13723 
    ;
    
#line 13725 
    ldv_81_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 13726 
    ldv_81_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 13730 
    if (ldv_81_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 13736 
      __VERIFIER_assume(ldv_81_size_cnt <= 2147479552UL);
      
#line 13738 
      (*(ldv_81_container->write))(ldv_81_resource_1,(char const *)ldv_81_ldv_param_1_6,ldv_81_size_cnt,ldv_81_ldv_param_3_7);
    }
    else ;
    
#line 13743 
    ldv_free((void *)ldv_81_ldv_param_3_7);
    
#line 13744 
    ldv_free((void *)ldv_81_ldv_param_1_6);
    
#line 13751 
    goto ldv_call_81;
    case 2: 
#line 13754 
    ;
    
#line 13756 
    if (ldv_81_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 13758 
      (*(ldv_81_container->release))(ldv_81_resource_0,ldv_81_resource_1); else ;
    
#line 13766 
    goto ldv_main_81;
    case 3: 
#line 13769 
    ;
    
#line 13773 
    tmp_9 = ldv_undef_int();
    
#line 13773 
    if (tmp_9 != 0) 
#line 13776 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_81_resource_1,ldv_81_ldv_param_1_2,ldv_81_ldv_param_2_3);
    else {
      
#line 13782 
      ldv_81_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 13783 
      ldv_81_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 13788 
      ldv_emg_wrapper_event_tx_stuck_read_3(ldv_81_resource_1,ldv_81_ldv_param_1_4,ldv_81_size_cnt,ldv_81_ldv_param_3_5);
      
#line 13792 
      ldv_free((void *)ldv_81_ldv_param_3_5);
      
#line 13793 
      ldv_free((void *)ldv_81_ldv_param_1_4);
    }
    
#line 13797 
    goto ldv_31902;
    default: 
#line 13799 
    ;
    
#line 13799 
    __VERIFIER_assume(0);
  }
  ldv_31902: 
#line 13808 
  ;
  
#line 13808 
  goto ldv_call_81;
  
#line 13810 
  __retres = (void *)0;
  return_label: 
#line 13810 
                return __retres;
}


#line 13815  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_38(void *arg0)
{
  void *__retres;
  struct file *ldv_38_resource_1;
  int ldv_38_ldv_param_2_3;
  long long ldv_38_ldv_param_1_2;
  char *ldv_38_ldv_param_1_4;
  struct inode *ldv_38_resource_0;
  unsigned long ldv_38_size_cnt;
  long long *ldv_38_ldv_param_3_5;
  char *ldv_38_ldv_param_1_6;
  long long *ldv_38_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 13826 
  struct file_operations *ldv_38_container = ldv_emg_alias_rx_dropped_ops_2;
  
#line 13827 
  int ldv_38_ret = ldv_undef_int();
  
#line 13830 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 13834 
  ldv_38_ret = ldv_undef_int();
  
#line 13837 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 13838 
    ldv_38_container = data->arg0;
    
#line 13839 
    ldv_free((void *)data);
  }
  else ;
  
#line 13844 
  ldv_38_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 13845 
  tmp_1 = ldv_undef_int();
  
#line 13845 
  ldv_38_size_cnt = (unsigned long)tmp_1;
  
#line 13852 
  goto ldv_main_38;
  
#line 13854 
  __retres = (void *)0;
  
#line 13854 
  goto return_label;
  ldv_main_38: 
#line 13857 
  ;
  
#line 13860 
  tmp_3 = ldv_undef_int();
  
#line 13860 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 13863 
    ldv_38_ret = (*ldv_emg_alias_simple_open_5)(ldv_38_resource_0,ldv_38_resource_1);
    
#line 13865 
    ldv_38_ret = ldv_filter_err_code(ldv_38_ret);
    
#line 13868 
    tmp_2 = ldv_undef_int();
    
#line 13868 
    if (tmp_2 != 0) {
      
#line 13870 
      __VERIFIER_assume(ldv_38_ret == 0);
      
#line 13877 
      goto ldv_call_38;
    }
    else {
      
#line 13881 
      __VERIFIER_assume(ldv_38_ret != 0);
      
#line 13888 
      goto ldv_main_38;
    }
  }
  else {
    
#line 13893 
    ldv_free((void *)ldv_38_resource_0);
    
#line 13901 
    __retres = (void *)0;
    
#line 13901 
    goto return_label;
  }
  
#line 13904 
  __retres = (void *)0;
  
#line 13904 
  goto return_label;
  ldv_call_38: 
#line 13907 
  ;
  
#line 13910 
  tmp_4 = ldv_undef_int();
  
#line 13910 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 13911 
    ;
    
#line 13913 
    ldv_38_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 13914 
    ldv_38_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 13918 
    if (ldv_38_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 13924 
      __VERIFIER_assume(ldv_38_size_cnt <= 2147479552UL);
      
#line 13926 
      (*(ldv_38_container->write))(ldv_38_resource_1,(char const *)ldv_38_ldv_param_1_6,ldv_38_size_cnt,ldv_38_ldv_param_3_7);
    }
    else ;
    
#line 13931 
    ldv_free((void *)ldv_38_ldv_param_3_7);
    
#line 13932 
    ldv_free((void *)ldv_38_ldv_param_1_6);
    
#line 13939 
    goto ldv_call_38;
    case 2: 
#line 13942 
    ;
    
#line 13944 
    if (ldv_38_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 13946 
      (*(ldv_38_container->release))(ldv_38_resource_0,ldv_38_resource_1); else ;
    
#line 13954 
    goto ldv_main_38;
    case 3: 
#line 13957 
    ;
    
#line 13961 
    tmp_9 = ldv_undef_int();
    
#line 13961 
    if (tmp_9 != 0) 
#line 13964 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_38_resource_1,ldv_38_ldv_param_1_2,ldv_38_ldv_param_2_3);
    else {
      
#line 13970 
      ldv_38_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 13971 
      ldv_38_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 13976 
      ldv_emg_wrapper_rx_dropped_read_3(ldv_38_resource_1,ldv_38_ldv_param_1_4,ldv_38_size_cnt,ldv_38_ldv_param_3_5);
      
#line 13980 
      ldv_free((void *)ldv_38_ldv_param_3_5);
      
#line 13981 
      ldv_free((void *)ldv_38_ldv_param_1_4);
    }
    
#line 13985 
    goto ldv_31924;
    default: 
#line 13987 
    ;
    
#line 13987 
    __VERIFIER_assume(0);
  }
  ldv_31924: 
#line 13996 
  ;
  
#line 13996 
  goto ldv_call_38;
  
#line 13998 
  __retres = (void *)0;
  return_label: 
#line 13998 
                return __retres;
}


#line 14003  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_66(void *arg0)
{
  void *__retres;
  struct file *ldv_66_resource_1;
  int ldv_66_ldv_param_2_3;
  long long ldv_66_ldv_param_1_2;
  char *ldv_66_ldv_param_1_4;
  struct inode *ldv_66_resource_0;
  unsigned long ldv_66_size_cnt;
  long long *ldv_66_ldv_param_3_5;
  char *ldv_66_ldv_param_1_6;
  long long *ldv_66_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 14014 
  struct file_operations *ldv_66_container = ldv_emg_alias_aes_decrypt_packets_ops_2;
  
#line 14015 
  int ldv_66_ret = ldv_undef_int();
  
#line 14018 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 14022 
  ldv_66_ret = ldv_undef_int();
  
#line 14025 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 14026 
    ldv_66_container = data->arg0;
    
#line 14027 
    ldv_free((void *)data);
  }
  else ;
  
#line 14032 
  ldv_66_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 14033 
  tmp_1 = ldv_undef_int();
  
#line 14033 
  ldv_66_size_cnt = (unsigned long)tmp_1;
  
#line 14040 
  goto ldv_main_66;
  
#line 14042 
  __retres = (void *)0;
  
#line 14042 
  goto return_label;
  ldv_main_66: 
#line 14045 
  ;
  
#line 14048 
  tmp_3 = ldv_undef_int();
  
#line 14048 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 14051 
    ldv_66_ret = (*ldv_emg_alias_simple_open_5)(ldv_66_resource_0,ldv_66_resource_1);
    
#line 14053 
    ldv_66_ret = ldv_filter_err_code(ldv_66_ret);
    
#line 14056 
    tmp_2 = ldv_undef_int();
    
#line 14056 
    if (tmp_2 != 0) {
      
#line 14058 
      __VERIFIER_assume(ldv_66_ret == 0);
      
#line 14065 
      goto ldv_call_66;
    }
    else {
      
#line 14069 
      __VERIFIER_assume(ldv_66_ret != 0);
      
#line 14076 
      goto ldv_main_66;
    }
  }
  else {
    
#line 14081 
    ldv_free((void *)ldv_66_resource_0);
    
#line 14089 
    __retres = (void *)0;
    
#line 14089 
    goto return_label;
  }
  
#line 14092 
  __retres = (void *)0;
  
#line 14092 
  goto return_label;
  ldv_call_66: 
#line 14095 
  ;
  
#line 14098 
  tmp_4 = ldv_undef_int();
  
#line 14098 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 14099 
    ;
    
#line 14101 
    ldv_66_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 14102 
    ldv_66_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 14106 
    if (ldv_66_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 14112 
      __VERIFIER_assume(ldv_66_size_cnt <= 2147479552UL);
      
#line 14114 
      (*(ldv_66_container->write))(ldv_66_resource_1,(char const *)ldv_66_ldv_param_1_6,ldv_66_size_cnt,ldv_66_ldv_param_3_7);
    }
    else ;
    
#line 14119 
    ldv_free((void *)ldv_66_ldv_param_3_7);
    
#line 14120 
    ldv_free((void *)ldv_66_ldv_param_1_6);
    
#line 14127 
    goto ldv_call_66;
    case 2: 
#line 14130 
    ;
    
#line 14132 
    if (ldv_66_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 14134 
      (*(ldv_66_container->release))(ldv_66_resource_0,ldv_66_resource_1); else ;
    
#line 14142 
    goto ldv_main_66;
    case 3: 
#line 14145 
    ;
    
#line 14149 
    tmp_9 = ldv_undef_int();
    
#line 14149 
    if (tmp_9 != 0) 
#line 14152 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_66_resource_1,ldv_66_ldv_param_1_2,ldv_66_ldv_param_2_3);
    else {
      
#line 14158 
      ldv_66_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 14159 
      ldv_66_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 14164 
      ldv_emg_wrapper_aes_decrypt_packets_read_3(ldv_66_resource_1,ldv_66_ldv_param_1_4,ldv_66_size_cnt,ldv_66_ldv_param_3_5);
      
#line 14168 
      ldv_free((void *)ldv_66_ldv_param_1_4);
      
#line 14169 
      ldv_free((void *)ldv_66_ldv_param_3_5);
    }
    
#line 14173 
    goto ldv_31946;
    default: 
#line 14175 
    ;
    
#line 14175 
    __VERIFIER_assume(0);
  }
  ldv_31946: 
#line 14184 
  ;
  
#line 14184 
  goto ldv_call_66;
  
#line 14186 
  __retres = (void *)0;
  return_label: 
#line 14186 
                return __retres;
}


#line 14191  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_7(void *arg0)
{
  void *__retres;
  struct file *ldv_7_resource_1;
  int ldv_7_ldv_param_2_3;
  long long ldv_7_ldv_param_1_2;
  char *ldv_7_ldv_param_1_4;
  struct inode *ldv_7_resource_0;
  unsigned long ldv_7_size_cnt;
  long long *ldv_7_ldv_param_3_5;
  char *ldv_7_ldv_param_1_6;
  long long *ldv_7_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 14202 
  struct file_operations *ldv_7_container = ldv_emg_alias_ps_upsd_max_apturn_ops_2;
  
#line 14203 
  int ldv_7_ret = ldv_undef_int();
  
#line 14206 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 14210 
  ldv_7_ret = ldv_undef_int();
  
#line 14213 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 14214 
    ldv_7_container = data->arg0;
    
#line 14215 
    ldv_free((void *)data);
  }
  else ;
  
#line 14220 
  ldv_7_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 14221 
  tmp_1 = ldv_undef_int();
  
#line 14221 
  ldv_7_size_cnt = (unsigned long)tmp_1;
  
#line 14228 
  goto ldv_main_7;
  
#line 14230 
  __retres = (void *)0;
  
#line 14230 
  goto return_label;
  ldv_main_7: 
#line 14233 
  ;
  
#line 14236 
  tmp_3 = ldv_undef_int();
  
#line 14236 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 14239 
    ldv_7_ret = (*ldv_emg_alias_simple_open_5)(ldv_7_resource_0,ldv_7_resource_1);
    
#line 14241 
    ldv_7_ret = ldv_filter_err_code(ldv_7_ret);
    
#line 14244 
    tmp_2 = ldv_undef_int();
    
#line 14244 
    if (tmp_2 != 0) {
      
#line 14246 
      __VERIFIER_assume(ldv_7_ret == 0);
      
#line 14253 
      goto ldv_call_7;
    }
    else {
      
#line 14257 
      __VERIFIER_assume(ldv_7_ret != 0);
      
#line 14264 
      goto ldv_main_7;
    }
  }
  else {
    
#line 14269 
    ldv_free((void *)ldv_7_resource_0);
    
#line 14277 
    __retres = (void *)0;
    
#line 14277 
    goto return_label;
  }
  
#line 14280 
  __retres = (void *)0;
  
#line 14280 
  goto return_label;
  ldv_call_7: 
#line 14283 
  ;
  
#line 14286 
  tmp_4 = ldv_undef_int();
  
#line 14286 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 14287 
    ;
    
#line 14289 
    ldv_7_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 14290 
    ldv_7_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 14294 
    if (ldv_7_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 14300 
      __VERIFIER_assume(ldv_7_size_cnt <= 2147479552UL);
      
#line 14302 
      (*(ldv_7_container->write))(ldv_7_resource_1,(char const *)ldv_7_ldv_param_1_6,ldv_7_size_cnt,ldv_7_ldv_param_3_7);
    }
    else ;
    
#line 14307 
    ldv_free((void *)ldv_7_ldv_param_1_6);
    
#line 14308 
    ldv_free((void *)ldv_7_ldv_param_3_7);
    
#line 14315 
    goto ldv_call_7;
    case 2: 
#line 14318 
    ;
    
#line 14320 
    if (ldv_7_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 14322 
      (*(ldv_7_container->release))(ldv_7_resource_0,ldv_7_resource_1); else ;
    
#line 14330 
    goto ldv_main_7;
    case 3: 
#line 14333 
    ;
    
#line 14337 
    tmp_9 = ldv_undef_int();
    
#line 14337 
    if (tmp_9 != 0) 
#line 14340 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_7_resource_1,ldv_7_ldv_param_1_2,ldv_7_ldv_param_2_3);
    else {
      
#line 14346 
      ldv_7_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 14347 
      ldv_7_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 14352 
      ldv_emg_wrapper_ps_upsd_max_apturn_read_3(ldv_7_resource_1,ldv_7_ldv_param_1_4,ldv_7_size_cnt,ldv_7_ldv_param_3_5);
      
#line 14356 
      ldv_free((void *)ldv_7_ldv_param_3_5);
      
#line 14357 
      ldv_free((void *)ldv_7_ldv_param_1_4);
    }
    
#line 14361 
    goto ldv_31968;
    default: 
#line 14363 
    ;
    
#line 14363 
    __VERIFIER_assume(0);
  }
  ldv_31968: 
#line 14372 
  ;
  
#line 14372 
  goto ldv_call_7;
  
#line 14374 
  __retres = (void *)0;
  return_label: 
#line 14374 
                return __retres;
}


#line 14379  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_54(void *arg0)
{
  void *__retres;
  struct file *ldv_54_resource_1;
  int ldv_54_ldv_param_2_3;
  long long ldv_54_ldv_param_1_2;
  char *ldv_54_ldv_param_1_4;
  struct inode *ldv_54_resource_0;
  unsigned long ldv_54_size_cnt;
  long long *ldv_54_ldv_param_3_5;
  char *ldv_54_ldv_param_1_6;
  long long *ldv_54_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 14390 
  struct file_operations *ldv_54_container = ldv_emg_alias_isr_cmd_cmplt_ops_2;
  
#line 14391 
  int ldv_54_ret = ldv_undef_int();
  
#line 14394 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 14398 
  ldv_54_ret = ldv_undef_int();
  
#line 14401 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 14402 
    ldv_54_container = data->arg0;
    
#line 14403 
    ldv_free((void *)data);
  }
  else ;
  
#line 14408 
  ldv_54_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 14409 
  tmp_1 = ldv_undef_int();
  
#line 14409 
  ldv_54_size_cnt = (unsigned long)tmp_1;
  
#line 14416 
  goto ldv_main_54;
  
#line 14418 
  __retres = (void *)0;
  
#line 14418 
  goto return_label;
  ldv_main_54: 
#line 14421 
  ;
  
#line 14424 
  tmp_3 = ldv_undef_int();
  
#line 14424 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 14427 
    ldv_54_ret = (*ldv_emg_alias_simple_open_5)(ldv_54_resource_0,ldv_54_resource_1);
    
#line 14429 
    ldv_54_ret = ldv_filter_err_code(ldv_54_ret);
    
#line 14432 
    tmp_2 = ldv_undef_int();
    
#line 14432 
    if (tmp_2 != 0) {
      
#line 14434 
      __VERIFIER_assume(ldv_54_ret == 0);
      
#line 14441 
      goto ldv_call_54;
    }
    else {
      
#line 14445 
      __VERIFIER_assume(ldv_54_ret != 0);
      
#line 14452 
      goto ldv_main_54;
    }
  }
  else {
    
#line 14457 
    ldv_free((void *)ldv_54_resource_0);
    
#line 14465 
    __retres = (void *)0;
    
#line 14465 
    goto return_label;
  }
  
#line 14468 
  __retres = (void *)0;
  
#line 14468 
  goto return_label;
  ldv_call_54: 
#line 14471 
  ;
  
#line 14474 
  tmp_4 = ldv_undef_int();
  
#line 14474 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 14475 
    ;
    
#line 14477 
    ldv_54_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 14478 
    ldv_54_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 14482 
    if (ldv_54_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 14488 
      __VERIFIER_assume(ldv_54_size_cnt <= 2147479552UL);
      
#line 14490 
      (*(ldv_54_container->write))(ldv_54_resource_1,(char const *)ldv_54_ldv_param_1_6,ldv_54_size_cnt,ldv_54_ldv_param_3_7);
    }
    else ;
    
#line 14495 
    ldv_free((void *)ldv_54_ldv_param_3_7);
    
#line 14496 
    ldv_free((void *)ldv_54_ldv_param_1_6);
    
#line 14503 
    goto ldv_call_54;
    case 2: 
#line 14506 
    ;
    
#line 14508 
    if (ldv_54_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 14510 
      (*(ldv_54_container->release))(ldv_54_resource_0,ldv_54_resource_1); else ;
    
#line 14518 
    goto ldv_main_54;
    case 3: 
#line 14521 
    ;
    
#line 14525 
    tmp_9 = ldv_undef_int();
    
#line 14525 
    if (tmp_9 != 0) 
#line 14528 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_54_resource_1,ldv_54_ldv_param_1_2,ldv_54_ldv_param_2_3);
    else {
      
#line 14534 
      ldv_54_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 14535 
      ldv_54_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 14540 
      ldv_emg_wrapper_isr_cmd_cmplt_read_3(ldv_54_resource_1,ldv_54_ldv_param_1_4,ldv_54_size_cnt,ldv_54_ldv_param_3_5);
      
#line 14544 
      ldv_free((void *)ldv_54_ldv_param_3_5);
      
#line 14545 
      ldv_free((void *)ldv_54_ldv_param_1_4);
    }
    
#line 14549 
    goto ldv_31990;
    default: 
#line 14551 
    ;
    
#line 14551 
    __VERIFIER_assume(0);
  }
  ldv_31990: 
#line 14560 
  ;
  
#line 14560 
  goto ldv_call_54;
  
#line 14562 
  __retres = (void *)0;
  return_label: 
#line 14562 
                return __retres;
}


#line 14567  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_28(void *arg0)
{
  void *__retres;
  struct file *ldv_28_resource_1;
  int ldv_28_ldv_param_2_3;
  long long ldv_28_ldv_param_1_2;
  char *ldv_28_ldv_param_1_4;
  struct inode *ldv_28_resource_0;
  unsigned long ldv_28_size_cnt;
  long long *ldv_28_ldv_param_3_5;
  char *ldv_28_ldv_param_1_6;
  long long *ldv_28_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 14578 
  struct file_operations *ldv_28_container = ldv_emg_alias_rxpipe_beacon_buffer_thres_host_int_trig_rx_data_ops_2;
  
#line 14579 
  int ldv_28_ret = ldv_undef_int();
  
#line 14582 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 14586 
  ldv_28_ret = ldv_undef_int();
  
#line 14589 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 14590 
    ldv_28_container = data->arg0;
    
#line 14591 
    ldv_free((void *)data);
  }
  else ;
  
#line 14596 
  ldv_28_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 14597 
  tmp_1 = ldv_undef_int();
  
#line 14597 
  ldv_28_size_cnt = (unsigned long)tmp_1;
  
#line 14604 
  goto ldv_main_28;
  
#line 14606 
  __retres = (void *)0;
  
#line 14606 
  goto return_label;
  ldv_main_28: 
#line 14609 
  ;
  
#line 14612 
  tmp_3 = ldv_undef_int();
  
#line 14612 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 14615 
    ldv_28_ret = (*ldv_emg_alias_simple_open_5)(ldv_28_resource_0,ldv_28_resource_1);
    
#line 14617 
    ldv_28_ret = ldv_filter_err_code(ldv_28_ret);
    
#line 14620 
    tmp_2 = ldv_undef_int();
    
#line 14620 
    if (tmp_2 != 0) {
      
#line 14622 
      __VERIFIER_assume(ldv_28_ret == 0);
      
#line 14629 
      goto ldv_call_28;
    }
    else {
      
#line 14633 
      __VERIFIER_assume(ldv_28_ret != 0);
      
#line 14640 
      goto ldv_main_28;
    }
  }
  else {
    
#line 14645 
    ldv_free((void *)ldv_28_resource_0);
    
#line 14653 
    __retres = (void *)0;
    
#line 14653 
    goto return_label;
  }
  
#line 14656 
  __retres = (void *)0;
  
#line 14656 
  goto return_label;
  ldv_call_28: 
#line 14659 
  ;
  
#line 14662 
  tmp_4 = ldv_undef_int();
  
#line 14662 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 14663 
    ;
    
#line 14665 
    ldv_28_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 14666 
    ldv_28_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 14670 
    if (ldv_28_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 14676 
      __VERIFIER_assume(ldv_28_size_cnt <= 2147479552UL);
      
#line 14678 
      (*(ldv_28_container->write))(ldv_28_resource_1,(char const *)ldv_28_ldv_param_1_6,ldv_28_size_cnt,ldv_28_ldv_param_3_7);
    }
    else ;
    
#line 14683 
    ldv_free((void *)ldv_28_ldv_param_3_7);
    
#line 14684 
    ldv_free((void *)ldv_28_ldv_param_1_6);
    
#line 14691 
    goto ldv_call_28;
    case 2: 
#line 14694 
    ;
    
#line 14696 
    if (ldv_28_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 14698 
      (*(ldv_28_container->release))(ldv_28_resource_0,ldv_28_resource_1); else ;
    
#line 14706 
    goto ldv_main_28;
    case 3: 
#line 14709 
    ;
    
#line 14713 
    tmp_9 = ldv_undef_int();
    
#line 14713 
    if (tmp_9 != 0) 
#line 14716 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_28_resource_1,ldv_28_ldv_param_1_2,ldv_28_ldv_param_2_3);
    else {
      
#line 14722 
      ldv_28_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 14723 
      ldv_28_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 14728 
      ldv_emg_wrapper_rxpipe_beacon_buffer_thres_host_int_trig_rx_data_read_3(ldv_28_resource_1,ldv_28_ldv_param_1_4,ldv_28_size_cnt,ldv_28_ldv_param_3_5);
      
#line 14732 
      ldv_free((void *)ldv_28_ldv_param_1_4);
      
#line 14733 
      ldv_free((void *)ldv_28_ldv_param_3_5);
    }
    
#line 14737 
    goto ldv_32012;
    default: 
#line 14739 
    ;
    
#line 14739 
    __VERIFIER_assume(0);
  }
  ldv_32012: 
#line 14748 
  ;
  
#line 14748 
  goto ldv_call_28;
  
#line 14750 
  __retres = (void *)0;
  return_label: 
#line 14750 
                return __retres;
}


#line 14755  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_56(void *arg0)
{
  void *__retres;
  struct file *ldv_56_resource_1;
  int ldv_56_ldv_param_2_3;
  long long ldv_56_ldv_param_1_2;
  char *ldv_56_ldv_param_1_4;
  struct inode *ldv_56_resource_0;
  unsigned long ldv_56_size_cnt;
  long long *ldv_56_ldv_param_3_5;
  char *ldv_56_ldv_param_1_6;
  long long *ldv_56_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 14766 
  struct file_operations *ldv_56_container = ldv_emg_alias_ps_upsd_utilization_ops_2;
  
#line 14767 
  int ldv_56_ret = ldv_undef_int();
  
#line 14770 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 14774 
  ldv_56_ret = ldv_undef_int();
  
#line 14777 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 14778 
    ldv_56_container = data->arg0;
    
#line 14779 
    ldv_free((void *)data);
  }
  else ;
  
#line 14784 
  ldv_56_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 14785 
  tmp_1 = ldv_undef_int();
  
#line 14785 
  ldv_56_size_cnt = (unsigned long)tmp_1;
  
#line 14792 
  goto ldv_main_56;
  
#line 14794 
  __retres = (void *)0;
  
#line 14794 
  goto return_label;
  ldv_main_56: 
#line 14797 
  ;
  
#line 14800 
  tmp_3 = ldv_undef_int();
  
#line 14800 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 14803 
    ldv_56_ret = (*ldv_emg_alias_simple_open_5)(ldv_56_resource_0,ldv_56_resource_1);
    
#line 14805 
    ldv_56_ret = ldv_filter_err_code(ldv_56_ret);
    
#line 14808 
    tmp_2 = ldv_undef_int();
    
#line 14808 
    if (tmp_2 != 0) {
      
#line 14810 
      __VERIFIER_assume(ldv_56_ret == 0);
      
#line 14817 
      goto ldv_call_56;
    }
    else {
      
#line 14821 
      __VERIFIER_assume(ldv_56_ret != 0);
      
#line 14828 
      goto ldv_main_56;
    }
  }
  else {
    
#line 14833 
    ldv_free((void *)ldv_56_resource_0);
    
#line 14841 
    __retres = (void *)0;
    
#line 14841 
    goto return_label;
  }
  
#line 14844 
  __retres = (void *)0;
  
#line 14844 
  goto return_label;
  ldv_call_56: 
#line 14847 
  ;
  
#line 14850 
  tmp_4 = ldv_undef_int();
  
#line 14850 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 14851 
    ;
    
#line 14853 
    ldv_56_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 14854 
    ldv_56_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 14858 
    if (ldv_56_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 14864 
      __VERIFIER_assume(ldv_56_size_cnt <= 2147479552UL);
      
#line 14866 
      (*(ldv_56_container->write))(ldv_56_resource_1,(char const *)ldv_56_ldv_param_1_6,ldv_56_size_cnt,ldv_56_ldv_param_3_7);
    }
    else ;
    
#line 14871 
    ldv_free((void *)ldv_56_ldv_param_3_7);
    
#line 14872 
    ldv_free((void *)ldv_56_ldv_param_1_6);
    
#line 14879 
    goto ldv_call_56;
    case 2: 
#line 14882 
    ;
    
#line 14884 
    if (ldv_56_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 14886 
      (*(ldv_56_container->release))(ldv_56_resource_0,ldv_56_resource_1); else ;
    
#line 14894 
    goto ldv_main_56;
    case 3: 
#line 14897 
    ;
    
#line 14901 
    tmp_9 = ldv_undef_int();
    
#line 14901 
    if (tmp_9 != 0) 
#line 14904 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_56_resource_1,ldv_56_ldv_param_1_2,ldv_56_ldv_param_2_3);
    else {
      
#line 14910 
      ldv_56_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 14911 
      ldv_56_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 14916 
      ldv_emg_wrapper_ps_upsd_utilization_read_3(ldv_56_resource_1,ldv_56_ldv_param_1_4,ldv_56_size_cnt,ldv_56_ldv_param_3_5);
      
#line 14920 
      ldv_free((void *)ldv_56_ldv_param_3_5);
      
#line 14921 
      ldv_free((void *)ldv_56_ldv_param_1_4);
    }
    
#line 14925 
    goto ldv_32034;
    default: 
#line 14927 
    ;
    
#line 14927 
    __VERIFIER_assume(0);
  }
  ldv_32034: 
#line 14936 
  ;
  
#line 14936 
  goto ldv_call_56;
  
#line 14938 
  __retres = (void *)0;
  return_label: 
#line 14938 
                return __retres;
}


#line 14943  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_23(void *arg0)
{
  void *__retres;
  struct file *ldv_23_resource_1;
  int ldv_23_ldv_param_2_3;
  long long ldv_23_ldv_param_1_2;
  char *ldv_23_ldv_param_1_4;
  struct inode *ldv_23_resource_0;
  unsigned long ldv_23_size_cnt;
  long long *ldv_23_ldv_param_3_5;
  char *ldv_23_ldv_param_1_6;
  long long *ldv_23_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 14954 
  struct file_operations *ldv_23_container = ldv_emg_alias_isr_rx_headers_ops_2;
  
#line 14955 
  int ldv_23_ret = ldv_undef_int();
  
#line 14958 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 14962 
  ldv_23_ret = ldv_undef_int();
  
#line 14965 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 14966 
    ldv_23_container = data->arg0;
    
#line 14967 
    ldv_free((void *)data);
  }
  else ;
  
#line 14972 
  ldv_23_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 14973 
  tmp_1 = ldv_undef_int();
  
#line 14973 
  ldv_23_size_cnt = (unsigned long)tmp_1;
  
#line 14980 
  goto ldv_main_23;
  
#line 14982 
  __retres = (void *)0;
  
#line 14982 
  goto return_label;
  ldv_main_23: 
#line 14985 
  ;
  
#line 14988 
  tmp_3 = ldv_undef_int();
  
#line 14988 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 14991 
    ldv_23_ret = (*ldv_emg_alias_simple_open_5)(ldv_23_resource_0,ldv_23_resource_1);
    
#line 14993 
    ldv_23_ret = ldv_filter_err_code(ldv_23_ret);
    
#line 14996 
    tmp_2 = ldv_undef_int();
    
#line 14996 
    if (tmp_2 != 0) {
      
#line 14998 
      __VERIFIER_assume(ldv_23_ret == 0);
      
#line 15005 
      goto ldv_call_23;
    }
    else {
      
#line 15009 
      __VERIFIER_assume(ldv_23_ret != 0);
      
#line 15016 
      goto ldv_main_23;
    }
  }
  else {
    
#line 15021 
    ldv_free((void *)ldv_23_resource_0);
    
#line 15029 
    __retres = (void *)0;
    
#line 15029 
    goto return_label;
  }
  
#line 15032 
  __retres = (void *)0;
  
#line 15032 
  goto return_label;
  ldv_call_23: 
#line 15035 
  ;
  
#line 15038 
  tmp_4 = ldv_undef_int();
  
#line 15038 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 15039 
    ;
    
#line 15041 
    ldv_23_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 15042 
    ldv_23_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 15046 
    if (ldv_23_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 15052 
      __VERIFIER_assume(ldv_23_size_cnt <= 2147479552UL);
      
#line 15054 
      (*(ldv_23_container->write))(ldv_23_resource_1,(char const *)ldv_23_ldv_param_1_6,ldv_23_size_cnt,ldv_23_ldv_param_3_7);
    }
    else ;
    
#line 15059 
    ldv_free((void *)ldv_23_ldv_param_3_7);
    
#line 15060 
    ldv_free((void *)ldv_23_ldv_param_1_6);
    
#line 15067 
    goto ldv_call_23;
    case 2: 
#line 15070 
    ;
    
#line 15072 
    if (ldv_23_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 15074 
      (*(ldv_23_container->release))(ldv_23_resource_0,ldv_23_resource_1); else ;
    
#line 15082 
    goto ldv_main_23;
    case 3: 
#line 15085 
    ;
    
#line 15089 
    tmp_9 = ldv_undef_int();
    
#line 15089 
    if (tmp_9 != 0) 
#line 15092 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_23_resource_1,ldv_23_ldv_param_1_2,ldv_23_ldv_param_2_3);
    else {
      
#line 15098 
      ldv_23_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 15099 
      ldv_23_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 15104 
      ldv_emg_wrapper_isr_rx_headers_read_3(ldv_23_resource_1,ldv_23_ldv_param_1_4,ldv_23_size_cnt,ldv_23_ldv_param_3_5);
      
#line 15108 
      ldv_free((void *)ldv_23_ldv_param_1_4);
      
#line 15109 
      ldv_free((void *)ldv_23_ldv_param_3_5);
    }
    
#line 15113 
    goto ldv_32056;
    default: 
#line 15115 
    ;
    
#line 15115 
    __VERIFIER_assume(0);
  }
  ldv_32056: 
#line 15124 
  ;
  
#line 15124 
  goto ldv_call_23;
  
#line 15126 
  __retres = (void *)0;
  return_label: 
#line 15126 
                return __retres;
}


#line 15131  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_27(void *arg0)
{
  void *__retres;
  struct file *ldv_27_resource_1;
  int ldv_27_ldv_param_2_3;
  long long ldv_27_ldv_param_1_2;
  char *ldv_27_ldv_param_1_4;
  struct inode *ldv_27_resource_0;
  unsigned long ldv_27_size_cnt;
  long long *ldv_27_ldv_param_3_5;
  char *ldv_27_ldv_param_1_6;
  long long *ldv_27_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 15142 
  struct file_operations *ldv_27_container = ldv_emg_alias_mic_rx_pkts_ops_2;
  
#line 15143 
  int ldv_27_ret = ldv_undef_int();
  
#line 15146 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 15150 
  ldv_27_ret = ldv_undef_int();
  
#line 15153 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 15154 
    ldv_27_container = data->arg0;
    
#line 15155 
    ldv_free((void *)data);
  }
  else ;
  
#line 15160 
  ldv_27_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 15161 
  tmp_1 = ldv_undef_int();
  
#line 15161 
  ldv_27_size_cnt = (unsigned long)tmp_1;
  
#line 15168 
  goto ldv_main_27;
  
#line 15170 
  __retres = (void *)0;
  
#line 15170 
  goto return_label;
  ldv_main_27: 
#line 15173 
  ;
  
#line 15176 
  tmp_3 = ldv_undef_int();
  
#line 15176 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 15179 
    ldv_27_ret = (*ldv_emg_alias_simple_open_5)(ldv_27_resource_0,ldv_27_resource_1);
    
#line 15181 
    ldv_27_ret = ldv_filter_err_code(ldv_27_ret);
    
#line 15184 
    tmp_2 = ldv_undef_int();
    
#line 15184 
    if (tmp_2 != 0) {
      
#line 15186 
      __VERIFIER_assume(ldv_27_ret == 0);
      
#line 15193 
      goto ldv_call_27;
    }
    else {
      
#line 15197 
      __VERIFIER_assume(ldv_27_ret != 0);
      
#line 15204 
      goto ldv_main_27;
    }
  }
  else {
    
#line 15209 
    ldv_free((void *)ldv_27_resource_0);
    
#line 15217 
    __retres = (void *)0;
    
#line 15217 
    goto return_label;
  }
  
#line 15220 
  __retres = (void *)0;
  
#line 15220 
  goto return_label;
  ldv_call_27: 
#line 15223 
  ;
  
#line 15226 
  tmp_4 = ldv_undef_int();
  
#line 15226 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 15227 
    ;
    
#line 15229 
    ldv_27_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 15230 
    ldv_27_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 15234 
    if (ldv_27_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 15240 
      __VERIFIER_assume(ldv_27_size_cnt <= 2147479552UL);
      
#line 15242 
      (*(ldv_27_container->write))(ldv_27_resource_1,(char const *)ldv_27_ldv_param_1_6,ldv_27_size_cnt,ldv_27_ldv_param_3_7);
    }
    else ;
    
#line 15247 
    ldv_free((void *)ldv_27_ldv_param_3_7);
    
#line 15248 
    ldv_free((void *)ldv_27_ldv_param_1_6);
    
#line 15255 
    goto ldv_call_27;
    case 2: 
#line 15258 
    ;
    
#line 15260 
    if (ldv_27_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 15262 
      (*(ldv_27_container->release))(ldv_27_resource_0,ldv_27_resource_1); else ;
    
#line 15270 
    goto ldv_main_27;
    case 3: 
#line 15273 
    ;
    
#line 15277 
    tmp_9 = ldv_undef_int();
    
#line 15277 
    if (tmp_9 != 0) 
#line 15280 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_27_resource_1,ldv_27_ldv_param_1_2,ldv_27_ldv_param_2_3);
    else {
      
#line 15286 
      ldv_27_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 15287 
      ldv_27_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 15292 
      ldv_emg_wrapper_mic_rx_pkts_read_3(ldv_27_resource_1,ldv_27_ldv_param_1_4,ldv_27_size_cnt,ldv_27_ldv_param_3_5);
      
#line 15296 
      ldv_free((void *)ldv_27_ldv_param_1_4);
      
#line 15297 
      ldv_free((void *)ldv_27_ldv_param_3_5);
    }
    
#line 15301 
    goto ldv_32078;
    default: 
#line 15303 
    ;
    
#line 15303 
    __VERIFIER_assume(0);
  }
  ldv_32078: 
#line 15312 
  ;
  
#line 15312 
  goto ldv_call_27;
  
#line 15314 
  __retres = (void *)0;
  return_label: 
#line 15314 
                return __retres;
}


#line 15319  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_33(void *arg0)
{
  void *__retres;
  struct file *ldv_33_resource_1;
  int ldv_33_ldv_param_2_3;
  long long ldv_33_ldv_param_1_2;
  char *ldv_33_ldv_param_1_4;
  struct inode *ldv_33_resource_0;
  unsigned long ldv_33_size_cnt;
  long long *ldv_33_ldv_param_3_5;
  char *ldv_33_ldv_param_1_6;
  long long *ldv_33_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 15330 
  struct file_operations *ldv_33_container = ldv_emg_alias_wep_addr_key_count_ops_2;
  
#line 15331 
  int ldv_33_ret = ldv_undef_int();
  
#line 15334 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 15338 
  ldv_33_ret = ldv_undef_int();
  
#line 15341 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 15342 
    ldv_33_container = data->arg0;
    
#line 15343 
    ldv_free((void *)data);
  }
  else ;
  
#line 15348 
  ldv_33_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 15349 
  tmp_1 = ldv_undef_int();
  
#line 15349 
  ldv_33_size_cnt = (unsigned long)tmp_1;
  
#line 15356 
  goto ldv_main_33;
  
#line 15358 
  __retres = (void *)0;
  
#line 15358 
  goto return_label;
  ldv_main_33: 
#line 15361 
  ;
  
#line 15364 
  tmp_3 = ldv_undef_int();
  
#line 15364 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 15367 
    ldv_33_ret = (*ldv_emg_alias_simple_open_5)(ldv_33_resource_0,ldv_33_resource_1);
    
#line 15369 
    ldv_33_ret = ldv_filter_err_code(ldv_33_ret);
    
#line 15372 
    tmp_2 = ldv_undef_int();
    
#line 15372 
    if (tmp_2 != 0) {
      
#line 15374 
      __VERIFIER_assume(ldv_33_ret == 0);
      
#line 15381 
      goto ldv_call_33;
    }
    else {
      
#line 15385 
      __VERIFIER_assume(ldv_33_ret != 0);
      
#line 15392 
      goto ldv_main_33;
    }
  }
  else {
    
#line 15397 
    ldv_free((void *)ldv_33_resource_0);
    
#line 15405 
    __retres = (void *)0;
    
#line 15405 
    goto return_label;
  }
  
#line 15408 
  __retres = (void *)0;
  
#line 15408 
  goto return_label;
  ldv_call_33: 
#line 15411 
  ;
  
#line 15414 
  tmp_4 = ldv_undef_int();
  
#line 15414 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 15415 
    ;
    
#line 15417 
    ldv_33_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 15418 
    ldv_33_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 15422 
    if (ldv_33_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 15428 
      __VERIFIER_assume(ldv_33_size_cnt <= 2147479552UL);
      
#line 15430 
      (*(ldv_33_container->write))(ldv_33_resource_1,(char const *)ldv_33_ldv_param_1_6,ldv_33_size_cnt,ldv_33_ldv_param_3_7);
    }
    else ;
    
#line 15435 
    ldv_free((void *)ldv_33_ldv_param_3_7);
    
#line 15436 
    ldv_free((void *)ldv_33_ldv_param_1_6);
    
#line 15443 
    goto ldv_call_33;
    case 2: 
#line 15446 
    ;
    
#line 15448 
    if (ldv_33_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 15450 
      (*(ldv_33_container->release))(ldv_33_resource_0,ldv_33_resource_1); else ;
    
#line 15458 
    goto ldv_main_33;
    case 3: 
#line 15461 
    ;
    
#line 15465 
    tmp_9 = ldv_undef_int();
    
#line 15465 
    if (tmp_9 != 0) 
#line 15468 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_33_resource_1,ldv_33_ldv_param_1_2,ldv_33_ldv_param_2_3);
    else {
      
#line 15474 
      ldv_33_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 15475 
      ldv_33_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 15480 
      ldv_emg_wrapper_wep_addr_key_count_read_3(ldv_33_resource_1,ldv_33_ldv_param_1_4,ldv_33_size_cnt,ldv_33_ldv_param_3_5);
      
#line 15484 
      ldv_free((void *)ldv_33_ldv_param_3_5);
      
#line 15485 
      ldv_free((void *)ldv_33_ldv_param_1_4);
    }
    
#line 15489 
    goto ldv_32100;
    default: 
#line 15491 
    ;
    
#line 15491 
    __VERIFIER_assume(0);
  }
  ldv_32100: 
#line 15500 
  ;
  
#line 15500 
  goto ldv_call_33;
  
#line 15502 
  __retres = (void *)0;
  return_label: 
#line 15502 
                return __retres;
}


#line 15507  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_78(void *arg0)
{
  void *__retres;
  struct file *ldv_78_resource_1;
  int ldv_78_ldv_param_2_3;
  long long ldv_78_ldv_param_1_2;
  char *ldv_78_ldv_param_1_4;
  struct inode *ldv_78_resource_0;
  unsigned long ldv_78_size_cnt;
  long long *ldv_78_ldv_param_3_5;
  char *ldv_78_ldv_param_1_6;
  long long *ldv_78_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 15518 
  struct file_operations *ldv_78_container = ldv_emg_alias_aes_decrypt_interrupt_ops_2;
  
#line 15519 
  int ldv_78_ret = ldv_undef_int();
  
#line 15522 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 15526 
  ldv_78_ret = ldv_undef_int();
  
#line 15529 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 15530 
    ldv_78_container = data->arg0;
    
#line 15531 
    ldv_free((void *)data);
  }
  else ;
  
#line 15536 
  ldv_78_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 15537 
  tmp_1 = ldv_undef_int();
  
#line 15537 
  ldv_78_size_cnt = (unsigned long)tmp_1;
  
#line 15544 
  goto ldv_main_78;
  
#line 15546 
  __retres = (void *)0;
  
#line 15546 
  goto return_label;
  ldv_main_78: 
#line 15549 
  ;
  
#line 15552 
  tmp_3 = ldv_undef_int();
  
#line 15552 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 15555 
    ldv_78_ret = (*ldv_emg_alias_simple_open_5)(ldv_78_resource_0,ldv_78_resource_1);
    
#line 15557 
    ldv_78_ret = ldv_filter_err_code(ldv_78_ret);
    
#line 15560 
    tmp_2 = ldv_undef_int();
    
#line 15560 
    if (tmp_2 != 0) {
      
#line 15562 
      __VERIFIER_assume(ldv_78_ret == 0);
      
#line 15569 
      goto ldv_call_78;
    }
    else {
      
#line 15573 
      __VERIFIER_assume(ldv_78_ret != 0);
      
#line 15580 
      goto ldv_main_78;
    }
  }
  else {
    
#line 15585 
    ldv_free((void *)ldv_78_resource_0);
    
#line 15593 
    __retres = (void *)0;
    
#line 15593 
    goto return_label;
  }
  
#line 15596 
  __retres = (void *)0;
  
#line 15596 
  goto return_label;
  ldv_call_78: 
#line 15599 
  ;
  
#line 15602 
  tmp_4 = ldv_undef_int();
  
#line 15602 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 15603 
    ;
    
#line 15605 
    ldv_78_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 15606 
    ldv_78_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 15610 
    if (ldv_78_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 15616 
      __VERIFIER_assume(ldv_78_size_cnt <= 2147479552UL);
      
#line 15618 
      (*(ldv_78_container->write))(ldv_78_resource_1,(char const *)ldv_78_ldv_param_1_6,ldv_78_size_cnt,ldv_78_ldv_param_3_7);
    }
    else ;
    
#line 15623 
    ldv_free((void *)ldv_78_ldv_param_3_7);
    
#line 15624 
    ldv_free((void *)ldv_78_ldv_param_1_6);
    
#line 15631 
    goto ldv_call_78;
    case 2: 
#line 15634 
    ;
    
#line 15636 
    if (ldv_78_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 15638 
      (*(ldv_78_container->release))(ldv_78_resource_0,ldv_78_resource_1); else ;
    
#line 15646 
    goto ldv_main_78;
    case 3: 
#line 15649 
    ;
    
#line 15653 
    tmp_9 = ldv_undef_int();
    
#line 15653 
    if (tmp_9 != 0) 
#line 15656 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_78_resource_1,ldv_78_ldv_param_1_2,ldv_78_ldv_param_2_3);
    else {
      
#line 15662 
      ldv_78_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 15663 
      ldv_78_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 15668 
      ldv_emg_wrapper_aes_decrypt_interrupt_read_3(ldv_78_resource_1,ldv_78_ldv_param_1_4,ldv_78_size_cnt,ldv_78_ldv_param_3_5);
      
#line 15672 
      ldv_free((void *)ldv_78_ldv_param_3_5);
      
#line 15673 
      ldv_free((void *)ldv_78_ldv_param_1_4);
    }
    
#line 15677 
    goto ldv_32122;
    default: 
#line 15679 
    ;
    
#line 15679 
    __VERIFIER_assume(0);
  }
  ldv_32122: 
#line 15688 
  ;
  
#line 15688 
  goto ldv_call_78;
  
#line 15690 
  __retres = (void *)0;
  return_label: 
#line 15690 
                return __retres;
}


#line 15695  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_57(void *arg0)
{
  void *__retres;
  struct file *ldv_57_resource_1;
  int ldv_57_ldv_param_2_3;
  long long ldv_57_ldv_param_1_2;
  char *ldv_57_ldv_param_1_4;
  struct inode *ldv_57_resource_0;
  unsigned long ldv_57_size_cnt;
  long long *ldv_57_ldv_param_3_5;
  char *ldv_57_ldv_param_1_6;
  long long *ldv_57_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 15706 
  struct file_operations *ldv_57_container = ldv_emg_alias_pwr_disable_ps_ops_2;
  
#line 15707 
  int ldv_57_ret = ldv_undef_int();
  
#line 15710 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 15714 
  ldv_57_ret = ldv_undef_int();
  
#line 15717 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 15718 
    ldv_57_container = data->arg0;
    
#line 15719 
    ldv_free((void *)data);
  }
  else ;
  
#line 15724 
  ldv_57_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 15725 
  tmp_1 = ldv_undef_int();
  
#line 15725 
  ldv_57_size_cnt = (unsigned long)tmp_1;
  
#line 15732 
  goto ldv_main_57;
  
#line 15734 
  __retres = (void *)0;
  
#line 15734 
  goto return_label;
  ldv_main_57: 
#line 15737 
  ;
  
#line 15740 
  tmp_3 = ldv_undef_int();
  
#line 15740 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 15743 
    ldv_57_ret = (*ldv_emg_alias_simple_open_5)(ldv_57_resource_0,ldv_57_resource_1);
    
#line 15745 
    ldv_57_ret = ldv_filter_err_code(ldv_57_ret);
    
#line 15748 
    tmp_2 = ldv_undef_int();
    
#line 15748 
    if (tmp_2 != 0) {
      
#line 15750 
      __VERIFIER_assume(ldv_57_ret == 0);
      
#line 15757 
      goto ldv_call_57;
    }
    else {
      
#line 15761 
      __VERIFIER_assume(ldv_57_ret != 0);
      
#line 15768 
      goto ldv_main_57;
    }
  }
  else {
    
#line 15773 
    ldv_free((void *)ldv_57_resource_0);
    
#line 15781 
    __retres = (void *)0;
    
#line 15781 
    goto return_label;
  }
  
#line 15784 
  __retres = (void *)0;
  
#line 15784 
  goto return_label;
  ldv_call_57: 
#line 15787 
  ;
  
#line 15790 
  tmp_4 = ldv_undef_int();
  
#line 15790 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 15791 
    ;
    
#line 15793 
    ldv_57_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 15794 
    ldv_57_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 15798 
    if (ldv_57_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 15804 
      __VERIFIER_assume(ldv_57_size_cnt <= 2147479552UL);
      
#line 15806 
      (*(ldv_57_container->write))(ldv_57_resource_1,(char const *)ldv_57_ldv_param_1_6,ldv_57_size_cnt,ldv_57_ldv_param_3_7);
    }
    else ;
    
#line 15811 
    ldv_free((void *)ldv_57_ldv_param_1_6);
    
#line 15812 
    ldv_free((void *)ldv_57_ldv_param_3_7);
    
#line 15819 
    goto ldv_call_57;
    case 2: 
#line 15822 
    ;
    
#line 15824 
    if (ldv_57_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 15826 
      (*(ldv_57_container->release))(ldv_57_resource_0,ldv_57_resource_1); else ;
    
#line 15834 
    goto ldv_main_57;
    case 3: 
#line 15837 
    ;
    
#line 15841 
    tmp_9 = ldv_undef_int();
    
#line 15841 
    if (tmp_9 != 0) 
#line 15844 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_57_resource_1,ldv_57_ldv_param_1_2,ldv_57_ldv_param_2_3);
    else {
      
#line 15850 
      ldv_57_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 15851 
      ldv_57_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 15856 
      ldv_emg_wrapper_pwr_disable_ps_read_3(ldv_57_resource_1,ldv_57_ldv_param_1_4,ldv_57_size_cnt,ldv_57_ldv_param_3_5);
      
#line 15860 
      ldv_free((void *)ldv_57_ldv_param_1_4);
      
#line 15861 
      ldv_free((void *)ldv_57_ldv_param_3_5);
    }
    
#line 15865 
    goto ldv_32144;
    default: 
#line 15867 
    ;
    
#line 15867 
    __VERIFIER_assume(0);
  }
  ldv_32144: 
#line 15876 
  ;
  
#line 15876 
  goto ldv_call_57;
  
#line 15878 
  __retres = (void *)0;
  return_label: 
#line 15878 
                return __retres;
}


#line 15883  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_60(void *arg0)
{
  void *__retres;
  struct file *ldv_60_resource_1;
  int ldv_60_ldv_param_2_3;
  long long ldv_60_ldv_param_1_2;
  char *ldv_60_ldv_param_1_4;
  struct inode *ldv_60_resource_0;
  unsigned long ldv_60_size_cnt;
  long long *ldv_60_ldv_param_3_5;
  char *ldv_60_ldv_param_1_6;
  long long *ldv_60_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 15894 
  struct file_operations *ldv_60_container = ldv_emg_alias_pwr_elp_enter_ops_2;
  
#line 15895 
  int ldv_60_ret = ldv_undef_int();
  
#line 15898 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 15902 
  ldv_60_ret = ldv_undef_int();
  
#line 15905 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 15906 
    ldv_60_container = data->arg0;
    
#line 15907 
    ldv_free((void *)data);
  }
  else ;
  
#line 15912 
  ldv_60_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 15913 
  tmp_1 = ldv_undef_int();
  
#line 15913 
  ldv_60_size_cnt = (unsigned long)tmp_1;
  
#line 15920 
  goto ldv_main_60;
  
#line 15922 
  __retres = (void *)0;
  
#line 15922 
  goto return_label;
  ldv_main_60: 
#line 15925 
  ;
  
#line 15928 
  tmp_3 = ldv_undef_int();
  
#line 15928 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 15931 
    ldv_60_ret = (*ldv_emg_alias_simple_open_5)(ldv_60_resource_0,ldv_60_resource_1);
    
#line 15933 
    ldv_60_ret = ldv_filter_err_code(ldv_60_ret);
    
#line 15936 
    tmp_2 = ldv_undef_int();
    
#line 15936 
    if (tmp_2 != 0) {
      
#line 15938 
      __VERIFIER_assume(ldv_60_ret == 0);
      
#line 15945 
      goto ldv_call_60;
    }
    else {
      
#line 15949 
      __VERIFIER_assume(ldv_60_ret != 0);
      
#line 15956 
      goto ldv_main_60;
    }
  }
  else {
    
#line 15961 
    ldv_free((void *)ldv_60_resource_0);
    
#line 15969 
    __retres = (void *)0;
    
#line 15969 
    goto return_label;
  }
  
#line 15972 
  __retres = (void *)0;
  
#line 15972 
  goto return_label;
  ldv_call_60: 
#line 15975 
  ;
  
#line 15978 
  tmp_4 = ldv_undef_int();
  
#line 15978 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 15979 
    ;
    
#line 15981 
    ldv_60_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 15982 
    ldv_60_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 15986 
    if (ldv_60_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 15992 
      __VERIFIER_assume(ldv_60_size_cnt <= 2147479552UL);
      
#line 15994 
      (*(ldv_60_container->write))(ldv_60_resource_1,(char const *)ldv_60_ldv_param_1_6,ldv_60_size_cnt,ldv_60_ldv_param_3_7);
    }
    else ;
    
#line 15999 
    ldv_free((void *)ldv_60_ldv_param_1_6);
    
#line 16000 
    ldv_free((void *)ldv_60_ldv_param_3_7);
    
#line 16007 
    goto ldv_call_60;
    case 2: 
#line 16010 
    ;
    
#line 16012 
    if (ldv_60_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 16014 
      (*(ldv_60_container->release))(ldv_60_resource_0,ldv_60_resource_1); else ;
    
#line 16022 
    goto ldv_main_60;
    case 3: 
#line 16025 
    ;
    
#line 16029 
    tmp_9 = ldv_undef_int();
    
#line 16029 
    if (tmp_9 != 0) 
#line 16032 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_60_resource_1,ldv_60_ldv_param_1_2,ldv_60_ldv_param_2_3);
    else {
      
#line 16038 
      ldv_60_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 16039 
      ldv_60_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 16044 
      ldv_emg_wrapper_pwr_elp_enter_read_3(ldv_60_resource_1,ldv_60_ldv_param_1_4,ldv_60_size_cnt,ldv_60_ldv_param_3_5);
      
#line 16048 
      ldv_free((void *)ldv_60_ldv_param_3_5);
      
#line 16049 
      ldv_free((void *)ldv_60_ldv_param_1_4);
    }
    
#line 16053 
    goto ldv_32166;
    default: 
#line 16055 
    ;
    
#line 16055 
    __VERIFIER_assume(0);
  }
  ldv_32166: 
#line 16064 
  ;
  
#line 16064 
  goto ldv_call_60;
  
#line 16066 
  __retres = (void *)0;
  return_label: 
#line 16066 
                return __retres;
}


#line 16071  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl12xx/wl12xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_70(void *arg0)
{
  void *__retres;
  struct file *ldv_70_resource_1;
  int ldv_70_ldv_param_2_3;
  long long ldv_70_ldv_param_1_2;
  char *ldv_70_ldv_param_1_4;
  struct inode *ldv_70_resource_0;
  unsigned long ldv_70_size_cnt;
  long long *ldv_70_ldv_param_3_5;
  char *ldv_70_ldv_param_1_6;
  long long *ldv_70_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 16082 
  struct file_operations *ldv_70_container = ldv_emg_alias_wep_default_key_count_ops_2;
  
#line 16083 
  int ldv_70_ret = ldv_undef_int();
  
#line 16086 
  struct ldv_struct_character_driver_scenario_5 *data = (struct ldv_struct_character_driver_scenario_5 *)arg0;
  
#line 16090 
  ldv_70_ret = ldv_undef_int();
  
#line 16093 
  if (data != (struct ldv_struct_character_driver_scenario_5 *)0) {
    
#line 16094 
    ldv_70_container = data->arg0;
    
#line 16095 
    ldv_free((void *)data);
  }
  else ;
  
#line 16100 
  ldv_70_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 16101 
  tmp_1 = ldv_undef_int();
  
#line 16101 
  ldv_70_size_cnt = (unsigned long)tmp_1;
  
#line 16108 
  goto ldv_main_70;
  
#line 16110 
  __retres = (void *)0;
  
#line 16110 
  goto return_label;
  ldv_main_70: 
#line 16113 
  ;
  
#line 16116 
  tmp_3 = ldv_undef_int();
  
#line 16116 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 16119 
    ldv_70_ret = (*ldv_emg_alias_simple_open_5)(ldv_70_resource_0,ldv_70_resource_1);
    
#line 16121 
    ldv_70_ret = ldv_filter_err_code(ldv_70_ret);
    
#line 16124 
    tmp_2 = ldv_undef_int();
    
#line 16124 
    if (tmp_2 != 0) {
      
#line 16126 
      __VERIFIER_assume(ldv_70_ret == 0);
      
#line 16133 
      goto ldv_call_70;
    }
    else {
      
#line 16137 
      __VERIFIER_assume(ldv_70_ret != 0);
      
#line 16144 
      goto ldv_main_70;
    }
  }
  else {
    
#line 16149 
    ldv_free((void *)ldv_70_resource_0);
    
#line 16157 
    __retres = (void *)0;
    
#line 16157 
    goto return_label;
  }
  
#line 16160 
  __retres = (void *)0;
  
#line 16160 
  goto return_label;
  ldv_call_70: 
#line 16163 
  ;
  
#line 16166 
  tmp_4 = ldv_undef_int();
  
#line 16166 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 16167 
    ;
    
#line 16169 
    ldv_70_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 16170 
    ldv_70_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 16174 
    if (ldv_70_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 16180 
      __VERIFIER_assume(ldv_70_size_cnt <= 2147479552UL);
      
#line 16182 
      (*(ldv_70_container->write))(ldv_70_resource_1,(char const *)ldv_70_ldv_param_1_6,ldv_70_size_cnt,ldv_70_ldv_param_3_7);
    }
    else ;
    
#line 16187 
    ldv_free((void *)ldv_70_ldv_param_1_6);
    
#line 16188 
    ldv_free((void *)ldv_70_ldv_param_3_7);
    
#line 16195 
    goto ldv_call_70;
    case 2: 
#line 16198 
    ;
    
#line 16200 
    if (ldv_70_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 16202 
      (*(ldv_70_container->release))(ldv_70_resource_0,ldv_70_resource_1); else ;
    
#line 16210 
    goto ldv_main_70;
    case 3: 
#line 16213 
    ;
    
#line 16217 
    tmp_9 = ldv_undef_int();
    
#line 16217 
    if (tmp_9 != 0) 
#line 16220 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_70_resource_1,ldv_70_ldv_param_1_2,ldv_70_ldv_param_2_3);
    else {
      
#line 16226 
      ldv_70_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 16227 
      ldv_70_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 16232 
      ldv_emg_wrapper_wep_default_key_count_read_3(ldv_70_resource_1,ldv_70_ldv_param_1_4,ldv_70_size_cnt,ldv_70_ldv_param_3_5);
      
#line 16236 
      ldv_free((void *)ldv_70_ldv_param_3_5);
      
#line 16237 
      ldv_free((void *)ldv_70_ldv_param_1_4);
    }
    
#line 16241 
    goto ldv_32188;
    default: 
#line 16243 
    ;
    
#line 16243 
    __VERIFIER_assume(0);
  }
  ldv_32188: 
#line 16252 
  ;
  
#line 16252 
  goto ldv_call_70;
  
#line 16254 
  __retres = (void *)0;
  return_label: 
#line 16254 
                return __retres;
}


