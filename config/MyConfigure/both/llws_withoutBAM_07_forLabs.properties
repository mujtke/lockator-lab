# 去掉了UsgaeTransferRelation中重复添加的操作

analysis.algorithm.CEGAR = true
analysis.functionPointerCalls = true
analysis.functionPointerTargets = USED_IN_CODE, EQ_PARAM_TYPES, EQ_PARAM_COUNT, RETURN_VALUE
analysis.matchAssignedFunctionPointers = true
analysis.matchAssignedFunctionPointers.ignoreUnknownAssignments = true
analysis.name = llws_withoutBAM_07_forLabs
analysis.reachedSet = USAGE
analysis.summaryEdges = true
analysis.threadOperationsTransform = true
analysis.traversal.order = dfs
analysis.traversal.useCallstack = true
analysis.traversal.useReversePostorder = true

cegar.globalRefinement = true
cegar.refiner = cpa.usage.refinement.IdentifierIterator
console_sem.lock = acquire_console_sem
console_sem.maxDepth = 2
console_sem.unlock = release_console_sem
copy_from_user.pInfo = WRITE:1, READ:1, READ:0
copy_to_user.pInfo = WRITE:1, READ:1, READ:0
coverage.enabled = true

# CPAs
cpa = cpa.arg.ARGCPA
ARGCPA.cpa = cpa.usage.UsageCPA
UsageCPA.cpa = cpa.composite.CompositeCPA
CompositeCPA.cpas = cpa.location.LocationCPA, cpa.callstack.CallstackCPA, cpa.thread.ThreadCPA, cpa.lock.LockCPA, cpa.predicate.PredicateCPA, cpa.functionpointer.FunctionPointerCPA
# CompositeCPA.cpas = cpa.location.LocationCPA, cpa.callstack.CallstackCPA, cpa.thread.ThreadCPA, cpa.lock.LockCPA, cpa.bdd.BDDCPA, cpa.functionpointer.FunctionPointerCPA

cpa.arg.witness.removeInsufficientEdges = false
cpa.callstack.skipRecursion = true
cpa.lock.lockinfo = mutex_lock, spin_lock, rtnl_lock, console_sem, rwsem
cpa.lock.reduceLockCounters = BLOCK
cpa.lock.reduceUselessLocks = false
cpa.lock.refinement = false
cpa.lock.stopAfterLockLimit = true
cpa.predicate.allowedUnsupportedFunctions = memset,memmove,memcpy,__atomic_store_n,__builtin_umull_overflow, __builtin_mul_overflow, __builtin_add_overflow
cpa.predicate.defaultArrayLength = 1
cpa.predicate.deferUntypedAllocations = true
cpa.predicate.encodeBitvectorAs = INTEGER
cpa.predicate.encodeFloatAs = RATIONAL
cpa.predicate.handlePointerAliasing = true
cpa.predicate.maxArrayLength = 1
cpa.predicate.maxPreFilledAllocationSize = 0
cpa.predicate.memoryAllocationsAlwaysSucceed = true
cpa.predicate.nondetFunctions = ldv_undef_int
cpa.predicate.refinement.checkPath = false
cpa.predicate.refinement.predicateBasisStrategy = subgraph
cpa.predicate.revealAllocationTypeFromLhs = true
cpa.predicate.trackFunctionPointers = false
cpa.predicate.useArraysForHeap = false
cpa.predicate.useBitwiseAxioms = true
cpa.predicate.useConstraintOptimization = false
cpa.predicate.useHavocAbstraction = false
cpa.thread.skipTheSameThread = true
cpa.predicate.blk.alwaysAfterAssume = true


cpa.usage.abortfunctions = __exit, pthread_exit, panic, ldv_check_final_state
cpa.usage.binderFunctions = INIT_LIST_HEAD, list_add, list_add_tail, list_del, list_replace, list_replace_init, list_del_init, list_move, list_move_tail, list_is_last, list_empty, ldv_list_get_first, ldv_list_is_stop, ldv_list_get_next, memcpy, virtqueue_add_buf, rcu_assign_pointer,copy_to_user,copy_from_user,kfree,list_add_tail_rcu
cpa.usage.filterMissedFiles = false
cpa.usage.filterSimilarUnsafes = true
cpa.usage.outputType = KLEVER3
cpa.usage.precision = localsave
cpa.usage.printOnlyTrueUnsafes = true
cpa.usage.printUnsafesIfUnknown = true
cpa.usage.processCoveredUsages = false
cpa.usage.refinement.disableAllCaching = true
# 不限制细化次数
cpa.usage.refinement.iterationLimit = 10
cpa.usage.refinement.refinementChain = IdentifierIterator, PointIterator, UsageIterator, PathIterator, PredicateRefiner
cpa.usage.skippedfunctions = mfree_annotated
cpa.usage.skippedvariables.byFunction = entry_point, INIT_LIST_HEAD, __list_del, __list_add, list_add
cpa.usage.skippedvariables.byFunctionPrefix = ldv_initialize
cpa.usage.skippedvariables.byNamePrefix = ldv_, emg_, __ldv
cpa.usage.skippedvariables.byType = struct ath_tx_stats
cpa.usage.unsafedetector.ignoreEmptyLockset = false
cpa.usage.useSoundRegions = false
cpa.usage.export.witnessTemplate = witness.%s.graphml


INIT_LIST_HEAD.pInfo = WRITE:1
kfree.pInfo = WRITE:1
ldv_list_get_first.linkInfo = 0, 1
ldv_list_get_first.pInfo = READ:1
ldv_list_get_next.linkInfo = 0, 1
ldv_list_get_next.pInfo = READ:1
ldv_list_is_stop.pInfo = READ:1, READ:1
list_add.linkInfo = 1, 2
list_add.pInfo = WRITE:1, WRITE:1
list_add_tail.linkInfo = 1, 2
list_add_tail.pInfo = WRITE:1, WRITE:1
list_add_tail_rcu.pInfo = READ:1, WRITE:1
list_del.pInfo = WRITE:1
list_del_init.pInfo = WRITE:1
list_empty.pInfo = READ:1
list_is_last.pInfo = READ:1, READ:1
list_move.linkInfo = 1, 2
list_move.pInfo = WRITE:1, WRITE:1
list_move_tail.linkInfo = 1, 2
list_move_tail.pInfo = WRITE:1, WRITE:1
list_replace.linkInfo = 2, 1
list_replace.pInfo = WRITE:1, WRITE:1
list_replace_init.linkInfo = 2, 1
list_replace_init.pInfo = WRITE:1, WRITE:1
log.level = INFO
memcpy.pInfo = WRITE:1, READ:1, READ:0
mutex_lock.ldv_mutex_model_lock.parameters = 2
mutex_lock.ldv_mutex_model_unlock.parameters = 2
mutex_lock.lock = ldv_mutex_model_lock, pthread_mutex_lock
mutex_lock.maxDepth = 2
mutex_lock.unlock = ldv_mutex_model_unlock, pthread_mutex_unlock
output.disable = false
precision.path = localsave
rcu_assign_pointer.pInfo = WRITE:0, READ:0
# restartAlgorithm.alwaysRestart = true
rtnl_lock.lock = rtnl_lock
rtnl_lock.maxDepth = 2
rtnl_lock.unlock = rtnl_unlock, __rtnl_unlock
rw_sem.ldv_spin_lock.parameters = 1
rw_sem.ldv_spin_unlock.parameters = 1
rw_sem.lock = down_write, down_read
rw_sem.maxDepth = 2
rw_sem.unlock = up_write, down_write
solver.solver = SMTINTERPOL
specification = 
spin_lock.ldv_spin_lock.parameters = 1
spin_lock.ldv_spin_unlock.parameters = 1
spin_lock.lock = ldv_spin_model_lock
spin_lock.maxDepth = 2
spin_lock.unlock = ldv_spin_model_unlock
statistics.memory = true
virtqueue_add_buf.pInfo = WRITE:1, READ:1, READ:0, READ:0, READ:1, READ:0
