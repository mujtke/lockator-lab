analysis.algorithm.CEGAR = true
analysis.functionPointerCalls = true
analysis.functionPointerTargets = USED_IN_CODE, EQ_PARAM_TYPES, EQ_PARAM_COUNT, RETURN_VALUE
analysis.matchAssignedFunctionPointers = true
analysis.matchAssignedFunctionPointers.ignoreUnknownAssignments = true
analysis.name = plan_B_v0
analysis.reachedSet = USAGE
# analysis.restartAfterUnknown = false


# CFA创建相关的内容
# 创建摘要调用语句边-“create summary call statement edges”
analysis.summaryEdges = true

# 用一个特殊的函数调用来取代线程创建函数
analysis.threadOperationsTransform = true
analysis.traversal.order = bfs
analysis.traversal.useCallstack = true
# 如果两个状态的后序遍历编号一样，则采用第二策略
analysis.traversal.useReversePostorder = true

# 在ARG构建完全之后进行细化，还是一发现ERROR就开始细化
cegar.globalRefinement = true
cegar.refiner = cpa.usage.refinement.IdentifierIterator


cfa.callgraph.export = true
cfa.callgraph.file = thread_test/callGraphs/plan_B_v0.dot
cfa.export = true
cfa.exportPerFunction = true
configuration.dumpFile = thread_test/configFiles/plan_B_v0.properties


console_sem.lock = acquire_console_sem
console_sem.maxDepth = 2
console_sem.unlock = release_console_sem
copy_from_user.pInfo = WRITE:1, READ:1, READ:0
copy_to_user.pInfo = WRITE:1, READ:1, READ:0
counterexample.export.enabled = true
counterexample.export.exportWitness = true
coverage.enabled = true
coverage.file = thread_test/coverInfo/plan_B_v0.info

# CPAs
# cpa = cpa.bam.BAMCPA
cpa = cpa.arg.ARGCPA
ARGCPA.cpa = cpa.usage.UsageCPA
UsageCPA.cpa = cpa.composite.CompositeCPA
CompositeCPA.cpas = cpa.location.LocationCPA, cpa.callstack.CallstackCPA, cpa.thread.ThreadCPA, cpa.lock.LockCPA, cpa.predicate.PredicateCPA, cpa.functionpointer.FunctionPointerCPA

cpa.arg.errorPath.export = true
cpa.arg.export = true
cpa.arg.file = thread_test/argFiles/plan_B_v0.dot
cpa.arg.witness.removeInsufficientEdges = false
# 跳过递归，将函数调用视作语句（与调用没有函数体的函数相同）
cpa.callstack.skipRecursion = true

# 包含所有的锁名字
cpa.lock.lockinfo = mutex_lock, spin_lock, rtnl_lock, console_sem, rwsem
cpa.lock.reduceLockCounters = BLOCK
# reduce unused locks
cpa.lock.reduceUselessLocks = false
cpa.lock.refinement = false
# stop path exploration if a lock limit is reached
cpa.lock.stopAfterLockLimit = true


cpa.predicate.allowedUnsupportedFunctions = memset,memmove,memcpy,__atomic_store_n,__builtin_umull_overflow, __builtin_mul_overflow, __builtin_add_overflow
cpa.predicate.defaultArrayLength = 1
# Use deferred allocation heuristic that tracks void * variables until the actual type of the allocation is figured out
cpa.predicate.deferUntypedAllocations = true
cpa.predicate.encodeBitvectorAs = INTEGER
cpa.predicate.encodeFloatAs = RATIONAL
cpa.predicate.handlePointerAliasing = true
cpa.predicate.maxArrayLength = 1
cpa.predicate.maxPreFilledAllocationSize = 0
cpa.predicate.memoryAllocationsAlwaysSucceed = true
cpa.predicate.nondetFunctions = ldv_undef_int
# Path checking takes a lot of time, sometimes we need a quick result
cpa.predicate.refinement.checkPath = false
# 谓词保留策略，例如“subgraph”会收集来自ARG中被移除的子图部分所产生的谓词
cpa.predicate.refinement.predicateBasisStrategy = subgraph
# 允许使用LHS的类型来检测内存分配的类型，e.g. char *arr = malloc(size) is detected as char[size]
cpa.predicate.revealAllocationTypeFromLhs = true
# Whether to track values stored in variables of function-pointer type.
cpa.predicate.trackFunctionPointers = false
# 使用SMT数组来编码堆内存而不是未解释函数，更精确但是有可能导致插值失败
cpa.predicate.useArraysForHeap = false
# 使用一些简单公理来简化按位操作
cpa.predicate.useBitwiseAxioms = true
cpa.predicate.useConstraintOptimization = false
# 对共享变量可能的取值进行过近似
cpa.predicate.useHavocAbstraction = false
# 相同的线程被创建多次选择跳过或认为fail
cpa.thread.skipTheSameThread = true


# 让分析停止的函数
cpa.usage.abortfunctions = __exit, pthread_exit, panic, ldv_check_final_state
# functions, which are used to bind variables (like list elements are binded to list variable)
cpa.usage.binderFunctions = INIT_LIST_HEAD, list_add, list_add_tail, list_del, list_replace, list_replace_init, list_del_init, list_move, list_move_tail, list_is_last, list_empty, ldv_list_get_first, ldv_list_is_stop, ldv_list_get_next, memcpy, virtqueue_add_buf, rcu_assign_pointer,copy_to_user,copy_from_user,kfree,list_add_tail_rcu
cpa.usage.export.witnessTemplate = witness.%s.graphml
# if a file do not exist, do not include the corresponding edge
cpa.usage.filterMissedFiles = false
# 过滤掉过于相似的Unsafes
cpa.usage.filterSimilarUnsafes = true
cpa.usage.outputType = KLEVER3
# a path to precision
cpa.usage.precision = localsave
cpa.usage.printOnlyTrueUnsafes = true
cpa.usage.printUnsafesIfUnknown = true
# Should we process the same blocks with covered sets of locks
cpa.usage.processCoveredUsages = false


cpa.usage.refinement.disableAllCaching = true
cpa.usage.refinement.iterationLimit = 2
cpa.usage.refinement.refinementChain = IdentifierIterator, PointIterator, UsageIterator, PathIterator, PredicateRefiner
# 不分析的函数
cpa.usage.skippedfunctions = mfree_annotated
# 通过函数位置过滤掉的变量
cpa.usage.skippedvariables.byFunction = entry_point, INIT_LIST_HEAD, __list_del, __list_add, list_add
# 通过函数前缀过滤掉的变量
cpa.usage.skippedvariables.byFunctionPrefix = ldv_initialize
cpa.usage.skippedvariables.byNamePrefix = ldv_, emg_, __ldv
cpa.usage.skippedvariables.byType = struct ath_tx_stats
# 忽略调用栈为空的Unsafes？
cpa.usage.unsafedetector.ignoreEmptyLockset = false
cpa.usage.useSoundRegions = false


INIT_LIST_HEAD.pInfo = WRITE:1
kfree.pInfo = WRITE:1
ldv_list_get_first.linkInfo = 0, 1
ldv_list_get_first.pInfo = READ:1
ldv_list_get_next.linkInfo = 0, 1
ldv_list_get_next.pInfo = READ:1
ldv_list_is_stop.pInfo = READ:1, READ:1
list_add.linkInfo = 1, 2
list_add.pInfo = WRITE:1, WRITE:1
list_add_tail.linkInfo = 1, 2
list_add_tail.pInfo = WRITE:1, WRITE:1
list_add_tail_rcu.pInfo = READ:1, WRITE:1
list_del.pInfo = WRITE:1
list_del_init.pInfo = WRITE:1
list_empty.pInfo = READ:1
list_is_last.pInfo = READ:1, READ:1
list_move.linkInfo = 1, 2
list_move.pInfo = WRITE:1, WRITE:1
list_move_tail.linkInfo = 1, 2
list_move_tail.pInfo = WRITE:1, WRITE:1
list_replace.linkInfo = 2, 1
list_replace.pInfo = WRITE:1, WRITE:1
list_replace_init.linkInfo = 2, 1
list_replace_init.pInfo = WRITE:1, WRITE:1
log.level = INFO
memcpy.pInfo = WRITE:1, READ:1, READ:0
mutex_lock.ldv_mutex_model_lock.parameters = 2
mutex_lock.ldv_mutex_model_unlock.parameters = 2
mutex_lock.lock = ldv_mutex_model_lock, pthread_mutex_lock
mutex_lock.maxDepth = 2
mutex_lock.unlock = ldv_mutex_model_unlock, pthread_mutex_unlock

rcu_assign_pointer.pInfo = WRITE:0, READ:0
report.export = true
report.file = plan_B_v0.html
counterexample.export.report = Counterexample.plan_B_v0.%d.html
# restartAlgorithm.alwaysRestart = true
rtnl_lock.lock = rtnl_lock
rtnl_lock.maxDepth = 2
rtnl_lock.unlock = rtnl_unlock, __rtnl_unlock
rw_sem.ldv_spin_lock.parameters = 1
rw_sem.ldv_spin_unlock.parameters = 1
rw_sem.lock = down_write, down_read
rw_sem.maxDepth = 2
rw_sem.unlock = up_write, down_write
solver.solver = SMTINTERPOL
specification = 
spin_lock.ldv_spin_lock.parameters = 1
spin_lock.ldv_spin_unlock.parameters = 1
spin_lock.lock = ldv_spin_model_lock
spin_lock.maxDepth = 2
spin_lock.unlock = ldv_spin_model_unlock
statistics.memory = true
virtqueue_add_buf.pInfo = WRITE:1, READ:1, READ:0, READ:0, READ:1, READ:0
