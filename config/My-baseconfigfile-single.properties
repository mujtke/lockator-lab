precision.path = localsave

# Disable all output files except the error path.
output.disable=true
cfa.export = false
cfa.exportPerFunction = false
cfa.callgraph.export = false
cpa.arg.export = false
counterexample.export.enabled = false
cpa.bam.exportARGs = false
cpa.bam.argFile=
cpa.bam.simplifiedArgFile=
report.export = false
coverage.enabled = true
coverage.file = coverage.info

# Disable statistics for memory consumption.
statistics.memory = true

[analysis]
# restartAfterUnknown = true
functionPointerCalls = true
matchAssignedFunctionPointers = true
matchAssignedFunctionPointers.ignoreUnknownAssignments=true
summaryEdges = true
threadOperationsTransform = true
functionPointerTargets = USED_IN_CODE, EQ_PARAM_TYPES, EQ_PARAM_COUNT, RETURN_VALUE



# CompositeCPA.cpas = cpa.location.LocationCPA, cpa.callstack.CallstackCPA, cpa.thread.ThreadCPA, cpa.lock.LockCPA, cpa.predicate.BAMPredicateCPA, cpa.functionpointer.FunctionPointerCPA
# cpa.usage.refinement. = IdentifierIterator, PointIterator, UsageIterator, PathIterator, PredicateRefiner

# 根据.xml文件中的-setprop配置 
CompositeCPA.cpas=cpa.location.LocationCPA,cpa.callstack.CallstackCPA,cpa.thread.ThreadCPA,cpa.lock.LockCPA,cpa.functionpointer.FunctionPointerCPA
cpa.usage.refinement.refinementChain=IdentifierIterator,PointIterator,UsageIterator,SinglePathIterator


solver.solver = SMTINTERPOL
analysis.algorithm.CEGAR = true

cpa.usage.printOnlyTrueUnsafes = true
cpa.usage.refinement.iterationLimit = 2
cpa.lock.refinement = false

[cegar]
refiner = cpa.usage.refinement.IdentifierIterator
globalRefinement = true
# maxIterations = 20


[cpa.predicate]
useBitwiseAxioms = true
encodeBitvectorAs = INTEGER
encodeFloatAs = RATIONAL
useArraysForHeap = false
defaultArrayLength = 1
maxArrayLength = 1
nondetFunctions = ldv_undef_int
useHavocAbstraction = false
useConstraintOptimization = false
# New heuristics: type detection and void* tracking
revealAllocationTypeFromLhs = true
deferUntypedAllocations = true
# New heuristic for cillified files: pre-populate small structures with all their fields
maxPreFilledAllocationSize = 0
# An option enabling PathFormulaWithUF, CToFormulaWithUFConverter and appropriate merging policy
handlePointerAliasing =  true
# Setting the option to make memory allocations always return correct addresses
memoryAllocationsAlwaysSucceed = true
# blk.alwaysAtJoin     = true
blk.alwaysAfterAssume = true
trackFunctionPointers=false
refinement.checkPath = false
allowedUnsupportedFunctions=memset,memmove,memcpy,__atomic_store_n,__builtin_umull_overflow, __builtin_mul_overflow, __builtin_add_overflow

[cpa.predicate.bam]
reduceIrrelevantPrecision = false
useAbstractionReduction = false
usePrecisionReduction = false
auxiliaryPredicateComputer = false


analysis.reachedSet = USAGE
cpa.bam.blockHeuristic = FunctionPartitioning
cpa.bam.aggressiveCaching = false

cpa.lock.reduceLockCounters = BLOCK
cpa.lock.reduceUselessLocks = false
cpa.lock.stopAfterLockLimit = true

# cpa.lock.stopMode = emptylockset
cpa.usage.refinement.disableAllCaching = true

cpa = cpa.bam.BAMCPA
BAMCPA.cpa = cpa.arg.ARGCPA
ARGCPA.cpa = cpa.usage.UsageCPA
UsageCPA.cpa = cpa.composite.CompositeCPA

cpa.usage.precision = localsave

# The block is not neccesary for analysis combination, as
# the are defined in global config
# Nevertheless, do not remove the options: someone can run the single analysis
cpa.callstack.skipRecursion = true
cpa.arg.errorPath.export = false

# 根据.xml文件配置
heap = 10000M
counterexample.export.exportWitness=false
counterexample.export.exportAsSource=false
cpa.predicate.refinement.predicateBasisStrategy=subgraph
# 


cfa.export = false
report.export = false
cpa.arg.witness.removeInsufficientEdges=false


[cpa.usage]
unsafedetector.ignoreEmptyLockset = false
printUnsafesIfUnknown = true
filterSimilarUnsafes = true
export.witnessTemplate = witness.%s.graphml
processCoveredUsages = false
# problems with shared analysis
useSoundRegions = false

[analysis.traversal]
order = bfs
useReversePostorder = true
useCallstack = true


cpa.lock.lockinfo = mutex_lock, spin_lock, rtnl_lock, console_sem, rwsem

[mutex_lock]
lock = ldv_mutex_model_lock, pthread_mutex_lock
ldv_mutex_model_lock.parameters = 2
unlock = ldv_mutex_model_unlock, pthread_mutex_unlock
ldv_mutex_model_unlock.parameters = 2
maxDepth = 2

[spin_lock]
lock = ldv_spin_model_lock
ldv_spin_lock.parameters = 1
unlock = ldv_spin_model_unlock
ldv_spin_unlock.parameters = 1
maxDepth = 2

[rtnl_lock]
lock = rtnl_lock
unlock = rtnl_unlock, __rtnl_unlock
maxDepth = 2

[console_sem]
lock = acquire_console_sem
unlock = release_console_sem
maxDepth = 2

[rw_sem]
lock = down_write, down_read
ldv_spin_lock.parameters = 1
unlock = up_write, down_write
ldv_spin_unlock.parameters = 1
maxDepth = 2

[cpa.usage]
abortfunctions = __exit, pthread_exit, panic, ldv_check_final_state
binderFunctions = INIT_LIST_HEAD, list_add, list_add_tail, list_del, list_replace, list_replace_init, list_del_init, list_move, list_move_tail, list_is_last, list_empty, ldv_list_get_first, ldv_list_is_stop, ldv_list_get_next, memcpy, virtqueue_add_buf, rcu_assign_pointer,copy_to_user,copy_from_user,kfree,list_add_tail_rcu
skippedvariables.byNamePrefix = ldv_, emg_, __ldv
skippedvariables.byType = struct ath_tx_stats
skippedvariables.byFunction = entry_point, INIT_LIST_HEAD, __list_del, __list_add, list_add
skippedvariables.byFunctionPrefix = ldv_initialize
skippedfunctions = mfree_annotated
filterMissedFiles = false
outputType = KLEVER3

[]
INIT_LIST_HEAD.pInfo = WRITE:1

list_add.pInfo = WRITE:1, WRITE:1
# first parameter (new) --> {redirect to} --> second parameter (list head)
list_add.linkInfo = 1, 2

list_add_tail.pInfo = WRITE:1, WRITE:1
list_add_tail.linkInfo = 1, 2

list_del.pInfo = WRITE:1

list_replace.pInfo = WRITE:1, WRITE:1
list_replace.linkInfo = 2, 1

list_replace_init.pInfo = WRITE:1, WRITE:1
list_replace_init.linkInfo = 2, 1

list_del_init.pInfo = WRITE:1

list_move.pInfo = WRITE:1, WRITE:1
list_move.linkInfo = 1, 2

list_move_tail.pInfo = WRITE:1, WRITE:1
list_move_tail.linkInfo = 1, 2

list_is_last.pInfo = READ:1, READ:1

list_empty.pInfo = READ:1

ldv_list_get_first.pInfo = READ:1
ldv_list_get_first.linkInfo = 0, 1

ldv_list_is_stop.pInfo = READ:1, READ:1

ldv_list_get_next.pInfo = READ:1
ldv_list_get_next.linkInfo = 0, 1

memcpy.pInfo = WRITE:1, READ:1, READ:0

virtqueue_add_buf.pInfo = WRITE:1, READ:1, READ:0, READ:0, READ:1, READ:0

rcu_assign_pointer.pInfo = WRITE:0, READ:0

copy_to_user.pInfo = WRITE:1, READ:1, READ:0

copy_from_user.pInfo = WRITE:1, READ:1, READ:0

kfree.pInfo = WRITE:1

list_add_tail_rcu.pInfo = READ:1, WRITE:1


cpa.thread.skipTheSameThread = true